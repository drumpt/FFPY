<?xml version="1.0" encoding="ISO-8859-1"?>
<bugrepository>
<bug id="78706" transactionid="70846">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="13"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="13"/>
<property name="lines-churned" value="13"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint/>
<fullfingerprint>Y</fullfingerprint>
<bugreport>This is the Rhino version of bug 76054 in SpiderMonkey -
Reporter: ajvincent@hotmail.com

"I've noticed the HTML methods of String.prototype return uppercase tags.  
The latest HTML recommendation from the W3C specifies lowercase tags -- 
example: &lt;big&gt;k&lt;/big&gt; instead of &lt;BIG&gt;k&lt;/BIG&gt;."

Reproducible: Always
Steps to Reproduce:
1. Type javascript:alert("k".big()) into your location bar.


Actual Results:    Alert window containing "&lt;BIG&gt;k&lt;/BIG&gt;".
Expected Results:  Alert window containing "&lt;big&gt;k&lt;/big&gt;".</bugreport>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/NativeString.java" revision="1.18" state="changed">749c749
&lt;         return tagify("B", null, null);
---
&gt;         return tagify("b", null, null);
753c753
&lt;         return tagify("I", null, null);
---
&gt;         return tagify("i", null, null);
757c757
&lt;         return tagify("TT", null, null);
---
&gt;         return tagify("tt", null, null);
761c761
&lt;         return tagify("STRIKE", null, null);
---
&gt;         return tagify("strike", null, null);
765c765
&lt;         return tagify("SMALL", null, null);
---
&gt;         return tagify("small", null, null);
769c769
&lt;         return tagify("BIG", null, null);
---
&gt;         return tagify("big", null, null);
773c773
&lt;         return tagify("BLINK", null, null);
---
&gt;         return tagify("blink", null, null);
777c777
&lt;         return tagify("SUP", null, null);
---
&gt;         return tagify("sup", null, null);
781c781
&lt;         return tagify("SUB", null, null);
---
&gt;         return tagify("sub", null, null);
785c785
&lt;         return tagify("FONT SIZE", "FONT", value);
---
&gt;         return tagify("font size", "font", value);
789c789
&lt;         return tagify("FONT COLOR", "FONT", value);
---
&gt;         return tagify("font color", "font", value);
793c793
&lt;         return tagify("A HREF", "A", value);
---
&gt;         return tagify("a href", "a", value);
797c797
&lt;         return tagify("A NAME", "A", value);
---
&gt;         return tagify("a name", "a", value);
</file>
</fixedFiles>
</bug>
<bug id="85880" transactionid="70875">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="6"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="3"/>
<property name="lines-modified" value="39"/>
<property name="lines-churned" value="42"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-finally K-if K-try M T V Z-if</fullfingerprint>
<bugreport>When run in interpreter mode (java org.mozilla.javascript.tools.shell.Main -opt
-1), the following prints "null" instead of expected "[object Arguments]":

function g(x) {
}

function f() {
	g();
	return f.arguments;
}

print(f(0))

I beliave this is caused by the following code in omj/ScriptRuntime.java, lines
1725-1727:

stack[stackTop] = ScriptRuntime.call(cx, lhs, rhs, 
                                     outArgs, 
                                     calleeScope);
if (theData.itsNeedsActivation) {
    ScriptRuntime.popActivation(cx);
}

which removes activation object after each function call.</bugreport>
<testsforfix id="85880" type="new">
<test file="mozilla/js/tests/ecma_3/Function/regress-85880.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/Interpreter.java" revision="1.46" state="changed">789,790c789,790
&lt;                        	    iCodeTop = addNumber(num, iCodeTop);
&lt;                        	}
---
&gt;                             iCodeTop = addNumber(num, iCodeTop);
&gt;                         }
1725,1727d1724
&lt;                         if (theData.itsNeedsActivation) {
&lt;                             ScriptRuntime.popActivation(cx);
&lt;                         }
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/NativeCall.java" revision="1.14" state="changed">57c57,66
&lt;         this(cx, scope, funObj, thisObj);
---
&gt;         this.funObj = funObj;
&gt;         this.thisObj = thisObj;
&gt;         
&gt;         setParentScope(scope);
&gt;         // leave prototype null
&gt;         
&gt;         // save current activation
&gt;         this.caller = cx.currentActivation;
&gt;         cx.currentActivation = this;
&gt; 
74,88c83
&lt;     NativeCall(Context cx, Scriptable scope, NativeFunction funObj, 
&lt;                Scriptable thisObj)
&lt;     {
&lt;         this.funObj = funObj;
&lt;         this.thisObj = thisObj;
&lt;         
&lt;         setParentScope(scope);
&lt;         // leave prototype null
&lt;         
&lt;         // save current activation
&lt;         this.caller = cx.currentActivation;
&lt;         cx.currentActivation = this;
&lt;     }
&lt;     
&lt;     NativeCall() {
---
&gt;     private NativeCall() {
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/InterpretedFunction.java" revision="1.18" state="changed">84c84,85
&lt;         if (itsData.itsNeedsActivation)
---
&gt;         
&gt;         if (itsData.itsNeedsActivation) {
86c87,96
&lt;         return Interpreter.interpret(cx, scope, thisObj, args, this, itsData);
---
&gt;         }
&gt;         try {
&gt;             return Interpreter.interpret(cx, scope, thisObj, args, this,
&gt;                                          itsData);
&gt;         }
&gt;         finally {
&gt;             if (itsData.itsNeedsActivation) {
&gt;                 ScriptRuntime.popActivation(cx);
&gt;             }
&gt;         }
</file>
</fixedFiles>
</bug>
<bug id="114491" transactionid="70516">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="6"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="4"/>
<property name="lines-churned" value="10"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-return M O-!= O-cast T V Y Z-cast Z-if</fullfingerprint>
<bugreport>E:\p4test\main\dev&gt;java -version
java version "1.2.2"
Java HotSpot(TM) Server VM (2.0rc1, mixed mode, build I)

E:\p4test\main\dev&gt;java -jar e:/rhino/js.jar
js&gt; if (true) function f(){}()
Exception in thread "main" java.lang.NullPointerException
        at org.mozilla.javascript.IRFactory.setFunctionExpressionStatement(IRFac
tory.java:235)
        at org.mozilla.javascript.Parser.statementHelper(Parser.java:767)
        at org.mozilla.javascript.Parser.statement(Parser.java:334)
        at org.mozilla.javascript.Parser.statementHelper(Parser.java:376)
        at org.mozilla.javascript.Parser.statement(Parser.java:334)
        at org.mozilla.javascript.Parser.parse(Parser.java:133)
        at org.mozilla.javascript.Context.stringIsCompilableUnit(Context.java:81
0)
        at org.mozilla.javascript.tools.shell.Main.processSource(Main.java:213)
        at org.mozilla.javascript.tools.shell.Main.exec(Main.java:104)
        at org.mozilla.javascript.tools.shell.Main.main(Main.java:66)

Happens on linux with jdk1.3.0 too.</bugreport>
<testsforfix id="114491" type="new">
<test file="mozilla/js/tests/js1_5/Regress/regress-114491.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/Parser.java" revision="1.21" state="changed">812c812,815
&lt;                 if (lastExprType == ts.FUNCTION)
---
&gt;                 if (lastExprType == ts.FUNCTION) {
&gt;                     if (nf.getLeafType(pn) != ts.FUNCTION) {
&gt;                         reportError(ts, "msg.syntax");
&gt;                     }
813a817
&gt;                 }
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/IRFactory.java" revision="1.20" state="changed">84a85,89
&gt;     public int getLeafType(Object leaf) {
&gt;         Node n = (Node) leaf;
&gt;         return n.getType();
&gt;     }
&gt; 
</file>
</fixedFiles>
</bug>
<bug id="114493" transactionid="70524">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-if O-- O-!= T V Y Z-if</fullfingerprint>
<bugreport>E:\p4test\main\dev&gt;java -version
java version "1.2.2"
Java HotSpot(TM) Server VM (2.0rc1, mixed mode, build I)

E:\p4test\main\dev&gt;java -jar e:/rhino/js.jar
js&gt; "3"[5]()
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException
        at org.mozilla.javascript.Interpreter.getString(Interpreter.java:1132)
        at org.mozilla.javascript.Interpreter.interpret(Interpreter.java:1942)
        at org.mozilla.javascript.InterpretedScript.call(InterpretedScript.java:
68)
        at org.mozilla.javascript.InterpretedScript.exec(InterpretedScript.java:
59)
        at org.mozilla.javascript.Context.evaluateReader(Context.java:773)
        at org.mozilla.javascript.tools.shell.Main.evaluateReader(Main.java:293)

        at org.mozilla.javascript.tools.shell.Main.processSource(Main.java:217)
        at org.mozilla.javascript.tools.shell.Main.exec(Main.java:104)
        at org.mozilla.javascript.tools.shell.Main.main(Main.java:66)</bugreport>
<testsforfix id="114493" type="new">
<test file="mozilla/js/tests/js1_5/Regress/regress-114493.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/Interpreter.java" revision="1.61" state="changed">1920c1920,1922
&lt;                             lhs = strings[getShort(iCode, pc + 1)];
---
&gt;                             i = getShort(iCode, pc + 1);
&gt;                             if (i != -1)
&gt;                                 lhs = strings[i];
</file>
</fixedFiles>
</bug>
<bug id="137181" transactionid="67693">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="12"/>
<property name="lines-added" value="6"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="59"/>
<property name="lines-churned" value="66"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-if K-return K-super K-synchronized K-this K-true M O-&lt; O-== O-|| O-- O-!= O-?: O-() O-cast T V Y Z-cast Z-cond Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>Reported in the JS Engine newsgroup by ibukanov8@yahoo.com (Igor Bukanov):

"Given the following and my reading of Ecma-262

function test1(x) {
    x = 1;
    delete arguments[0];
    return x;
}

function test2(x) {
    x = 1;
    delete arguments[0];
    arguments[0] = -1;
    return x;
}


test1(0) and test2(0) should both return 1, since after |delete argument[0]|,
arguments[0] loses any connection with x, even if arguments[0] is recreated. 


From ECMA-262 Edition 3:


Section 10.1.8 Arguments Object

*  For each non-negative integer, arg, less than the value of the length
property, a property is created with name ToString(arg) and property
attributes { DontEnum }. The initial value of this property is the value 
of the corresponding actual parameter supplied by the caller. The first 
actual parameter value corresponds to arg = 0, the second to arg = 1, 
and so on. In the case when arg is less than the number of formal 
parameters for the Function object, this property shares its value with 
the corresponding property of the activation object. This means that 
changing this property changes the corresponding property of the 
activation object and vice versa.


Section 10.2.3 Function Code

*  Variable instantiation is performed using the activation object as 
the variable object and using property attributes { DontDelete }.


SpiderMonkey meets these expectations, but Rhino does not.
In Rhino, test1(0) returns |undefined|; test2(0) returns -1.


Note the testcase for bug 72884,

     mozilla/js/tests/ecma_3/Function/arguments-001.js

does not touch this area, so maybe it should be updated to
cover this issue as well -"



FOR REFERENCE:

bug 72884 (SpiderMonkey) "Arguments object has incorrect [[Prototype]] property"
bug 79568 (Rhino)        "delete on an arguments[i] not working correctly"</bugreport>
<testsforfix id="137181" type="new">
<test file="mozilla/js/tests/ecma_3/Function/regress-137181.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/Arguments.java" revision="1.17" state="changed">22a23
&gt;  * Igor Bukanov
75,76c76,81
&lt;         Object[] args = activation.getOriginalArguments();
&lt;         return (0 &lt;= index &amp;&amp; index &lt; args.length) || super.has(index, start);
---
&gt;         if (0 &lt;= index &amp;&amp; index &lt; args.length) {
&gt;             if (args[index] != NOT_FOUND) {
&gt;                 return true;
&gt;             }
&gt;         }
&gt;         return super.has(index, start);
81,82c86,105
&lt;             NativeFunction f = activation.funObj;
&lt;             if (index &lt; f.argCount) {
---
&gt;             Object value = args[index];
&gt;             if (value != NOT_FOUND) {
&gt;                 if (sharedWithActivation(index)) {
&gt;                     String argName = activation.funObj.argNames[index];
&gt;                     value = activation.get(argName, activation);
&gt;                     if (value == NOT_FOUND) Context.codeBug();
&gt;                 }
&gt;                 return value;
&gt;             }
&gt;         }
&gt;         return super.get(index, start);
&gt;     }
&gt; 
&gt;     private boolean sharedWithActivation(int index) {
&gt;         NativeFunction f = activation.funObj;
&gt;         int definedCount = f.argCount;
&gt;         if (index &lt; definedCount) {
&gt;             // Check if argument is not hidden by later argument with the same
&gt;             // name as hidden arguments are not shared with activation
&gt;             if (index &lt; definedCount - 1) {
84c107
&lt;                 for (int i=index+1; i &lt; f.argNames.length; i++) {
---
&gt;                 for (int i = index + 1; i &lt; definedCount; i++) {
86,90c109
&lt;                         // duplicate parameter name, must use initial
&lt;                         // parameter value
&lt;                         Object[] orig = activation.getOriginalArguments();
&lt;                         return index &lt; orig.length ? orig[index]
&lt;                                                    : Undefined.instance;
---
&gt;                         return false;
93d111
&lt;                 return activation.get(f.argNames[index], activation);
95c113
&lt;             return args[index];
---
&gt;             return true;
97c115
&lt;         return super.get(index, start);
---
&gt;         return false;
102,107c120,135
&lt;             NativeFunction f = activation.funObj;
&lt;             if (index &lt; f.argCount)
&lt;                 activation.put(f.argNames[index], activation, value);
&lt;             else
&lt;                 args[index] = value;
&lt;             return;
---
&gt;             if (args[index] != NOT_FOUND) {
&gt;                 if (sharedWithActivation(index)) {
&gt;                     String argName = activation.funObj.argNames[index];
&gt;                     activation.put(argName, activation, value);
&gt;                     return;
&gt;                 }
&gt;                 synchronized (this) {
&gt;                     if (args[index] != NOT_FOUND) {
&gt;                         if (args == activation.getOriginalArguments()) {
&gt;                             args = (Object[])args.clone();
&gt;                         }
&gt;                         args[index] = value;
&gt;                         return;
&gt;                     }
&gt;                 }
&gt;             }
114,118c142,150
&lt;             NativeFunction f = activation.funObj;
&lt;             if (index &lt; f.argCount)
&lt;                 activation.delete(f.argNames[index]);
&lt;             else
&lt;                 args[index] = Undefined.instance;
---
&gt;             synchronized (this) {
&gt;                 if (args[index] != NOT_FOUND) {
&gt;                     if (args == activation.getOriginalArguments()) {
&gt;                         args = (Object[])args.clone();
&gt;                     }
&gt;                     args[index] = NOT_FOUND;
&gt;                     return;
&gt;                 }
&gt;             }
119a152
&gt;         super.delete(index);
230a264,267
&gt; 
&gt; // Initially args holds activation.getOriginalArgs(), but any modification
&gt; // of its elements triggers creation of a copy. If its element holds NOT_FOUND,
&gt; // it indicates deleted index, in which case super class is queried.
</file>
</fixedFiles>
</bug>
<bug id="157509" transactionid="67950">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="52"/>
<property name="lines-added" value="37"/>
<property name="lines-deleted" value="80"/>
<property name="lines-modified" value="193"/>
<property name="lines-churned" value="310"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-break K-case K-continue K-do K-else K-false K-for K-if K-new K-null K-return K-this K-true K-while M O-&lt; O-&lt;&lt; O-&lt;= O-== O-&gt;= O-| O-|| O-- O-! O-!= O-() O-* O-+ O-++ O-cast T V Y Z-cast Z-do Z-for Z-if Z-switch Z-vardecl</fullfingerprint>
<bugreport>Rhino does not throw SyntaxError on invalid \ usage in identifiers like in:

var a\b;

In general, as long as \ in the middle of the identifier does not follow by u,
Rhino silently swallow that:

try {
	eval("var a\\1 = 0; print(a\\1); ");
} catch (e) {
	print(e);
}

which prints 0 while SM correctly prints:

SyntaxError: illegal character</bugreport>
<testsforfix id="157509" type="new">
<test file="mozilla/js/tests/ecma_3/Statements/regress-157509.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/TokenStream.java" revision="1.30" state="changed">753a754
&gt;         boolean identifierStart;
757c758,759
&lt;             if (c == 'u')
---
&gt;             if (c == 'u') {
&gt;                 identifierStart = true;
759c761,763
&lt;             else
---
&gt;                 stringBufferTop = 0;
&gt;             } else {
&gt;                 identifierStart = false;
761,763c765,772
&lt;             // always unread the 'u' or whatever, we need
&lt;             // to start the string below at the &lt;backslash&gt;.
&lt;             in.unread();
---
&gt;                 in.unread();
&gt;             }
&gt;         } else {
&gt;             identifierStart = Character.isJavaIdentifierStart((char)c);
&gt;             if (identifierStart) {
&gt;                 stringBufferTop = 0;
&gt;                 addToString(c);
&gt;             }
765,767d773
&lt;         if (isUnicodeEscapeStart ||
&lt;                     Character.isJavaIdentifierStart((char)c)) {
&lt;             in.startString();
768a775
&gt;         if (identifierStart) {
770,772c777,798
&lt;             do {
&lt;                 c = in.read();
&lt;                 if (c == '\\') {
---
&gt;             for (;;) {
&gt;                 if (isUnicodeEscapeStart) {
&gt;                     // strictly speaking we should probably push-back
&gt;                     // all the bad characters if the &lt;backslash&gt;uXXXX
&gt;                     // sequence is malformed. But since there isn't a
&gt;                     // correct context(is there?) for a bad Unicode
&gt;                     // escape sequence in an identifier, we can report
&gt;                     // an error here.
&gt;                     int escapeVal = 0;
&gt;                     for (int i = 0; i != 4; ++i) {
&gt;                         c = in.read();
&gt;                         escapeVal = (escapeVal &lt;&lt; 4) | xDigitToInt(c);
&gt;                         // Next check takes care about c &lt; 0 and bad escape
&gt;                         if (escapeVal &lt; 0) { break; }
&gt;                     }
&gt;                     if (escapeVal &lt; 0) {
&gt;                         reportSyntaxError("msg.invalid.escape", null);
&gt;                         return ERROR;
&gt;                     }
&gt;                     addToString(escapeVal);
&gt;                     isUnicodeEscapeStart = false;
&gt;                 } else {
774,818c800,806
&lt;                     containsEscape = (c == 'u');
&lt;                 }
&lt;             } while (Character.isJavaIdentifierPart((char)c));
&lt;             in.unread();
&lt; 
&lt;             int result;
&lt; 
&lt;             String str = in.getString();
&lt;             // OPT we shouldn't have to make a string (object!) to
&lt;             // check if it's a keyword.
&lt; 
&lt;             // strictly speaking we should probably push-back
&lt;             // all the bad characters if the &lt;backslash&gt;uXXXX
&lt;             // sequence is malformed. But since there isn't a
&lt;             // correct context(is there?) for a bad Unicode
&lt;             // escape sequence after an identifier, we can report
&lt;             // an error here.
&lt;             if (containsEscape) {
&lt;                 char ca[] = str.toCharArray();
&lt;                 int L = str.length();
&lt;                 int destination = 0;
&lt;                 for (int i = 0; i != L;) {
&lt;                     c = ca[i];
&lt;                     ++i;
&lt;                     if (c == '\\' &amp;&amp; i != L &amp;&amp; ca[i] == 'u') {
&lt;                         boolean goodEscape = false;
&lt;                         if (i + 4 &lt; L) {
&lt;                             int val = xDigitToInt(ca[i + 1]);
&lt;                             if (val &gt;= 0) {
&lt;                                 val = (val &lt;&lt; 4) | xDigitToInt(ca[i + 2]);
&lt;                                 if (val &gt;= 0) {
&lt;                                     val = (val &lt;&lt; 4) | xDigitToInt(ca[i + 3]);
&lt;                                     if (val &gt;= 0) {
&lt;                                         val = (val &lt;&lt; 4) | xDigitToInt(ca[i + 4]);
&lt;                                         if (val &gt;= 0) {
&lt;                                             c = (char)val;
&lt;                                             i += 5;
&lt;                                             goodEscape = true;
&lt;                                         }
&lt;                                     }
&lt;                                 }
&lt;                             }
&lt;                         }
&lt;                         if (!goodEscape) {
&lt;                             reportSyntaxError("msg.invalid.escape", null);
---
&gt;                     if (c == '\\') {
&gt;                         c = in.read();
&gt;                         if (c == 'u') {
&gt;                             isUnicodeEscapeStart = true;
&gt;                             containsEscape = true;
&gt;                         } else {
&gt;                             reportSyntaxError("msg.illegal.character", null);
820a809,813
&gt;                     } else {
&gt;                         if (!Character.isJavaIdentifierPart((char)c)) {
&gt;                             break;
&gt;                         }
&gt;                         addToString(c);
822,823d814
&lt;                     ca[destination] = (char)c;
&lt;                     ++destination;
825d815
&lt;                 str = new String(ca, 0, destination);
827c817,823
&lt;             else {
---
&gt;             in.unread();
&gt; 
&gt;                String str = getStringFromBuffer();
&gt;             if (!containsEscape) {
&gt;                 // OPT we shouldn't have to make a string (object!) to
&gt;                 // check if it's a keyword.
&gt; 
829c825
&lt;                 result = stringToKeyword(str);
---
&gt;                 int result = stringToKeyword(str);
845d840
&lt;                         result = EOF;
849d843
&lt; 
855a850,851
&gt; 
&gt;             stringBufferTop = 0;
857d852
&lt;             in.startString();
862d856
&lt;                     c = in.read();
864,865c858
&lt;                     // restart the string, losing leading 0x
&lt;                     in.startString();
---
&gt;                     c = in.read();
867a861,862
&gt;                 } else {
&gt;                     addToString('0');
871,874c866,872
&lt;             while (0 &lt;= xDigitToInt(c)) {
&lt;                 if (base &lt; 16) {
&lt;                     if (isAlpha(c))
&lt;                         break;
---
&gt;             if (base == 16) {
&gt;                 while (0 &lt;= xDigitToInt(c)) {
&gt;                     addToString(c);
&gt;                     c = in.read();
&gt;                 }
&gt;             } else {
&gt;                 while ('0' &lt;= c &amp;&amp; c &lt;= '9') {
885a884,885
&gt;                     addToString(c);
&gt;                     c = in.read();
887d886
&lt;                 c = in.read();
895a895
&gt;                         addToString(c);
899d898
&lt; 
900a900
&gt;                     addToString(c);
902a903
&gt;                         addToString(c);
906d906
&lt;                         in.getString(); // throw away string in progress
910a911
&gt;                         addToString(c);
916c917
&lt;             String numString = in.getString();
---
&gt;             String numString = getStringFromBuffer();
944,945d944
&lt;             StringBuffer stringBuf = null;
&lt; 
947a947
&gt;             stringBufferTop = 0;
950,951c950
&lt;             in.startString(); // start after the first "
&lt;             while(c != quoteChar) {
---
&gt;         strLoop: while (c != quoteChar) {
954d952
&lt;                     in.getString(); // throw away the string in progress
960,967c958
&lt;                     // We've hit an escaped character; revert to the
&lt;                     // slow method of building a string.
&lt;                     if (stringBuf == null) {
&lt;                         // Don't include the backslash
&lt;                         in.unread();
&lt;                         stringBuf = new StringBuffer(in.getString());
&lt;                         in.read();
&lt;                     }
---
&gt;                     // We've hit an escaped character
969,977c960,970
&lt;                     switch (c = in.read()) {
&lt;                     case 'b': c = '\b'; break;
&lt;                     case 'f': c = '\f'; break;
&lt;                     case 'n': c = '\n'; break;
&lt;                     case 'r': c = '\r'; break;
&lt;                     case 't': c = '\t'; break;
&lt;                     case 'v': c = '\u000B'; break;
&lt;                         // \v a late addition to the ECMA spec.
&lt;                         // '\v' doesn't seem to be valid Java.
---
&gt;                     c = in.read();
&gt;                     switch (c) {
&gt;                         case 'b': c = '\b'; break;
&gt;                         case 'f': c = '\f'; break;
&gt;                         case 'n': c = '\n'; break;
&gt;                         case 'r': c = '\r'; break;
&gt;                         case 't': c = '\t'; break;
&gt; 
&gt;                         // \v a late addition to the ECMA spec,
&gt;                         // it is not in Java, so use 0xb
&gt;                         case 'v': c = 0xb; break;
979,980c972,1019
&lt;                     default:
&lt;                         if (isDigit(c) &amp;&amp; c &lt; '8') {
---
&gt;                         case 'u': {
&gt;                             /*
&gt;                              * Get 4 hex digits; if the u escape is not
&gt;                              * followed by 4 hex digits, use 'u' + the literal
&gt;                              * character sequence that follows.
&gt;                              */
&gt;                             int escapeStart = stringBufferTop;
&gt;                             addToString('u');
&gt;                             int escapeVal = 0;
&gt;                             for (int i = 0; i != 4; ++i) {
&gt;                                 c = in.read();
&gt;                                 escapeVal = (escapeVal &lt;&lt; 4) | xDigitToInt(c);
&gt;                                 if (escapeVal &lt; 0) {
&gt;                                     continue strLoop;
&gt;                                 }
&gt;                                 addToString(c);
&gt;                             }
&gt;                             // prepare for replace of stored 'u' sequence
&gt;                             // by escape value
&gt;                             stringBufferTop = escapeStart;
&gt;                             c = escapeVal;
&gt;                         } break;
&gt; 
&gt;                         case 'x': {
&gt;                             /* Get 2 hex digits, defaulting to 'x' + literal
&gt;                              * sequence, as above.
&gt;                              */
&gt;                             c = in.read();
&gt;                             int escapeVal = xDigitToInt(c);
&gt;                             if (escapeVal &lt; 0) {
&gt;                                 addToString('x');
&gt;                                 continue strLoop;
&gt;                             } else {
&gt;                                 int c1 = c;
&gt;                                 c = in.read();
&gt;                                 escapeVal = (escapeVal &lt;&lt; 4) | xDigitToInt(c);
&gt;                                 if (escapeVal &lt; 0) {
&gt;                                     addToString('x');
&gt;                                     addToString(c1);
&gt;                                     continue strLoop;
&gt;                                 } else {
&gt;                                     // got 2 hex digits
&gt;                                     c = escapeVal;
&gt;                                 }
&gt;                             }
&gt;                         } break;
&gt; 
&gt;                         default: if (isDigit(c) &amp;&amp; c &lt; '8') {
993c1032,1033
&lt;                                 reportSyntaxError("msg.oct.esc.too.large", null);
---
&gt;                                 reportSyntaxError("msg.oct.esc.too.large",
&gt;                                                   null);
997,1059d1036
&lt;                         } else if (c == 'u') {
&lt;                             /*
&lt;                              * Get 4 hex digits; if the u escape is not
&lt;                              * followed by 4 hex digits, use 'u' + the literal
&lt;                              * character sequence that follows.  Do some manual
&lt;                              * match (OK because we're in a string) to avoid
&lt;                              * multi-char match on the underlying stream.
&lt;                              */
&lt;                             int c1 = in.read();
&lt;                             c = xDigitToInt(c1);
&lt;                             if (c &lt; 0) {
&lt;                                 in.unread();
&lt;                                 c = 'u';
&lt;                             } else {
&lt;                                 int c2 = in.read();
&lt;                                 c = (c &lt;&lt; 4) | xDigitToInt(c2);
&lt;                                 if (c &lt; 0) {
&lt;                                     in.unread();
&lt;                                     stringBuf.append('u');
&lt;                                     c = c1;
&lt;                                 } else {
&lt;                                     int c3 = in.read();
&lt;                                     c = (c &lt;&lt; 4) | xDigitToInt(c3);
&lt;                                     if (c &lt; 0) {
&lt;                                         in.unread();
&lt;                                         stringBuf.append('u');
&lt;                                         stringBuf.append((char)c1);
&lt;                                         c = c2;
&lt;                                     } else {
&lt;                                         int c4 = in.read();
&lt;                                         c = (c &lt;&lt; 4) | xDigitToInt(c4);
&lt;                                         if (c &lt; 0) {
&lt;                                             in.unread();
&lt;                                             stringBuf.append('u');
&lt;                                             stringBuf.append((char)c1);
&lt;                                             stringBuf.append((char)c2);
&lt;                                             c = c3;
&lt;                                         } else {
&lt;                                             // got 4 hex digits! Woo Hoo!
&lt;                                         }
&lt;                                     }
&lt;                                 }
&lt;                             }
&lt;                         } else if (c == 'x') {
&lt;                             /* Get 2 hex digits, defaulting to 'x' + literal
&lt;                              * sequence, as above.
&lt;                              */
&lt;                             int c1 = in.read();
&lt;                             c = xDigitToInt(c1);
&lt;                             if (c &lt; 0) {
&lt;                                 in.unread();
&lt;                                 c = 'x';
&lt;                             } else {
&lt;                                 int c2 = in.read();
&lt;                                 c = (c &lt;&lt; 4) | xDigitToInt(c2);
&lt;                                 if (c &lt; 0) {
&lt;                                     in.unread();
&lt;                                     stringBuf.append('x');
&lt;                                     c = c1;
&lt;                                 } else {
&lt;                                     // got 2 hex digits
&lt;                                 }
&lt;                             }
1063,1065c1040
&lt; 
&lt;                 if (stringBuf != null)
&lt;                     stringBuf.append((char) c);
---
&gt;                 addToString(c);
1069,1075c1044
&lt;             if (stringBuf != null)
&lt;                 this.string = stringBuf.toString();
&lt;             else {
&lt;                 in.unread(); // miss the trailing "
&lt;                 this.string = in.getString();
&lt;                 in.read();
&lt;             }
---
&gt;             this.string = getStringFromBuffer();
1237,1240c1206
&lt;                 // We don't try to use the in.startString/in.getString
&lt;                 // approach, because escaped characters (which break it)
&lt;                 // seem likely to be common.
&lt;                 StringBuffer re = new StringBuffer();
---
&gt;                 stringBufferTop = 0;
1248c1214
&lt;                         re.append((char) c);
---
&gt;                         addToString(c);
1252c1218
&lt;                     re.append((char) c);
---
&gt;                     addToString(c);
1253a1220
&gt;                 int reEnd = stringBufferTop;
1255d1221
&lt;                 StringBuffer flagsBuf = new StringBuffer();
1258c1224
&lt;                         flagsBuf.append('g');
---
&gt;                         addToString('g');
1260c1226
&lt;                         flagsBuf.append('i');
---
&gt;                         addToString('i');
1262c1228
&lt;                         flagsBuf.append('m');
---
&gt;                         addToString('m');
1272,1273c1238,1240
&lt;                 this.string = re.toString();
&lt;                 this.regExpFlags = flagsBuf.toString();
---
&gt;                 this.string = new String(stringBuffer, 0, reEnd);
&gt;                 this.regExpFlags = new String(stringBuffer, reEnd,
&gt;                                               stringBufferTop - reEnd);
1324a1292,1304
&gt;     private String getStringFromBuffer() {
&gt;         return new String(stringBuffer, 0, stringBufferTop);
&gt;     }
&gt; 
&gt;     private void addToString(int c) {
&gt;         if (stringBufferTop == stringBuffer.length) {
&gt;             char[] tmp = new char[stringBuffer.length * 2];
&gt;             System.arraycopy(stringBuffer, 0, tmp, 0, stringBufferTop);
&gt;             stringBuffer = tmp;
&gt;         }
&gt;         stringBuffer[stringBufferTop++] = (char)c;
&gt;     }
&gt; 
1379a1360,1364
&gt; 
&gt;     private char[] stringBuffer = new char[128];
&gt;     private int stringBufferTop;
&gt; 
&gt;     private static final boolean checkSelf = Context.check &amp;&amp; true;
</file>
</fixedFiles>
</bug>
<bug id="159334" transactionid="67468">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="35"/>
<property name="lines-added" value="18"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="40"/>
<property name="lines-churned" value="58"/>
<property name="priority" value="--"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-null K-return K-throw M O-&lt; O-&lt;&lt; O-== O-&gt; O-&gt;&gt;&gt; O-| O-- O-!= O-() O-&amp; O-+ O-cast T V Y Z-cast Z-if Z-throw</fullfingerprint>
<bugreport>As far as I understand Rhino's source code, I think it's a bug. It is present 
on both versions 1.5R2 &amp; 1.5R3. It occurs each time the number of token exceeds 
32767. 

V1.5R2 : org.mozilla.javascript.Interpreter:getString()
V1.5R3 : org.mozilla.javascript.Interpreter.getShort()

The way the index to enter the token's table (theStringTable) is computed can 
result in negative numbers. 

Here's the code in 1.5R2 ;

    private static String getString(String[] theStringTable, byte[] iCode,
                                    int pc){
        int index = (iCode[pc] &lt;&lt; 8) + (iCode[pc + 1] &amp; 0xFF);
        return theStringTable[index];
    }

As iCode is a table of bytes, iCode[pc] can result in a negative number. Here's 
an ugly-coded patch ;

    private static String getString(String[] theStringTable, byte[] iCode,
                                    int pc){
	int a1 = iCode[pc];
	if ( a1&lt;0 ) a1 += 256;
	a1 = a1 &lt;&lt; 8;
	int a2 = iCode[pc + 1];
	if ( a2&lt;0 ) a2 += 256;
	a2 = a2  &amp; 0xFF;
	int index = a1 + a2;
        return theStringTable[index];
    }

As I use some kind of code-generation, I have functions that exceed 2500 lines. 
By using this patch, everything works fine. Sorry for my bad english, I hope 
this will help :)</bugreport>
<testsforfix id="159334" type="new">
<test file="mozilla/js/tests/js1_5/Regress/regress-159334.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/Interpreter.java" revision="1.108" state="changed">282c282
&lt;                     iCodeTop = addShort(index, iCodeTop);
---
&gt;                     iCodeTop = addIndex(index, iCodeTop);
414c414
&lt;                     int nameIndex = -1;
---
&gt;                     String functionName = null;
417c417
&lt;                         if (nameIndex == -1) {
---
&gt;                         if (functionName == null) {
422c422
&lt;                                 nameIndex = lastStringIndex;
---
&gt;                                 functionName = lastAddString;
435c435
&lt;                         iCodeTop = addShort(nameIndex, iCodeTop);
---
&gt;                         iCodeTop = addString(functionName, iCodeTop);
444c444
&lt;                     iCodeTop = addShort(childCount, iCodeTop);
---
&gt;                     iCodeTop = addIndex(childCount, iCodeTop);
1013c1013
&lt;                     iCodeTop = addShort(index, iCodeTop);
---
&gt;                     iCodeTop = addIndex(index, iCodeTop);
1086,1087c1086
&lt;             throw Context.reportRuntimeError
&lt;                 ("Program too complex: too big jump offset");
---
&gt;             throw Context.reportRuntimeError0("msg.too.big.jump");
1111a1111,1124
&gt;     private int addIndex(int index, int iCodeTop) {
&gt;         if (index &lt; 0) Context.codeBug();
&gt;         if (index &gt; 0xFFFF) {
&gt;             throw Context.reportRuntimeError0("msg.too.big.index");
&gt;         }
&gt;         byte[] array = itsData.itsICode;
&gt;         if (iCodeTop + 2 &gt; array.length) {
&gt;             array = increaseICodeCapasity(iCodeTop, 2);
&gt;         }
&gt;         array[iCodeTop] = (byte)(index &gt;&gt;&gt; 8);
&gt;         array[iCodeTop + 1] = (byte)index;
&gt;         return iCodeTop + 2;
&gt;     }
&gt; 
1137c1150
&lt;         iCodeTop = addShort(index, iCodeTop);
---
&gt;         iCodeTop = addIndex(index, iCodeTop);
1147,1148c1160,1161
&lt;         iCodeTop = addShort(index, iCodeTop);
&lt;         lastStringIndex = index;
---
&gt;         iCodeTop = addIndex(index, iCodeTop);
&gt;         lastAddString = str;
1168a1182,1185
&gt;     private static int getIndex(byte[] iCode, int pc) {
&gt;         return ((iCode[pc] &amp; 0xFF) &lt;&lt; 8) | (iCode[pc + 1] &amp; 0xFF);
&gt;     }
&gt; 
1272,1273c1289,1290
&lt;                                 String name = strings[getShort(iCode, pc + 2)];
&lt;                                 int count = getShort(iCode, pc + 4);
---
&gt;                                 String name = strings[getIndex(iCode, pc + 2)];
&gt;                                 int count = getIndex(iCode, pc + 4);
1280c1297
&lt;                                 int i = getShort(iCode, pc);
---
&gt;                                 int i = getIndex(iCode, pc);
1287c1304
&lt;                                 int i = getShort(iCode, pc + 1);
---
&gt;                                 int i = getIndex(iCode, pc + 1);
1295,1296c1312,1313
&lt;                                 int count = getShort(iCode, pc + 2);
&lt;                                 String name = strings[getShort(iCode, pc)];
---
&gt;                                 int count = getIndex(iCode, pc + 2);
&gt;                                 String name = strings[getIndex(iCode, pc)];
1315c1332
&lt;                                 int index = getShort(iCode, pc);
---
&gt;                                 int index = getIndex(iCode, pc);
1330c1347
&lt;                                         + strings[getShort(iCode, pc)] + "\"");
---
&gt;                                         + strings[getIndex(iCode, pc)] + "\"");
1989c2006
&lt;         String name = strings[getShort(iCode, pc + 1)];
---
&gt;         String name = strings[getIndex(iCode, pc + 1)];
1995c2012
&lt;         String name = strings[getShort(iCode, pc + 1)];
---
&gt;         String name = strings[getIndex(iCode, pc + 1)];
2001c2018
&lt;         String name = strings[getShort(iCode, pc + 1)];
---
&gt;         String name = strings[getIndex(iCode, pc + 1)];
2106,2107c2123,2124
&lt;         String name = strings[getShort(iCode, pc + 3)];
&lt;         int count = getShort(iCode, pc + 5);
---
&gt;         String name = strings[getIndex(iCode, pc + 3)];
&gt;         int count = getIndex(iCode, pc + 5);
2129c2146
&lt;         int count = getShort(iCode, pc + 3);
---
&gt;         int count = getIndex(iCode, pc + 3);
2165,2166c2182,2183
&lt;                 int i = getShort(iCode, pc + 1);
&lt;                 if (i != -1) lhs = strings[i];
---
&gt;                 lhs = strings[getIndex(iCode, pc + 1)];
&gt;                 if (lhs == null) lhs = undefined;
2182c2199
&lt;         int count = getShort(iCode, pc + 3);
---
&gt;         int count = getIndex(iCode, pc + 3);
2209,2210c2226,2227
&lt;                 int i = getShort(iCode, pc + 1);
&lt;                 if (i != -1) lhs = strings[i];
---
&gt;                 lhs = strings[getIndex(iCode, pc + 1)];
&gt;                 if (lhs == null) lhs = undefined;
2226c2243
&lt;         String name = strings[getShort(iCode, pc + 1)];
---
&gt;         String name = strings[getIndex(iCode, pc + 1)];
2232c2249
&lt;         stack[++stackTop] = strings[getShort(iCode, pc + 1)];
---
&gt;         stack[++stackTop] = strings[getIndex(iCode, pc + 1)];
2250c2267
&lt;         sDbl[stackTop] = idata.itsDoubleTable[getShort(iCode, pc + 1)];
---
&gt;         sDbl[stackTop] = idata.itsDoubleTable[getIndex(iCode, pc + 1)];
2254c2271
&lt;         String name = strings[getShort(iCode, pc + 1)];
---
&gt;         String name = strings[getIndex(iCode, pc + 1)];
2260c2277
&lt;         String name = strings[getShort(iCode, pc + 1)];
---
&gt;         String name = strings[getIndex(iCode, pc + 1)];
2266c2283
&lt;         String name = strings[getShort(iCode, pc + 1)];
---
&gt;         String name = strings[getIndex(iCode, pc + 1)];
2437c2454
&lt;         int i = getShort(iCode, pc + 1);
---
&gt;         int i = getIndex(iCode, pc + 1);
2446c2463
&lt;         int i = getShort(iCode, pc + 1);
---
&gt;         int i = getIndex(iCode, pc + 1);
2902c2919
&lt;     private int lastStringIndex = -1;
---
&gt;     private String lastAddString;
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/resources/Messages.properties" revision="1.33" state="changed"/>
</fixedFiles>
</bug>
<bug id="177314" transactionid="67533">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="5"/>
<property name="lines-modified" value="5"/>
<property name="lines-churned" value="10"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-null K-return M O-&lt;= O-&gt; O-&amp;&amp; T V Y Z-if</fullfingerprint>
<bugreport>Although octal escapes in string literals are not part of Ecma 262 since the
version 3, to support old scripts Rhino should handle them correctly. In
particular, currently Rhino throws an error when evaluating
'\400' == ' 0'

js&gt; '\400' == ' 0'
js: "&lt;stdin&gt;", line 1: uncaught JavaScript exception: SyntaxError: octal escape
too large (&lt;stdin&gt;; line 1)
js: '\400' == ' 0'
js: ....^

while SM gives true, which is what required by Ecma 262 version 1 and 2.</bugreport>
<testsforfix id="177314" type="new">
<test file="mozilla/js/tests/js1_5/LexicalConventions/regress-177314.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/TokenStream.java" revision="1.32" state="changed">1019c1019
&lt;                         default: if (isDigit(c) &amp;&amp; c &lt; '8') {
---
&gt;                         default: if ('0' &lt;= c &amp;&amp; c &lt; '8') {
1022c1022
&lt;                             if (isDigit(c) &amp;&amp; c &lt; '8') {
---
&gt;                             if ('0' &lt;= c &amp;&amp; c &lt; '8') {
1025c1025,1027
&lt;                                 if (isDigit(c) &amp;&amp; c &lt; '8') {
---
&gt;                                 if ('0' &lt;= c &amp;&amp; c &lt; '8' &amp;&amp; val &lt;= 037) {
&gt;                                     // c is 3rd char of octal sequence only if
&gt;                                     // the resulting val &lt;= 0377
1031,1035d1032
&lt;                             if (val &gt; 0377) {
&lt;                                 reportSyntaxError("msg.oct.esc.too.large",
&lt;                                                   null);
&lt;                                 return ERROR;
&lt;                             }
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/resources/Messages.properties" revision="1.32" state="changed"/>
</fixedFiles>
</bug>
<bug id="179068" transactionid="67258">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="29"/>
<property name="lines-added" value="56"/>
<property name="lines-deleted" value="3"/>
<property name="lines-modified" value="115"/>
<property name="lines-churned" value="174"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-break K-case K-continue K-default K-else K-for K-if K-new K-null K-return K-throw K-while M O-&lt; O-&lt;&lt; O-== O-&gt; O-&gt;= O-&gt;&gt;&gt; O-| O-|| O-- O-!= O-() O-&amp; O-&amp;&amp; O-+ O-++ O-cast T V Y Z-cast Z-if Z-switch Z-throw Z-while</fullfingerprint>
<bugreport>Currently Rhino does not support long string literals with more then 64K of
characters, which can be a problem to run it against automatically generated
scripts.</bugreport>
<testsforfix id="179068" type="new">
<test file="mozilla/js/tests/js1_5/String/regress-179068.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/Parser.java" revision="1.27" state="changed">106a107,109
&gt;         // Add script indicator
&gt;         sourceAdd((char)ts.SCRIPT);
&gt; 
1465,1467c1468,1470
&lt;         int L = str.length();
&lt;         // java string length &lt; 2^16?
&lt;         if (Context.check &amp;&amp; L &gt; Character.MAX_VALUE) Context.codeBug();
---
&gt;         sourceAdd((char)type);
&gt;         sourceAddString(str);
&gt;     }
1469,1470c1472,1486
&lt;         if (sourceTop + L + 2 &gt; sourceBuffer.length) {
&lt;             increaseSourceCapacity(sourceTop + L + 2);
---
&gt;     private void sourceAddString(String str) {
&gt;         int L = str.length();
&gt;         int lengthEncodingSize = 1;
&gt;         if (L &gt;= 0x8000) {
&gt;             lengthEncodingSize = 2;
&gt;         }
&gt;         int nextTop = sourceTop + lengthEncodingSize + L;
&gt;         if (nextTop &gt; sourceBuffer.length) {
&gt;             increaseSourceCapacity(nextTop);
&gt;         }
&gt;         if (L &gt;= 0x8000) {
&gt;             // Use 2 chars to encode strings exceeding 32K, were the highest
&gt;             // bit in the first char indicates presence of the next byte
&gt;             sourceBuffer[sourceTop] = (char)(0x8000 | (L &gt;&gt;&gt; 16));
&gt;             ++sourceTop;
1472,1473c1488,1489
&lt;         sourceAdd((char)type);
&lt;         sourceAdd((char)L);
---
&gt;         sourceBuffer[sourceTop] = (char)L;
&gt;         ++sourceTop;
1475c1491,1504
&lt;         sourceTop += L;
---
&gt;         sourceTop = nextTop;
&gt;     }
&gt; 
&gt;     static int getSourceString(String source, int offset, Object[] result) {
&gt;         int length = source.charAt(offset);
&gt;         ++offset;
&gt;         if ((0x8000 &amp; length) != 0) {
&gt;             length = ((0x7FFF &amp; length) &lt;&lt; 16) | source.charAt(offset);
&gt;             ++offset;
&gt;         }
&gt;         if (result != null) {
&gt;             result[0] = source.substring(offset, offset + length);
&gt;         }
&gt;         return offset + length;
1529a1559,1590
&gt;     static int getSourceNumber(String source, int offset, Object[] result) {
&gt;         char type = source.charAt(offset);
&gt;         ++offset;
&gt;         if (type == 'S') {
&gt;             if (result != null) {
&gt;                 int ival = source.charAt(offset);
&gt;                 result[0] = new Integer(ival);
&gt;             }
&gt;             ++offset;
&gt;         } else if (type == 'J' || type == 'D') {
&gt;             if (result != null) {
&gt;                 long lbits;
&gt;                 lbits = (long)source.charAt(offset) &lt;&lt; 48;
&gt;                 lbits |= (long)source.charAt(offset + 1) &lt;&lt; 32;
&gt;                 lbits |= (long)source.charAt(offset + 2) &lt;&lt; 16;
&gt;                 lbits |= (long)source.charAt(offset + 3);
&gt;                 double dval;
&gt;                 if (type == 'J') {
&gt;                     dval = lbits;
&gt;                 } else {
&gt;                     dval = Double.longBitsToDouble(lbits);
&gt;                 }
&gt;                 result[0] = new Double(dval);
&gt;             }
&gt;             offset += 4;
&gt;         } else {
&gt;             // Bad source
&gt;             throw new RuntimeException();
&gt;         }
&gt;         return offset;
&gt;     }
&gt; 
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/NativeFunction.java" revision="1.36" state="changed">80a81
&gt;         Object[] srcData = new Object[1];
82c83
&lt;         decompile_r(this, indent, true, justbody, result);
---
&gt;         decompile_r(this, indent, true, justbody, srcData, result);
89c90
&lt;                                     StringBuffer result)
---
&gt;                                     Object[] srcData, StringBuffer result)
91a93
&gt; 
132,142c134,137
&lt;         if (length &gt; 0) {
&lt;             /* special-case FUNCTION as the first token; if it is,
&lt;              * (and it's not followed by a NAME or LP) then we're
&lt;              * decompiling a function (and not the toplevel script.)
&lt; 
&lt;              * FUNCTION appearing elsewhere is an escape that means we'll
&lt;              * need to call toString of the given function (object).
&lt; 
&lt;              * If not at the top level, don't add an initial indent;
&lt;              * let the caller do it, so functions as expressions look
&lt;              * reasonable.  */
---
&gt;         if (length != 0) {
&gt;             // If the first token is TokenStream.SCRIPT, then we're
&gt;             // decompiling the toplevel script, otherwise it a function
&gt;             // and should start with TokenStream.FUNCTION
152,158c147,149
&lt;             if (source.charAt(0) == TokenStream.FUNCTION
&lt;                 // make sure it's not a script that begins with a
&lt;                 // reference to a function definition.
&lt;                 &amp;&amp; length &gt; 1
&lt;                 &amp;&amp; (source.charAt(1) == TokenStream.NAME
&lt;                     || source.charAt(1) == TokenStream.LP))
&lt;             {
---
&gt;             int token = source.charAt(i);
&gt;             ++i;
&gt;             if (token == TokenStream.FUNCTION) {
171c162
&lt;                     if (nextIs(source, length, i, TokenStream.LP)
---
&gt;                     if (source.charAt(i) == TokenStream.LP
174a166
&gt;                     {
176c168
&lt;                     ++i;
---
&gt;                     }
178,187c170,172
&lt;                     /* Skip past the entire function header to the next EOL.
&lt;                      * Depends on how NAMEs are encoded.
&lt;                      */
&lt;                     while (i &lt; length
&lt;                            &amp;&amp; (source.charAt(i) != TokenStream.EOL
&lt;                                // the length char of a NAME sequence
&lt;                                // can look like an EOL.
&lt;                                || (i &gt; 0
&lt;                                    &amp;&amp; source.charAt(i-1) == TokenStream.NAME)))
&lt;                     {
---
&gt;                     // Skip past the entire function header pass the next EOL.
&gt;                     skipLoop: for (;;) {
&gt;                         token = source.charAt(i);
188a174,188
&gt;                         switch (token) {
&gt;                             case TokenStream.EOL:
&gt;                                 break skipLoop;
&gt;                             case TokenStream.NAME:
&gt;                                 // Skip function or argument name
&gt;                                 i = Parser.getSourceString(source, i, null);
&gt;                                 break;
&gt;                             case TokenStream.LP:
&gt;                             case TokenStream.COMMA:
&gt;                             case TokenStream.RP:
&gt;                                 break;
&gt;                             default:
&gt;                                 // Bad function header
&gt;                                 throw new RuntimeException();
&gt;                         }
190,191d189
&lt;                     // Skip past the EOL, too.
&lt;                     ++i;
192a191,193
&gt;             } else if (token != TokenStream.SCRIPT) {
&gt;                 // Bad source header
&gt;                 throw new RuntimeException();
197d197
&lt;             int stop;
208,241c208,217
&lt;                 ++i;
&lt;                 stop = i + (int)source.charAt(i);
&lt;                 result.append(source.substring(i + 1, stop + 1));
&lt;                 i = stop;
&lt;                 break;
&lt; 
&lt;             case TokenStream.NUMBER:
&lt;                 ++i;
&lt;                 long lbits = 0;
&lt;                 switch(source.charAt(i)) {
&lt;                 case 'S':
&lt;                     ++i;
&lt;                     result.append((int)source.charAt(i));
&lt;                     break;
&lt; 
&lt;                 case 'J':
&lt;                     lbits |= (long)source.charAt(++i) &lt;&lt; 48;
&lt;                     lbits |= (long)source.charAt(++i) &lt;&lt; 32;
&lt;                     lbits |= (long)source.charAt(++i) &lt;&lt; 16;
&lt;                     lbits |= (long)source.charAt(++i);
&lt; 
&lt;                     result.append(lbits);
&lt;                     break;
&lt;                 case 'D':
&lt;                     lbits |= (long)source.charAt(++i) &lt;&lt; 48;
&lt;                     lbits |= (long)source.charAt(++i) &lt;&lt; 32;
&lt;                     lbits |= (long)source.charAt(++i) &lt;&lt; 16;
&lt;                     lbits |= (long)source.charAt(++i);
&lt; 
&lt;                     double dval = Double.longBitsToDouble(lbits);
&lt;                     result.append(ScriptRuntime.numberToString(dval, 10));
&lt;                     break;
&lt;                 }
&lt;                 break;
---
&gt;                 i = Parser.getSourceString(source, i + 1, srcData);
&gt;                 result.append((String)srcData[0]);
&gt;                 continue;
&gt; 
&gt;             case TokenStream.NUMBER: {
&gt;                 i = Parser.getSourceNumber(source, i + 1, srcData);
&gt;                 double number = ((Number)srcData[0]).doubleValue();
&gt;                 result.append(ScriptRuntime.numberToString(number, 10));
&gt;                 continue;
&gt;             }
244,245c220
&lt;                 ++i;
&lt;                 stop = i + (int)source.charAt(i);
---
&gt;                 i = Parser.getSourceString(source, i + 1, srcData);
247,248c222
&lt;                 result.append(ScriptRuntime.escapeString
&lt;                               (source.substring(i + 1, stop + 1)));
---
&gt;                 result.append(ScriptRuntime.escapeString((String)srcData[0]));
250,251c224
&lt;                 i = stop;
&lt;                 break;
---
&gt;                 continue;
310c283
&lt;                             false, false, result);
---
&gt;                             false, false, srcData, result);
370,371c343,345
&lt;                     if (nextIs(source, length, i, TokenStream.CASE)
&lt;                         || nextIs(source, length, i, TokenStream.DEFAULT))
---
&gt;                     int nextToken = source.charAt(i + 1);
&gt;                     if (nextToken == TokenStream.CASE
&gt;                         || nextToken == TokenStream.DEFAULT)
373c347
&lt;                     else if (nextIs(source, length, i, TokenStream.RC))
---
&gt;                     else if (nextToken == TokenStream.RC)
380,382c354,357
&lt;                     else if (nextIs(source, length, i, TokenStream.NAME)) {
&lt;                         int skip = source.charAt(i + 2);
&lt;                         if (source.charAt(i + skip + 3) == TokenStream.COLON)
---
&gt;                     else if (nextToken == TokenStream.NAME) {
&gt;                         int afterName = Parser.getSourceString(source, i + 2,
&gt;                                                                null);
&gt;                         if (source.charAt(afterName) == TokenStream.COLON)
</file>
</fixedFiles>
</bug>
<bug id="179366" transactionid="67920">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="14"/>
<property name="lines-added" value="21"/>
<property name="lines-deleted" value="2"/>
<property name="lines-modified" value="33"/>
<property name="lines-churned" value="56"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-noop K-return K-true K-while M O-~ O-&lt;&lt; O-== O-&amp; O-&amp;&amp; O-cast T V Y Z-cast Z-if Z-while</fullfingerprint>
<bugreport>User-Agent:       Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.0.1) Gecko/20021003
Build Identifier: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.0.1) Gecko/20021003

This is a Rhino version of bug 31255.

Rhino should follow SpiderMonkey and allow to treat --&gt; after a possible
whitespace after line start to mean comments until line end.


Reproducible: Always

Steps to Reproduce:</bugreport>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/TokenStream.java" revision="1.33" state="changed">59,64c59,66
&lt;     public final static int
&lt;         TSF_NEWLINES    = 0x0001,  // tokenize newlines
&lt;         TSF_FUNCTION    = 0x0002,  // scanning inside function body
&lt;         TSF_RETURN_EXPR = 0x0004,  // function has 'return expr;'
&lt;         TSF_RETURN_VOID = 0x0008,  // function has 'return;'
&lt;         TSF_REGEXP      = 0x0010;  // looking for a regular expression
---
&gt;     final static int
&gt;         TSF_NEWLINES    = 1 &lt;&lt; 0,  // tokenize newlines
&gt;         TSF_FUNCTION    = 1 &lt;&lt; 1,  // scanning inside function body
&gt;         TSF_RETURN_EXPR = 1 &lt;&lt; 2,  // function has 'return expr;'
&gt;         TSF_RETURN_VOID = 1 &lt;&lt; 3,  // function has 'return;'
&gt;         TSF_REGEXP      = 1 &lt;&lt; 4,  // looking for a regular expression
&gt;         TSF_DIRTYLINE   = 1 &lt;&lt; 5;  // stuff other than whitespace since
&gt;                                    // start of line
729a732,738
&gt;     private void skipLine() throws IOException {
&gt;         // skip to end of line
&gt;         int c;
&gt;         while ((c = in.read()) != EOF_CHAR &amp;&amp; c != '\n') { }
&gt;         in.unread();
&gt;     }
&gt; 
744c753,754
&lt;             if (c == '\n')
---
&gt;             if (c == '\n') {
&gt;                 flags &amp;= ~TSF_DIRTYLINE;
746a757
&gt;             }
750a762,763
&gt;         if (c != '-' &amp;&amp; c != '\n')
&gt;             flags |= TSF_DIRTYLINE;
1117,1119c1130
&lt;                         while ((c = in.read()) != EOF_CHAR &amp;&amp; c != '\n')
&lt;                             /* skip to end of line */;
&lt;                         in.unread();
---
&gt;                         skipLine();
1184,1186c1195
&lt;                 while ((c = in.read()) != EOF_CHAR &amp;&amp; c != '\n')
&lt;                     /* skip to end of line */;
&lt;                 in.unread();
---
&gt;                 skipLine();
1261a1271,1279
&gt;             if (in.match('=')) {
&gt;                 this.op = ADD;
&gt;                 return ASSIGN;
&gt;             } else if (in.match('+')) {
&gt;                 return INC;
&gt;             } else {
&gt;                 return ADD;
&gt;             }
&gt; 
1264,1275c1282,1291
&lt;                 if (c == '+') {
&lt;                     this.op = ADD;
&lt;                     return ASSIGN;
&lt;                 } else {
&lt;                     this.op = SUB;
&lt;                     return ASSIGN;
&lt;                 }
&lt;             } else if (in.match((char) c)) {
&lt;                 if (c == '+') {
&lt;                     return INC;
&lt;                 } else {
&lt;                     return DEC;
---
&gt;                 this.op = SUB;
&gt;                 c = ASSIGN;
&gt;             } else if (in.match('-')) {
&gt;                 if (0 == (flags &amp; TSF_DIRTYLINE)) {
&gt;                     // treat HTML end-comment after possible whitespace
&gt;                     // after line start as comment-utill-eol
&gt;                     if (in.match('&gt;')) {
&gt;                         skipLine();
&gt;                         return getToken();
&gt;                     }
1277,1278c1293
&lt;             } else if (c == '-') {
&lt;                 return SUB;
---
&gt;                 c = DEC;
1280c1295
&lt;                 return ADD;
---
&gt;                 c = SUB;
1281a1297,1298
&gt;             flags |= TSF_DIRTYLINE;
&gt;             return c;
1340,1341c1357,1358
&lt;     public int flags;
&lt;     public String regExpFlags;
---
&gt;     int flags;
&gt;     String regExpFlags;
1360,1361d1376
&lt; 
&lt;     private static final boolean checkSelf = Context.check &amp;&amp; true;
</file>
</fixedFiles>
</bug>
<bug id="181654" transactionid="68241">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="6"/>
<property name="lines-added" value="7"/>
<property name="lines-deleted" value="7"/>
<property name="lines-modified" value="9"/>
<property name="lines-churned" value="23"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-instanceof K-true K-while M O-== O-! O-() O-cast O-instanceof T V Y Z-cast Z-if Z-while</fullfingerprint>
<bugreport>User-Agent:       Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; Q312461)
Build Identifier: Rhino 1.5 release 4 0000 00 00 (in progress)

Calling the toString method for an object that is derived from the Error class 
results in a thrown TypeError (Rhino only, works perfectly in SpiderMonkey).

Reproducible: Always

Steps to Reproduce:
regression test case attached
Actual Results:  
TypeError raised

Expected Results:  
same behaviour as with SpiderMonkey: method returns String with class name and 
error message.

Environment is reproducable with Rhino 1.5 RC4pre from current CVS</bugreport>
<testsforfix id="181654" type="new">
<test file="mozilla/js/tests/ecma_3/Exceptions/regress-181654.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/NativeError.java" revision="1.23" state="changed">103c103
&lt;                 return realThis(thisObj, f).toString();
---
&gt;                 return js_toString(thisObj);
109,115d108
&lt;     private NativeError realThis(Scriptable thisObj, IdFunction f) {
&lt;         while (!(thisObj instanceof NativeError)) {
&lt;             thisObj = nextInstanceCheck(thisObj, f, true);
&lt;         }
&lt;         return (NativeError)thisObj;
&lt;     }
&lt; 
125a119,125
&gt;     private static String js_toString(Scriptable thisObj) {
&gt;         Object name = ScriptRuntime.getStrIdElem(thisObj, "name");
&gt;         Object message = ScriptRuntime.getStrIdElem(thisObj, "message");
&gt;         return ScriptRuntime.toString(name)
&gt;             +": "+ScriptRuntime.toString(message);
&gt;     }
&gt; 
131,136c131
&lt;         // The "name" property is usually just defined in the prototype,
&lt;         // so use getProperty to fetch it.
&lt;         Object name = ScriptableObject.getProperty(this, "name");
&lt;         if (name == NOT_FOUND)
&lt;             name = Undefined.instance;
&lt;         return name + ": " + getMessage();
---
&gt;         return js_toString(this);
139c134
&lt;     public String getName() {
---
&gt;     String getName() {
145c140
&lt;     public String getMessage() {
---
&gt;     String getMessage() {
</file>
</fixedFiles>
</bug>
<bug id="181834" transactionid="68123">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="14"/>
<property name="lines-churned" value="14"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-false K-if K-instanceof O-|| O-! O-() O-instanceof T V Z-if</fullfingerprint>
<bugreport>User-Agent:       Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.2b) Gecko/20021016
Build Identifier: Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.2b) Gecko/20021016

i fear, i found a scoping problem with rhino related to the 'compile functions
with dynamic scope' feature. given the code :

	function outer( /* String */ arg ) {
        var outer_d = 0;
	  function inner( /* int */ level ) {
          outer_d++;
          if (level &gt; 0) {
            inner( level - 1 );
          } else {
            return outer_d;
          }
        }
        return inner(5);
      }
      var result = outer("arg");

should set the result variable to 6, but this is what happens (where o is the
optimization level and d is the dynamic function scope flag) :

	o &gt;= 0 &amp;&amp; d     : result == 6
	o &gt;= 0 &amp;&amp; !d    : result == 6
	o == -1 &amp;&amp; d    : ReferenceError: "outer_d" is not defined.
	o == -1 &amp;&amp; !d   : result == 6

so it seems, as long as the code is compiled to a class file, execution works
all right. but if the code is interpreted, something goes wrong with the scopes.

by inspecting the code (Interpreter.java), i found out, that inner functions are
compiled with the context's compileFunctionsWithDynamicScope flag. in the
dynamic case, this of course is the scope within which the outer function is
running instead of the variable object of the outer function, in which the inner
function is defined and obviously should be running.

i assume, inner functions should always be compiled with static scope regardless
of whether the context is set for dynamic scope compilations of functions or not.

if i am correct, then the Interpreter.generateNestedFunctions method should
probably be added the line

	            jsi.itsData.itsUseDynamicScope = false;

after creating the InterpreterData instance.

i tried it with the above sample code and it seems to fix the problem. though i
am not sure, whether it runs fine with more thorough regression tests.

what do you think of it ?

regards, felix

Reproducible: Always

Steps to Reproduce:
1. make Context interpreting (optimizationLevel = -1)
2. make Context "compile" functions with dynamic scope
3. run the above script and see the error noted using the shell tool.

Actual Results:  
error message : ReferenceError: "outer_d" is not defined.

Expected Results:  
the variable should be set to 6.</bugreport>
<testsforfix id="181834" type="new">
<test file="mozilla/js/tests/js1_5/Scope/regress-181834.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/Interpreter.java" revision="1.122" state="changed">1520c1520,1529
&lt;             fn.itsUseDynamicScope = true;
---
&gt;              // Nested functions are not affected by the dynamic scope flag
&gt;              // as dynamic scope is already a parent of their scope
&gt;              // Functions defined under the with statement also immune to
&gt;              // this setup, in which case dynamic scope is ignored in favor
&gt;              // of with object.
&gt;              if (!(scope instanceof NativeCall
&gt;                    || scope instanceof NativeWith))
&gt;              {
&gt;                  fn.itsUseDynamicScope = true;
&gt;              }
2441,2444c2450,2451
&lt;         InterpretedFunction closure = createFunction(cx, scope, closureData,
&lt;                                                      idata.itsFromEvalCode);
&lt;         closure.itsUseDynamicScope = false;
&lt;         stack[++stackTop] = closure;
---
&gt;         stack[++stackTop] = createFunction(cx, scope, closureData,
&gt;                                            idata.itsFromEvalCode);
</file>
</fixedFiles>
</bug>
<bug id="184107" transactionid="66985">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="6"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-instanceof K-while M O-instanceof T V Z-while</fullfingerprint>
<bugreport>User-Agent:       Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.0.1) Gecko/20021003
Build Identifier: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.0.1) Gecko/20021003

When evaluationg the following test:

var x = {y:10};
with (x) {
	function f()  {
		return y;
	}
}

var result = f();

var ok1 = (x.f === undefined)
print(ok1)

var ok2 = (result === x.y);
print(ok2)


Rhino incorrectly put f into the x object instead of the global scope. 

The test would work as expected if function f()... would be replaced by f =
function()...



Reproducible: Always

Steps to Reproduce:</bugreport>
<testsforfix id="184107" type="new">
<test file="mozilla/js/tests/js1_5/Scope/regress-184107.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/ScriptRuntime.java" revision="1.109" state="changed">1953a1954,1959
&gt;                 // Always put function expression statements into initial
&gt;                 // activation object ignoring the with statement to follow
&gt;                 // SpiderMonkey
&gt;                 while (scope instanceof NativeWith) {
&gt;                     scope = scope.getParentScope();
&gt;                 }
</file>
</fixedFiles>
</bug>
<bug id="185165" transactionid="67922">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>Z</concisefingerprint>
<fullfingerprint>O-!= O-&amp;&amp; T V Z-if</fullfingerprint>
<bugreport>User-Agent:       Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.0.1) Gecko/20021003
Build Identifier: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.0.1) Gecko/20021003

Rhino does not decompile "\\"  string literal properly. Given
function f() { return "\\"; } Rhino currently produces for print(f.toString())

function f() {
    return "\";
}

which contains broken "\"


Reproducible: Always

Steps to Reproduce:
Run in the shell the following script:

// Check that second decompilation of script gives the same string as first one.

var f1 = function() {
	return "\\";
}

var s1 = f1.toString();

var f2;
eval("f2="+s1);

var s2 = f2.toString();

var ok = (s1 === s2);

print(ok);

Actual Results:  
The shell signals syntax error:
js: "x.js#8(eval)", line 3: uncaught JavaScript exception: SyntaxError:
unterminated string literal (x.js#8(eval); line 3)
js:     return "\";
js: ..............^


Expected Results:  
The shell should print:
true</bugreport>
<testsforfix id="185165" type="new">
<test file="mozilla/js/tests/js1_5/Regress/regress-185165.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/ScriptRuntime.java" revision="1.104" state="changed">371c371
&lt;             if (' ' &lt;= c &amp;&amp; c &lt;= '~' &amp;&amp; c != '"') {
---
&gt;             if (' ' &lt;= c &amp;&amp; c &lt;= '~' &amp;&amp; c != '"' &amp;&amp; c != '\\') {
372a373
&gt;                 // or \ . Note single quote ' is not escaped
394c395
&lt;                 case '\'':  escape = '\''; break;
---
&gt;                 case '\\':  escape = '\\'; break;
</file>
</fixedFiles>
</bug>
<bug id="190685" transactionid="72471">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="8"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>K</concisefingerprint>
<fullfingerprint>K-case</fullfingerprint>
<bugreport>User-Agent:       Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.0.1) Gecko/20021003
Build Identifier: Rhino  2003-01-25 CVS

Already applied fix for the bug 189898 broke js1_2/Objects/toString-001.js test
case which now fails with:

*-* Testcase js1_2/Objects/toString-001.js failed:
Expected exit code 0, got 3
Testcase terminated with signal 0
Complete testcase output was:
js: uncaught JavaScript exception: SyntaxError: Invalid quantifier {


The test case fails when it declares the following regular expression:

/^{(.*)\}$/



Reproducible: Always

Steps to Reproduce:
1. Run Rhino shell
2. Enter there the foolowing regular expression:
/{\}/
Actual Results:  
js: uncaught JavaScript exception: SyntaxError: Invalid quantifier {


Expected Results:  
/{\}/</bugreport>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/regexp/NativeRegExp.java" revision="1.58" state="changed">1020d1019
&lt;         case '{':
</file>
</fixedFiles>
</bug>
<bug id="191276" transactionid="67192">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if M O-! Z-if</fullfingerprint>
<bugreport>User-Agent:       Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.0.1) Gecko/20021003
Build Identifier: Rhino CVS 2003-01-30

The following scripts when run in Rhino shell prints unexpected false, while the
interpreter mode prints correct true. Note that presence of never called
unused_function with test("a") line is essential, scripts work OK without it.
The bug presents at least since 1.5R3.

function test(name) { return this[name]; }

function unused_function() { test("a"); }

var result = test.call({ a: "aaa" }, "a");

var ok = (result === "aaa")

print(ok)


Reproducible: Always

Steps to Reproduce:
Run the test script against Rhino shell
Actual Results:  
false

Expected Results:  
true</bugreport>
<testsforfix id="191276" type="new">
<test file="mozilla/js/tests/js1_5/Scope/regress-191276.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/optimizer/Optimizer.java" revision="1.16" state="changed">679,683c679,684
&lt;                         // setting the ISNUMBER_PROP signals the codegen
&lt;                         // to use the scriptRuntime.getElem that takes
&lt;                         // a double index
&lt;                         n.putIntProp(Node.ISNUMBER_PROP, Node.RIGHT);
&lt;                         markDCPNumberContext(arrayIndex);
---
&gt;                         if (!convertParameter(arrayIndex)) {
&gt;                             // setting the ISNUMBER_PROP signals the codegen
&gt;                             // to use the scriptRuntime.getElem that takes
&gt;                             // a double index
&gt;                             n.putIntProp(Node.ISNUMBER_PROP, Node.RIGHT);
&gt;                         }
</file>
</fixedFiles>
</bug>
<bug id="191668" transactionid="67188">
<property name="files-churned" value="6"/>
<property name="java-files-churned" value="4"/>
<property name="classes-churned" value="4"/>
<property name="methods-churned" value="4"/>
<property name="hunks" value="99"/>
<property name="lines-added" value="166"/>
<property name="lines-deleted" value="506"/>
<property name="lines-modified" value="269"/>
<property name="lines-churned" value="941"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-break K-case K-catch K-class K-continue K-do K-else K-false K-for K-if K-import K-instanceof K-new K-null K-package K-return K-switch K-this K-throw K-true K-try K-while M O-^ O-&lt; O-&lt;= O-== O-&gt; O-&gt;= O-|| O-- O--- O-! O-!= O-?: O-() O-* O-&amp; O-&amp;&amp; O-+ O-++ O-cast O-instanceof T V Y Z-cast Z-cond Z-do Z-for Z-if Z-switch Z-throw Z-vardecl Z-while</fullfingerprint>
<bugreport>User-Agent:       Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.0.1) Gecko/20021003
Build Identifier: Rhino CVS from 2003-02-02

Rhino tokenizer violates single character lookahead restriction of
omj.LineBuffer when implementing recognition of HTML comments &lt;!-- . In
particular, LineBuffer assumes that calls to LineBuffer.match will not unread
after successful match, but code to recognize &lt;!-- does exactly that as &lt;! and
&lt;!- are valid sequence of JavaScript operators. 

The following attached test case calls eval on "if (0&lt;!-0) ++j;" prefixed by
increasing sequence of spaces to make sure that at some point &lt;!- occurs on
internal buffer boundary when LineBuffer.unread can not work.



Reproducible: Always

Steps to Reproduce:
Run the test by Rhino shell
Actual Results:  
Exception in thread "main" java.lang.RuntimeException: FAILED ASSERTION
        at org.mozilla.javascript.Context.codeBug(Context.java:2150)
        at org.mozilla.javascript.LineBuffer.unread(LineBuffer.java:116)
        at org.mozilla.javascript.TokenStream.getToken(TokenStream.java:1131)


Expected Results:  
The test should print OK</bugreport>
<testsforfix id="191668" type="new">
<test file="mozilla/js/tests/js1_5/Regress/regress-191668.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/LineBuffer.java" revision="1.17" state="deleted"/>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/Context.java" revision="1.110" state="changed">782,789c782,787
&lt;         try {
&lt;             Reader in = new StringReader(source);
&lt;             return evaluateReader(scope, in, sourceName, lineno,
&lt;                                   securityDomain);
&lt;         }
&lt;         catch (IOException ioe) {
&lt;             // Should never occur because we just made the reader from a String
&lt;             throw new RuntimeException();
---
&gt;         Script script = compileString(scope, source, sourceName, lineno,
&gt;                                       securityDomain);
&gt;         if (script != null) {
&gt;             return script.exec(this, scope);
&gt;         } else {
&gt;             return null;
819c817
&lt;         if (script != null)
---
&gt;         if (script != null) {
821c819
&lt;         else
---
&gt;         } else {
822a821
&gt;         }
843d841
&lt;         Reader in = new StringReader(source);
846c844
&lt;         TokenStream ts = new TokenStream(in, null, null, 1);
---
&gt;         TokenStream ts = new TokenStream(null, source, null, null, 1);
899,900c897,898
&lt;         return (Script) compile(scope, in, sourceName, lineno, securityDomain,
&lt;                                 false);
---
&gt;         return (Script) compile(scope, in, null, sourceName, lineno,
&gt;                                 securityDomain, false);
902a901,931
&gt;     /**
&gt;      * Compiles the source in the given string.
&gt;      * &lt;p&gt;
&gt;      * Returns a script that may later be executed.
&gt;      *
&gt;      * @param scope if nonnull, will be the scope in which the script object
&gt;      *        is created. The script object will be a valid JavaScript object
&gt;      *        as if it were created using the JavaScript1.3 Script constructor
&gt;      * @param source the source string
&gt;      * @param sourceName a string describing the source, such as a filename
&gt;      * @param lineno the starting line number for reporting errors
&gt;      * @param securityDomain an arbitrary object that specifies security
&gt;      *        information about the origin or owner of the script. For
&gt;      *        implementations that don't care about security, this value
&gt;      *        may be null.
&gt;      * @return a script that may later be executed
&gt;      * @see org.mozilla.javascript.Script#exec
&gt;      * @exception IOException if an IOException was generated by the Reader
&gt;      */
&gt;     public Script compileString(Scriptable scope, String source,
&gt;                                 String sourceName, int lineno,
&gt;                                 Object securityDomain)
&gt;     {
&gt;         try {
&gt;             return (Script) compile(scope, null, source, sourceName, lineno,
&gt;                                     securityDomain, false);
&gt;         } catch (IOException ex) {
&gt;             // Should not happen when dealing with source as string
&gt;             throw new RuntimeException();
&gt;         }
&gt;     }
925d953
&lt;         Reader in = new StringReader(source);
927c955
&lt;             return (Function) compile(scope, in, sourceName, lineno,
---
&gt;             return (Function) compile(scope, null, source, sourceName, lineno,
1906a1935,1952
&gt;     private static String readReader(Reader r)
&gt;         throws IOException
&gt;     {
&gt;         char[] buffer = new char[512];
&gt;         int cursor = 0;
&gt;         for (;;) {
&gt;             int n = r.read(buffer, cursor, buffer.length - cursor);
&gt;             if (n &lt; 0) { break; }
&gt;             cursor += n;
&gt;             if (cursor == buffer.length) {
&gt;                 char[] tmp = new char[buffer.length];
&gt;                 System.arraycopy(buffer, 0, tmp, 0, cursor);
&gt;                 buffer = tmp;
&gt;             }
&gt;         }
&gt;         return new String(buffer, 0, cursor);
&gt;     }
&gt; 
1933,1935c1979,1982
&lt;     private Object compile(Scriptable scope, Reader in, String sourceName,
&lt;                            int lineno, Object securityDomain,
&lt;                            boolean returnFunction)
---
&gt;     private Object compile(Scriptable scope,
&gt;                            Reader sourceReader, String sourceString,
&gt;                            String sourceName, int lineno,
&gt;                            Object securityDomain, boolean returnFunction)
1937a1985,1987
&gt;         // One of sourceReader or sourceString has to be null
&gt;         if (!(sourceReader == null ^ sourceString == null)) Context.codeBug();
&gt; 
1944,1945c1994,1998
&lt;         if (debugger != null &amp;&amp; in != null) {
&lt;             in = new DebugReader(in);
---
&gt;         if (debugger != null) {
&gt;             if (sourceReader != null) {
&gt;                 sourceString = readReader(sourceReader);
&gt;                 sourceReader = null;
&gt;             }
1947,1948c2000,2002
&lt;         TokenStream ts = new TokenStream(in, scope, sourceName, lineno);
&lt;         return compile(scope, ts, dynamicDoamin, in, returnFunction);
---
&gt;         TokenStream ts = new TokenStream(sourceReader, sourceString,
&gt;                                          scope, sourceName, lineno);
&gt;         return compile(scope, ts, dynamicDoamin, sourceString, returnFunction);
1981c2035
&lt;                            Object dynamicSecurityDomain, Reader in,
---
&gt;                            Object dynamicSecurityDomain, String sourceString,
2013,2015c2067,2069
&lt;         if (in instanceof DebugReader) {
&lt;             DebugReader dr = (DebugReader) in;
&lt;             tree.putProp(Node.DEBUGSOURCE_PROP, dr.getSaved());
---
&gt;         if (debugger != null) {
&gt;             if (sourceString == null) Context.codeBug();
&gt;             tree.putProp(Node.DEBUGSOURCE_PROP, sourceString);
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/debug/DebugReader.java" revision="1.8" state="deleted"/>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/TokenStream.java" revision="1.34" state="changed">23a24
&gt;  * Igor Bukanov
616,617c617,618
&lt;     public TokenStream(Reader in, Scriptable scope,
&lt;                        String sourceName, int lineno)
---
&gt;     public TokenStream(Reader sourceReader, String sourceString,
&gt;                        Scriptable scope, String sourceName, int lineno)
619d619
&lt;         this.in = new LineBuffer(in, lineno);
623c623,635
&lt;         flags = 0;
---
&gt;         this.lineno = lineno;
&gt;         this.flags = 0;
&gt;         if (sourceReader != null) {
&gt;             if (sourceString != null) Context.codeBug();
&gt;             this.sourceReader = sourceReader;
&gt;             this.sourceBuffer = new char[512];
&gt;             this.sourceEnd = 0;
&gt;         } else {
&gt;             if (sourceString == null) Context.codeBug();
&gt;             this.sourceString = sourceString;
&gt;             this.sourceEnd = sourceString.length();
&gt;         }
&gt;         this.sourceCursor = 0;
629a642,655
&gt;     public String getSourceName() { return sourceName; }
&gt; 
&gt;     public int getLineno() { return lineno; }
&gt; 
&gt;     public int getOp() { return op; }
&gt; 
&gt;     public String getString() { return string; }
&gt; 
&gt;     public double getNumber() { return number; }
&gt; 
&gt;     public int getTokenno() { return tokenno; }
&gt; 
&gt;     public boolean eof() { return hitEOF; }
&gt; 
649,653c675,676
&lt;         if (this.pushbackToken != EOF &amp;&amp; tt != ERROR) {
&lt;             String message = Context.getMessage2("msg.token.replaces.pushback",
&lt;                 tokenToString(tt), tokenToString(this.pushbackToken));
&lt;             throw new RuntimeException(message);
&lt;         }
---
&gt;         // Can not unread more then one token
&gt;         if (this.pushbackToken != EOF &amp;&amp; tt != ERROR) Context.codeBug();
677,738d699
&lt;     protected static boolean isJSIdentifier(String s) {
&lt;         int length = s.length();
&lt; 
&lt;         if (length == 0 || !Character.isJavaIdentifierStart(s.charAt(0)))
&lt;             return false;
&lt; 
&lt;         for (int i=1; i&lt;length; i++) {
&lt;             char c = s.charAt(i);
&lt;             if (!Character.isJavaIdentifierPart(c))
&lt;                 if (c == '\\')
&lt;                     if (! ((i + 5) &lt; length)
&lt;                             &amp;&amp; (s.charAt(i + 1) == 'u')
&lt;                             &amp;&amp; 0 &lt;= xDigitToInt(s.charAt(i + 2))
&lt;                             &amp;&amp; 0 &lt;= xDigitToInt(s.charAt(i + 3))
&lt;                             &amp;&amp; 0 &lt;= xDigitToInt(s.charAt(i + 4))
&lt;                             &amp;&amp; 0 &lt;= xDigitToInt(s.charAt(i + 5)))
&lt; 
&lt;                 return false;
&lt;         }
&lt; 
&lt;         return true;
&lt;     }
&lt; 
&lt;     private static boolean isAlpha(int c) {
&lt;         return ((c &gt;= 'a' &amp;&amp; c &lt;= 'z')
&lt;                 || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z'));
&lt;     }
&lt; 
&lt;     static boolean isDigit(int c) {
&lt;         return (c &gt;= '0' &amp;&amp; c &lt;= '9');
&lt;     }
&lt; 
&lt;     static int xDigitToInt(int c) {
&lt;         if ('0' &lt;= c &amp;&amp; c &lt;= '9') { return c - '0'; }
&lt;         if ('a' &lt;= c &amp;&amp; c &lt;= 'f') { return c - ('a' - 10); }
&lt;         if ('A' &lt;= c &amp;&amp; c &lt;= 'F') { return c - ('A' - 10); }
&lt;         return -1;
&lt;     }
&lt; 
&lt;     /* As defined in ECMA.  jsscan.c uses C isspace() (which allows
&lt;      * \v, I think.)  note that code in in.read() implicitly accepts
&lt;      * '\r' == \u000D as well.
&lt;      */
&lt;     public static boolean isJSSpace(int c) {
&lt;         return (c == '\u0020' || c == '\u0009'
&lt;                 || c == '\u000C' || c == '\u000B'
&lt;                 || c == '\u00A0'
&lt;                 || Character.getType((char)c) == Character.SPACE_SEPARATOR);
&lt;     }
&lt; 
&lt;     public static boolean isJSLineTerminator(int c) {
&lt;         return (c == '\n' || c == '\r'
&lt;                 || c == 0x2028 || c == 0x2029);
&lt;     }
&lt; 
&lt;     private void skipLine() throws IOException {
&lt;         // skip to end of line
&lt;         int c;
&lt;         while ((c = in.read()) != EOF_CHAR &amp;&amp; c != '\n') { }
&lt;         in.unread();
&lt;     }
&lt; 
751,753c712,716
&lt;         do {
&lt;             c = in.read();
&lt;             if (c == '\n') {
---
&gt;         for (;;) {
&gt;             c = getChar();
&gt;             if (c == EOF_CHAR) {
&gt;                 return EOF;
&gt;             } else if (c == '\n') {
755c718
&lt;                 if ((flags &amp; TSF_NEWLINES) != 0)
---
&gt;                 if ((flags &amp; TSF_NEWLINES) != 0) {
756a720,725
&gt;                 }
&gt;             } else if (!isJSSpace(c)) {
&gt;                 if (c != '-') {
&gt;                     flags |= TSF_DIRTYLINE;
&gt;                 }
&gt;                 break;
758,763c727
&lt;         } while (isJSSpace(c) || c == '\n');
&lt; 
&lt;         if (c == EOF_CHAR)
&lt;             return EOF;
&lt;         if (c != '-' &amp;&amp; c != '\n')
&lt;             flags |= TSF_DIRTYLINE;
---
&gt;         }
770c734
&lt;             c = in.read();
---
&gt;             c = getChar();
776a741
&gt;                 ungetChar(c);
778d742
&lt;                 in.unread();
800c764
&lt;                         c = in.read();
---
&gt;                         c = getChar();
812c776
&lt;                     c = in.read();
---
&gt;                     c = getChar();
814c778
&lt;                         c = in.read();
---
&gt;                         c = getChar();
823c787,789
&lt;                         if (!Character.isJavaIdentifierPart((char)c)) {
---
&gt;                         if (c == EOF_CHAR
&gt;                             || !Character.isJavaIdentifierPart((char)c))
&gt;                         {
830c796
&lt;             in.unread();
---
&gt;             ungetChar(c);
832c798
&lt;                String str = getStringFromBuffer();
---
&gt;             String str = getStringFromBuffer();
857c823
&lt;             this.string = str;
---
&gt;             this.string = (String)allStrings.intern(str);
862c828
&lt;         if (isDigit(c) || (c == '.' &amp;&amp; isDigit(in.peek()))) {
---
&gt;         if (isDigit(c) || (c == '.' &amp;&amp; isDigit(peekChar()))) {
868c834
&lt;                 c = in.read();
---
&gt;                 c = getChar();
871c837
&lt;                     c = in.read();
---
&gt;                     c = getChar();
882c848
&lt;                     c = in.read();
---
&gt;                     c = getChar();
898c864
&lt;                     c = in.read();
---
&gt;                     c = getChar();
909c875
&lt;                         c = in.read();
---
&gt;                         c = getChar();
914c880
&lt;                     c = in.read();
---
&gt;                     c = getChar();
917c883
&lt;                         c = in.read();
---
&gt;                         c = getChar();
925c891
&lt;                         c = in.read();
---
&gt;                         c = getChar();
929c895
&lt;             in.unread();
---
&gt;             ungetChar(c);
962c928
&lt;             c = in.read();
---
&gt;             c = getChar();
965c931
&lt;                     in.unread();
---
&gt;                     ungetChar(c);
973c939
&lt;                     c = in.read();
---
&gt;                     c = getChar();
995c961
&lt;                                 c = in.read();
---
&gt;                                 c = getChar();
1012c978
&lt;                             c = in.read();
---
&gt;                             c = getChar();
1019c985
&lt;                                 c = in.read();
---
&gt;                                 c = getChar();
1034c1000
&lt;                             c = in.read();
---
&gt;                             c = getChar();
1037c1003
&lt;                                 c = in.read();
---
&gt;                                 c = getChar();
1042c1008
&lt;                                     c = in.read();
---
&gt;                                     c = getChar();
1045c1011
&lt;                             in.unread();
---
&gt;                             ungetChar(c);
1051c1017
&lt;                 c = in.read();
---
&gt;                 c = getChar();
1054c1020,1021
&lt;             this.string = getStringFromBuffer();
---
&gt;             String str = getStringFromBuffer();
&gt;             this.string = (String)allStrings.intern(str);
1074c1041
&lt;             if (in.match('|')) {
---
&gt;             if (matchChar('|')) {
1076c1043
&lt;             } else if (in.match('=')) {
---
&gt;             } else if (matchChar('=')) {
1084c1051
&lt;             if (in.match('=')) {
---
&gt;             if (matchChar('=')) {
1092c1059
&lt;             if (in.match('&amp;')) {
---
&gt;             if (matchChar('&amp;')) {
1094c1061
&lt;             } else if (in.match('=')) {
---
&gt;             } else if (matchChar('=')) {
1102,1103c1069,1070
&lt;             if (in.match('=')) {
&lt;                 if (in.match('='))
---
&gt;             if (matchChar('=')) {
&gt;                 if (matchChar('='))
1114,1115c1081,1082
&lt;             if (in.match('=')) {
&lt;                 if (in.match('='))
---
&gt;             if (matchChar('=')) {
&gt;                 if (matchChar('='))
1127,1129c1094,1096
&lt;             if (in.match('!')) {
&lt;                 if (in.match('-')) {
&lt;                     if (in.match('-')) {
---
&gt;             if (matchChar('!')) {
&gt;                 if (matchChar('-')) {
&gt;                     if (matchChar('-')) {
1133c1100
&lt;                     in.unread();
---
&gt;                     ungetChar('-');
1135c1102
&lt;                 in.unread();
---
&gt;                 ungetChar('!');
1137,1138c1104,1105
&lt;             if (in.match('&lt;')) {
&lt;                 if (in.match('=')) {
---
&gt;             if (matchChar('&lt;')) {
&gt;                 if (matchChar('=')) {
1146c1113
&lt;                 if (in.match('=')) {
---
&gt;                 if (matchChar('=')) {
1156,1158c1123,1125
&lt;             if (in.match('&gt;')) {
&lt;                 if (in.match('&gt;')) {
&lt;                     if (in.match('=')) {
---
&gt;             if (matchChar('&gt;')) {
&gt;                 if (matchChar('&gt;')) {
&gt;                     if (matchChar('=')) {
1166c1133
&lt;                     if (in.match('=')) {
---
&gt;                     if (matchChar('=')) {
1175c1142
&lt;                 if (in.match('=')) {
---
&gt;                 if (matchChar('=')) {
1185c1152
&lt;             if (in.match('=')) {
---
&gt;             if (matchChar('=')) {
1194c1161
&lt;             if (in.match('/')) {
---
&gt;             if (matchChar('/')) {
1198,1200c1165,1167
&lt;             if (in.match('*')) {
&lt;                 while ((c = in.read()) != -1 &amp;&amp;
&lt;                        !(c == '*' &amp;&amp; in.match('/'))) {
---
&gt;             if (matchChar('*')) {
&gt;                 while ((c = getChar()) != -1 &amp;&amp;
&gt;                        !(c == '*' &amp;&amp; matchChar('/'))) {
1213c1180
&lt;                 while ((c = in.read()) != '/') {
---
&gt;                 while ((c = getChar()) != '/') {
1215c1182
&lt;                         in.unread();
---
&gt;                         ungetChar(c);
1221c1188
&lt;                         c = in.read();
---
&gt;                         c = getChar();
1229c1196
&lt;                     if (in.match('g'))
---
&gt;                     if (matchChar('g'))
1231c1198
&lt;                     else if (in.match('i'))
---
&gt;                     else if (matchChar('i'))
1233c1200
&lt;                     else if (in.match('m'))
---
&gt;                     else if (matchChar('m'))
1239c1206
&lt;                 if (isAlpha(in.peek())) {
---
&gt;                 if (isAlpha(peekChar())) {
1251c1218
&lt;             if (in.match('=')) {
---
&gt;             if (matchChar('=')) {
1260c1227
&lt;             if (in.match('=')) {
---
&gt;             if (matchChar('=')) {
1271c1238
&lt;             if (in.match('=')) {
---
&gt;             if (matchChar('=')) {
1274c1241
&lt;             } else if (in.match('+')) {
---
&gt;             } else if (matchChar('+')) {
1281c1248
&lt;             if (in.match('=')) {
---
&gt;             if (matchChar('=')) {
1284c1251
&lt;             } else if (in.match('-')) {
---
&gt;             } else if (matchChar('-')) {
1288c1255
&lt;                     if (in.match('&gt;')) {
---
&gt;                     if (matchChar('&gt;')) {
1305a1273,1319
&gt;     private static boolean isAlpha(int c) {
&gt;         // Use 'Z' &lt; 'a'
&gt;         if (c &lt;= 'Z') {
&gt;             return 'A' &lt;= c;
&gt;         } else {
&gt;             return 'a' &lt;= c &amp;&amp; c &lt;= 'z';
&gt;         }
&gt;     }
&gt; 
&gt;     static boolean isDigit(int c) {
&gt;         return '0' &lt;= c &amp;&amp; c &lt;= '9';
&gt;     }
&gt; 
&gt;     static int xDigitToInt(int c) {
&gt;         // Use 0..9 &lt; A..Z &lt; a..z
&gt;         if (c &lt;= '9') {
&gt;             c -= '0';
&gt;             if (0 &lt;= c) { return c; }
&gt;         } else if (c &lt;= 'F') {
&gt;             if ('A' &lt;= c) { return c - ('A' - 10); }
&gt;         } else if (c &lt;= 'f') {
&gt;             if ('a' &lt;= c) { return c - ('a' - 10); }
&gt;         }
&gt;         return -1;
&gt;     }
&gt; 
&gt;     /* As defined in ECMA.  jsscan.c uses C isspace() (which allows
&gt;      * \v, I think.)  note that code in getChar() implicitly accepts
&gt;      * '\r' == \u000D as well.
&gt;      */
&gt;     public static boolean isJSSpace(int c) {
&gt;         if (c &lt;= 127) {
&gt;             return c == 0x20 || c == 0x9 || c == 0xC || c == 0xB;
&gt;         } else {
&gt;             return c == 0xA0
&gt;                 || Character.getType((char)c) == Character.SPACE_SEPARATOR;
&gt;         }
&gt;     }
&gt; 
&gt;     public static boolean isJSLineTerminator(int c) {
&gt;         return c == '\n' || c == '\r' || c == 0x2028 || c == 0x2029;
&gt;     }
&gt; 
&gt;     private static boolean isJSFormatChar(int c) {
&gt;         return c &gt; 127 &amp;&amp; Character.getType((char)c) == Character.FORMAT;
&gt;     }
&gt; 
1339,1347c1353,1368
&lt;     public String getSourceName() { return sourceName; }
&lt;     public int getLineno() { return in.getLineno(); }
&lt;     public int getOp() { return op; }
&lt;     public String getString() { return string; }
&lt;     public double getNumber() { return number; }
&lt;     public String getLine() { return in.getLine(); }
&lt;     public int getOffset() { return in.getOffset(); }
&lt;     public int getTokenno() { return tokenno; }
&lt;     public boolean eof() { return in.eof(); }
---
&gt;     private void ungetChar(int c) {
&gt;         // can not unread past across line boundary
&gt;         if (ungetCursor != 0 &amp;&amp; ungetBuffer[ungetCursor - 1] == '\n')
&gt;             Context.codeBug();
&gt;         ungetBuffer[ungetCursor++] = c;
&gt;     }
&gt; 
&gt;     private boolean matchChar(int test) throws IOException {
&gt;         int c = getChar();
&gt;         if (c == test) {
&gt;             return true;
&gt;         } else {
&gt;             ungetChar(c);
&gt;             return false;
&gt;         }
&gt;     }
1349,1350c1370,1397
&lt;     // instance variables
&lt;     private LineBuffer in;
---
&gt;     private int peekChar() throws IOException {
&gt;         int c = getChar();
&gt;         ungetChar(c);
&gt;         return c;
&gt;     }
&gt; 
&gt;     private int getChar() throws IOException {
&gt;         if (ungetCursor != 0) {
&gt;             return ungetBuffer[--ungetCursor];
&gt;         }
&gt; 
&gt;         for(;;) {
&gt;             int c;
&gt;             if (sourceString != null) {
&gt;                 if (sourceCursor == sourceEnd) {
&gt;                     hitEOF = true;
&gt;                     return EOF_CHAR;
&gt;                 }
&gt;                 c = sourceString.charAt(sourceCursor++);
&gt;             } else {
&gt;                 if (sourceCursor == sourceEnd) {
&gt;                     if (!fillSourceBuffer()) {
&gt;                         hitEOF = true;
&gt;                         return EOF_CHAR;
&gt;                     }
&gt;                 }
&gt;                 c = sourceBuffer[sourceCursor++];
&gt;             }
1351a1399,1507
&gt;             if (lineEndChar &gt;= 0) {
&gt;                 if (lineEndChar == '\r' &amp;&amp; c == '\n') {
&gt;                     lineEndChar = '\n';
&gt;                     continue;
&gt;                 }
&gt;                 lineEndChar = -1;
&gt;                 lineStart = sourceCursor - 1;
&gt;                 lineno++;
&gt;             }
&gt; 
&gt;             if (c &lt;= 127) {
&gt;                 if (c == '\n' || c == '\r') {
&gt;                     lineEndChar = c;
&gt;                     c = '\n';
&gt;                 }
&gt;             } else {
&gt;                 if (isJSFormatChar(c)) {
&gt;                     continue;
&gt;                 }
&gt;                 if ((c &amp; EOL_HINT_MASK) == 0 &amp;&amp; isJSLineTerminator(c)) {
&gt;                     lineEndChar = c;
&gt;                     c = '\n';
&gt;                 }
&gt;             }
&gt;             return c;
&gt;         }
&gt;     }
&gt; 
&gt;     private void skipLine() throws IOException {
&gt;         // skip to end of line
&gt;         int c;
&gt;         while ((c = getChar()) != EOF_CHAR &amp;&amp; c != '\n') { }
&gt;         ungetChar(c);
&gt;     }
&gt; 
&gt;     public int getOffset() {
&gt;         int n = sourceCursor - lineStart;
&gt;         if (lineEndChar &gt;= 0) { --n; }
&gt;         return n;
&gt;     }
&gt; 
&gt;     public String getLine() {
&gt;         if (sourceString != null) {
&gt;             // String case
&gt;             int lineEnd = sourceCursor;
&gt;             if (lineEndChar &gt;= 0) {
&gt;                 --lineEnd;
&gt;             } else {
&gt;                 for (; lineEnd != sourceEnd; ++lineEnd) {
&gt;                     int c = sourceString.charAt(lineEnd);
&gt;                     if ((c &amp; EOL_HINT_MASK) == 0 &amp;&amp; isJSLineTerminator(c)) {
&gt;                         break;
&gt;                     }
&gt;                 }
&gt;             }
&gt;             return sourceString.substring(lineStart, lineEnd);
&gt;         } else {
&gt;             // Reader case
&gt;             int lineLength = sourceCursor - lineStart;
&gt;             if (lineEndChar &gt;= 0) {
&gt;                 --lineLength;
&gt;             } else {
&gt;                 // Read until the end of line
&gt;                 for (;; ++lineLength) {
&gt;                     int i = lineStart + lineLength;
&gt;                     if (i == sourceEnd) {
&gt;                         try {
&gt;                             if (!fillSourceBuffer()) { break; }
&gt;                         } catch (IOException ioe) {
&gt;                             // ignore it, we're already displaying an error...
&gt;                             break;
&gt;                         }
&gt;                         // i recalculuation as fillSourceBuffer can move saved
&gt;                         // line buffer and change lineStart
&gt;                         i = lineStart + lineLength;
&gt;                     }
&gt;                     int c = sourceBuffer[i];
&gt;                     if ((c &amp; EOL_HINT_MASK) == 0 &amp;&amp; isJSLineTerminator(c)) {
&gt;                         break;
&gt;                     }
&gt;                 }
&gt;             }
&gt;             return new String(sourceBuffer, lineStart, lineLength);
&gt;         }
&gt;     }
&gt; 
&gt;     private boolean fillSourceBuffer() throws IOException {
&gt;         if (sourceString != null) Context.codeBug();
&gt;         if (sourceEnd == sourceBuffer.length) {
&gt;             if (lineStart != 0) {
&gt;                 System.arraycopy(sourceBuffer, lineStart, sourceBuffer, 0,
&gt;                                  sourceEnd - lineStart);
&gt;                 sourceEnd -= lineStart;
&gt;                 sourceCursor -= lineStart;
&gt;                 lineStart = 0;
&gt;             } else {
&gt;                 char[] tmp = new char[sourceBuffer.length * 2];
&gt;                 System.arraycopy(sourceBuffer, 0, tmp, 0, sourceEnd);
&gt;                 sourceBuffer = tmp;
&gt;             }
&gt;         }
&gt;         int n = sourceReader.read(sourceBuffer, sourceEnd,
&gt;                                   sourceBuffer.length - sourceEnd);
&gt;         if (n &lt; 0) {
&gt;             return false;
&gt;         }
&gt;         sourceEnd += n;
&gt;         return true;
&gt;     }
1376a1533,1553
&gt;     private ObjToIntMap allStrings = new ObjToIntMap(50);
&gt; 
&gt;     // Room to backtrace from to &lt; on failed match of the last - in &lt;!--
&gt;     private final int[] ungetBuffer = new int[3];
&gt;     private int ungetCursor;
&gt; 
&gt;     private boolean hitEOF = false;
&gt; 
&gt;     // Optimization for faster check for eol character: isJSLineTerminator(c)
&gt;     // returns true only when (c &amp; EOL_HINT_MASK) == 0
&gt;     private static final int EOL_HINT_MASK = 0xdfd0;
&gt; 
&gt;     private int lineStart = 0;
&gt;     private int lineno;
&gt;     private int lineEndChar = -1;
&gt; 
&gt;     private String sourceString;
&gt;     private Reader sourceReader;
&gt;     private char[] sourceBuffer;
&gt;     private int sourceEnd;
&gt;     private int sourceCursor;
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/resources/Messages.properties" revision="1.35" state="changed"/>
</fixedFiles>
</bug>
<bug id="192105" transactionid="67794">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="9"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="42"/>
<property name="lines-churned" value="51"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>MZ</concisefingerprint>
<fullfingerprint>M O-() O-+ O-cast T V Y Z-cast</fullfingerprint>
<bugreport>User-Agent:       Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.0.1) Gecko/20021003
Build Identifier: Rhino CVS 2003-01-04

With optimization set to 1 or higher instanceof inside a function to test if the
function is called as a constructor or not returns false if the function is
called as constructor from some other function.

Reproducible: Always

Steps to Reproduce:
Run the following attached test case with rhino shell with optimization set to 1.
Actual Results:  
The test case prints FAILED

Expected Results:  
It should print OK

The test case ecma_3/Exceptions/regress-181914.js from the js test suite fails
with an infinite recursion for exactly this reason, just run it via jsDriver.pl
with the engine set to rhino9.</bugreport>
<testsforfix id="192105" type="new">
<test file="mozilla/js/tests/js1_5/Object/regress-192105.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/optimizer/Codegen.java" revision="1.79" state="changed">274,282c274,275
&lt;             Scriptable newInstance = new NativeObject();
&lt;             newInstance.setPrototype(getClassPrototype());
&lt;             newInstance.setParentScope(getParentScope());
&lt; 
&lt;             Object val = callDirect(&lt;directCallArgs&gt;);
&lt;             // except that the incoming thisArg is discarded
&lt;             // and replaced by newInstance
&lt;             //
&lt; 
---
&gt;             Scriptable newInstance = createObject(cx, scope);
&gt;             Object val = callDirect(cx, scope, newInstance, &lt;directCallArgs&gt;);
299,329c292
&lt;         short firstLocal = (short)((4 + argCount * 3) + 1);
&lt; 
&lt;         addByteCode(ByteCode.NEW, "org/mozilla/javascript/NativeObject");
&lt;         addByteCode(ByteCode.DUP);
&lt;         classFile.add(ByteCode.INVOKESPECIAL,
&lt;                                 "org/mozilla/javascript/NativeObject",
&lt;                                 "&lt;init&gt;", "()", "V");
&lt;         astore(firstLocal);
&lt; 
&lt;         aload(firstLocal);
&lt;         aload((short)0);
&lt;         addVirtualInvoke("org/mozilla/javascript/NativeFunction",
&lt;                             "getClassPrototype",
&lt;                             "()", "Lorg/mozilla/javascript/Scriptable;");
&lt;         classFile.add(ByteCode.INVOKEINTERFACE,
&lt;                         "org/mozilla/javascript/Scriptable",
&lt;                         "setPrototype",
&lt;                         "(Lorg/mozilla/javascript/Scriptable;)",
&lt;                         "V");
&lt; 
&lt; 
&lt;         aload(firstLocal);
&lt;         aload((short)0);
&lt;         addVirtualInvoke("org/mozilla/javascript/NativeFunction",
&lt;                             "getParentScope",
&lt;                             "()", "Lorg/mozilla/javascript/Scriptable;");
&lt;         classFile.add(ByteCode.INVOKEINTERFACE,
&lt;                         "org/mozilla/javascript/Scriptable",
&lt;                         "setPrototype",
&lt;                         "(Lorg/mozilla/javascript/Scriptable;)",
&lt;                         "V");
---
&gt;         int firstLocal = (4 + argCount * 3) + 1;
330a294,302
&gt;         aload((short)0); // this
&gt;         aload((short)1); // cx
&gt;         aload((short)2); // scope
&gt;         addVirtualInvoke("org/mozilla/javascript/BaseFunction",
&gt;                          "createObject",
&gt;                          "(Lorg/mozilla/javascript/Context;"
&gt;                          +"Lorg/mozilla/javascript/Scriptable;)",
&gt;                          "Lorg/mozilla/javascript/Scriptable;");
&gt;         astore((short)firstLocal);
335c307
&lt;         aload(firstLocal);
---
&gt;         aload((short)firstLocal);
361c333
&lt;         aload(firstLocal);
---
&gt;         aload((short)firstLocal);
</file>
</fixedFiles>
</bug>
<bug id="192226" transactionid="67233">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="4"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="10"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>MZ</concisefingerprint>
<fullfingerprint>M O-! O-&amp;&amp; T V Y Z-if</fullfingerprint>
<bugreport>User-Agent:       Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.0.1) Gecko/20021003
Build Identifier: Rhino CVS from 2003-02-07

With optimization set to at least one, optimizer fails when generating code for
a script function containing calls to to other functions inside the with or
catch statement. This bug is present at least since Rhino 1.5R3.


Reproducible: Always

Steps to Reproduce:
To test, run the following attached script with optimization set to 1.


Actual Results:  
Test fails with NullPointerException in omj.optimizer.Codegen. If calls to
test0() in the test script are commented out, then it would fail with
java.lang.VerifierError when loading the script.



Expected Results:  
Should print OK.</bugreport>
<testsforfix id="192226" type="new">
<test file="mozilla/js/tests/js1_5/Scope/regress-192226.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/optimizer/Codegen.java" revision="1.78" state="changed">1856,1857c1856,1858
&lt;                 push(0);
&lt;                 addByteCode(ByteCode.ANEWARRAY, "java/lang/Object");
---
&gt;                 classFile.add(ByteCode.GETSTATIC,
&gt;                         "org/mozilla/javascript/ScriptRuntime",
&gt;                         "emptyArgs", "[Ljava/lang/Object;");
1921c1922
&lt;         if (type != TokenStream.NEW) {
---
&gt;         if (!firstArgDone &amp;&amp; type != TokenStream.NEW) {
1929,1930c1930
&lt;                 push(childCount - argSkipCount);
&lt;                 addByteCode(ByteCode.ANEWARRAY, "java/lang/Object");
---
&gt;                 constructArgArray(childCount - argSkipCount);
1977,1980d1976
&lt;                                         // now we need to construct the array
&lt;                                         // (even if there are no args to load
&lt;                                         // into it) - REMIND could pass null
&lt;                                         // instead ?
</file>
</fixedFiles>
</bug>
<bug id="192288" transactionid="67593">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="13"/>
<property name="lines-churned" value="15"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if M O-!= T V Y Z-if</fullfingerprint>
<bugreport>User-Agent:       Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.0.1) Gecko/20021003
Build Identifier: Rhino CVS from 2003-02-07

With optimization set to 1 or higher 0 / 0  in functions leads to bad class code
triggering java.lang.NoSuchFieldError during execution. The bug is present at
least since  Rhino 1.5R3 so its fix has to wait post 1.5R4 time.

A simple test case is a script like

function f() { return 0 / 0; }
f();

which gives java.lang.NoSuchFieldError: jsK_0

This is the reason why ecma/Expressions/11.5.2.js from the test suite currently
fails when jsDriver.pl runs with --engine rhino9

Reproducible: Always

Steps to Reproduce:
Run the following attached test case under Rhino shell with optimization set to
1 or higher.

Actual Results:  
Exception in thread "main" java.lang.NoSuchFieldError: jsK_0
        at org.mozilla.javascript.gen.c1.call(/home/igor/w/js/x/opt.js:1)
        at
org.mozilla.javascript.optimizer.OptRuntime.callSimple(OptRuntime.java:275)
        at org.mozilla.javascript.gen.c2.call(/home/igor/w/js/x/opt.js:3)
        at org.mozilla.javascript.gen.c2.exec(/home/igor/w/js/x/opt.js)
        at org.mozilla.javascript.Context.evaluateReader(Context.java:818)
        at org.mozilla.javascript.tools.shell.Main.evaluateReader(Main.java:363)
        at org.mozilla.javascript.tools.shell.Main.processFileSecure(Main.java:354)
        at org.mozilla.javascript.tools.shell.Main.processFile(Main.java:291)
        at org.mozilla.javascript.tools.shell.Main.processSource(Main.java:283)
        at org.mozilla.javascript.tools.shell.Main.exec(Main.java:103)
        at org.mozilla.javascript.tools.shell.Main.main(Main.java:76)


Expected Results:  
It should print OK.</bugreport>
<testsforfix id="192288" type="new">
<test file="mozilla/js/tests/js1_5/Expressions/regress-192288.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/optimizer/Codegen.java" revision="1.80" state="changed">3007,3011c3007,3018
&lt;                 String constantName = "jsK_" + addNumberConstant(num);
&lt;                 String constantType = getStaticConstantWrapperType(num);
&lt;                 classFile.add(ByteCode.GETSTATIC,
&lt;                               classFile.fullyQualifiedForm(this.name),
&lt;                               constantName, constantType);
---
&gt;                 if (num != num) {
&gt;                     // Add NaN object
&gt;                     classFile.add(ByteCode.GETSTATIC,
&gt;                                   "org/mozilla/javascript/ScriptRuntime",
&gt;                                   "NaNobj", "Ljava/lang/Double;");
&gt;                 } else {
&gt;                     String constantName = "jsK_" + addNumberConstant(num);
&gt;                     String constantType = getStaticConstantWrapperType(num);
&gt;                     classFile.add(ByteCode.GETSTATIC,
&gt;                                   classFile.fullyQualifiedForm(this.name),
&gt;                                   constantName, constantType);
&gt;                 }
3042a3050,3051
&gt;         // NaN is provided via ScriptRuntime.NaNobj
&gt;         if (num != num) Context.codeBug();
3074c3083
&lt;             String constantName = "jsK_" + addNumberConstant(num);
---
&gt;             String constantName = "jsK_" + i;
</file>
</fixedFiles>
</bug>
<bug id="193418" transactionid="67410">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="22"/>
<property name="lines-deleted" value="97"/>
<property name="lines-modified" value="15"/>
<property name="lines-churned" value="134"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-break K-class K-else K-for K-if K-import K-new K-null K-package K-return K-while M O-== O-|| O-! O-!= O-() O-cast T V Z-cast Z-if Z-while</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>Empty block {} triggers NullPointerException when optimization &gt;= 1

With optimization level set to 1 or higher empty block { } usage can trigger
NullPointerException in the compiler.

To reproduce, run the following script against Rhino shell with the optimization
level set to 1:

//-------TEST START --------------------------------
var test = false;

function f() {
  while (0) {
    {  }
  }
  test = true;
}

f();

print(test ? "OK" : "FAILED!");
//-------TEST END ----------------------------------


The test should print "OK" but instead the following stack trace appears:


Exception in thread "main" java.lang.NullPointerException
        at org.mozilla.javascript.optimizer.Block.buildBlocks(Block.java:137)
        at
org.mozilla.javascript.optimizer.Optimizer.optimizeFunction(Optimizer.java:71)
        at org.mozilla.javascript.optimizer.Optimizer.optimize(Optimizer.java:149)
        at org.mozilla.javascript.optimizer.Codegen.compile(Codegen.java:95)
        at org.mozilla.javascript.Context.compile(Context.java:2072)
        at org.mozilla.javascript.Context.compile(Context.java:2002)
        at org.mozilla.javascript.Context.compileReader(Context.java:897)
        at org.mozilla.javascript.Context.evaluateReader(Context.java:815)
        at org.mozilla.javascript.tools.shell.Main.evaluateReader(Main.java:363)
        at org.mozilla.javascript.tools.shell.Main.processFileSecure(Main.java:354)
        at org.mozilla.javascript.tools.shell.Main.processFile(Main.java:291)
        at org.mozilla.javascript.tools.shell.Main.processSource(Main.java:283)
        at org.mozilla.javascript.tools.shell.Main.exec(Main.java:103)
        at org.mozilla.javascript.tools.shell.Main.main(Main.java:76)</bugreport>
<testsforfix id="193418" type="new">
<test file="mozilla/js/tests/js1_5/Regress/regress-193418.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/optimizer/StmtNodeIterator.java" revision="1.8" state="deleted"/>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/optimizer/Optimizer.java" revision="1.17" state="changed">1034c1034,1035
&lt;         ObjArray nodeList = new ObjArray();
---
&gt;         ObjArray statements = new ObjArray();
&gt;         ObjArray blockStack = new ObjArray();
1036,1040c1037,1046
&lt;         StmtNodeIterator iterator = new StmtNodeIterator(theFunction);
&lt;         Node node = iterator.nextNode();
&lt;         while (node != null) {
&lt;             nodeList.add(node);
&lt;             node = iterator.nextNode();
---
&gt;         Node node = theFunction;
&gt;         for (;;) {
&gt;             node = findNextStatementNode(node, blockStack);
&gt;             if (node == null) { break; }
&gt;             statements.add(node);
&gt;             node = node.getNext();
&gt;             if (node == null) {
&gt;                 if (blockStack.isEmpty()) { break; }
&gt;                 node = (Node)(blockStack.pop());
&gt;             }
1042,1043c1048,1050
&lt;         Node[] result = new Node[nodeList.size()];
&lt;         nodeList.toArray(result);
---
&gt; 
&gt;         Node[] result = new Node[statements.size()];
&gt;         statements.toArray(result);
1046a1054,1075
&gt;     private static Node findNextStatementNode(Node node, ObjArray blockStack)
&gt;     {
&gt;         for (;;) {
&gt;             int type = node.getType();
&gt;             boolean blockType = (type == TokenStream.BLOCK
&gt;                                  || type == TokenStream.LOOP
&gt;                                  || type == TokenStream.FUNCTION);
&gt;             if (!blockType) { return node; }
&gt;             Node first = node.getFirstChild();
&gt;             Node next = node.getNext();
&gt;             if (first == null) {
&gt;                 if (next == null) { return null; }
&gt;                 node = next;
&gt;             } else {
&gt;                 if (next != null) {
&gt;                     blockStack.push(next);
&gt;                 }
&gt;                 node = first;
&gt;             }
&gt;         }
&gt;     }
&gt; 
</file>
</fixedFiles>
</bug>
<bug id="193555" transactionid="67261">
<property name="files-churned" value="9"/>
<property name="java-files-churned" value="8"/>
<property name="classes-churned" value="8"/>
<property name="methods-churned" value="8"/>
<property name="hunks" value="34"/>
<property name="lines-added" value="11"/>
<property name="lines-deleted" value="25"/>
<property name="lines-modified" value="75"/>
<property name="lines-churned" value="111"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-continue K-for K-if K-new K-null K-throw K-try M O-== O-|| O-- O-!= O-++ T V Y Z-cast Z-for Z-if Z-throw Z-vardecl</fullfingerprint>
<bugreport>In 1.5R4 a function expression can not access its function name. To test, run
the following test case in the Rhino shell with arbitrary optimization:

var x = function f() { return f.toString(); };

var ok = (x.toString() === x());

print(ok ? "OK" : "FAILED");


In Rhino 1.5R3 it prints OK while running 1.5R4 produces:

js: "/home/igor/js/x/f_rec.js", line 2: uncaught JavaScript exception:
ReferenceError: "f" is not defined. (/home/igor/js/x/f_rec.js; line 2)</bugreport>
<testsforfix id="193555" type="new">
<test file="mozilla/js/tests/ecma_3/Function/regress-193555.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/optimizer/OptFunctionNode.java" revision="1.13" state="changed">50,53c50,53
&lt;     public void setVariableTable(VariableTable variableTable) {
&lt;         super.setVariableTable(variableTable);
&lt;         int N = variableTable.size();
&lt;         int parameterCount = variableTable.getParameterCount();
---
&gt;     protected void markVariableTableReady() {
&gt;         super.markVariableTableReady();
&gt;         int N = itsVariableTable.size();
&gt;         int parameterCount = itsVariableTable.getParameterCount();
56c56
&lt;             String name = variableTable.getVariable(i);
---
&gt;             String name = itsVariableTable.getVariable(i);
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/TokenStream.java" revision="1.38" state="changed">1355c1355
&lt;     private void reportSyntaxWarning(String messageProperty, Object[] args) {
---
&gt;     void reportSyntaxWarning(String messageProperty, Object[] args) {
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/FunctionNode.java" revision="1.16" state="changed">56,61c56
&lt;     public void setVariableTable(VariableTable variableTable) {
&lt;         // Can do it only once
&lt;         if (variableTable == null) Context.codeBug();
&lt;         if (itsVariableTable != null) Context.codeBug();
&lt;         itsVariableTable = variableTable;
&lt;     }
---
&gt;     protected void markVariableTableReady() { }
107c102
&lt;         return argNames.size();
---
&gt;         return itsVariableTable.getParameterCount();
115d109
&lt;     ObjArray argNames;
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/IRFactory.java" revision="1.32" state="changed">55,56c55,57
&lt;     public Object createScript(Object body, String sourceName,
&lt;                                int baseLineno, int endLineno, Object source)
---
&gt;     public Object
&gt;     createScript(Object body, VariableTable vars, String sourceName,
&gt;                  int baseLineno, int endLineno, String source)
60,61c61,62
&lt;         if (children != null)
&lt;             result.addChildrenToBack(children);
---
&gt;         if (children != null) { result.addChildrenToBack(children); }
&gt;         result.putProp(Node.VARS_PROP, vars);
209c210
&lt;     public Object createFunction(String name, ObjArray argNames,
---
&gt;     public Object createFunction(String name, VariableTable vars,
219c220
&lt;         f.argNames = argNames;
---
&gt;         f.itsVariableTable = vars;
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/Parser.java" revision="1.34" state="changed">106a107
&gt;         fn_vars = new VariableTable();
149c150
&lt;         pn = nf.createScript(pn, ts.getSourceName(),
---
&gt;         pn = nf.createScript(pn, fn_vars, ts.getSourceName(),
243c244,246
&lt;         ObjArray args = new ObjArray();
---
&gt;         VariableTable saved_vars = fn_vars;
&gt;         VariableTable new_vars = new VariableTable();
&gt; 
247a251
&gt;             fn_vars = new_vars;
263c267,271
&lt;                     args.add(s);
---
&gt;                     if (new_vars.hasVariable(s)) {
&gt;                         Object[] msgArgs = { s };
&gt;                         ts.reportSyntaxWarning("msg.dup.parms", msgArgs);
&gt;                     }
&gt;                     new_vars.addParameter(s);
284a293
&gt;             fn_vars = saved_vars;
289c298
&lt;             pn = nf.createFunction(name, args, body,
---
&gt;             pn = nf.createFunction(name, new_vars, body,
307c316
&lt;             pn = nf.createFunction(name, args, body,
---
&gt;             pn = nf.createFunction(name, new_vars, body,
879a889
&gt;             fn_vars.addLocal(s);
2278a2289,2290
&gt;     private VariableTable fn_vars;
&gt; 
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/NativeGlobal.java" revision="1.47" state="changed">507a508,512
&gt;         // Compile the reader with opt level of -1 to force interpreter
&gt;         // mode.
&gt;         int oldOptLevel = cx.getOptimizationLevel();
&gt;         cx.setOptimizationLevel(-1);
&gt;         Script script;
509c514,532
&lt;             StringReader in = new StringReader((String) x);
---
&gt;             script = cx.compileString(scope, (String)x, sourceName, 1,
&gt;                                       null);
&gt;         } finally {
&gt;             cx.setOptimizationLevel(oldOptLevel);
&gt;         }
&gt; 
&gt;         // if the compile fails, an error has been reported by the
&gt;         // compiler, but we need to stop execution to avoid
&gt;         // infinite looping on while(true) { eval('foo bar') } -
&gt;         // so we throw an EvaluatorException.
&gt;         if (script == null) {
&gt;             String message = Context.getMessage0("msg.syntax");
&gt;             throw new EvaluatorException(message);
&gt;         }
&gt; 
&gt;         InterpretedScript is = (InterpretedScript) script;
&gt;         is.itsData.itsFromEvalCode = true;
&gt;         Object result = is.call(cx, scope, (Scriptable) thisArg,
&gt;                                 ScriptRuntime.emptyArgs);
511,541c534
&lt;             // Compile the reader with opt level of -1 to force interpreter
&lt;             // mode.
&lt;             int oldOptLevel = cx.getOptimizationLevel();
&lt;             cx.setOptimizationLevel(-1);
&lt;             Script script;
&lt;             try {
&lt;                 script = cx.compileReader(scope, in, sourceName, 1, null);
&lt;             } finally {
&lt;                 cx.setOptimizationLevel(oldOptLevel);
&lt;             }
&lt; 
&lt;             // if the compile fails, an error has been reported by the
&lt;             // compiler, but we need to stop execution to avoid
&lt;             // infinite looping on while(true) { eval('foo bar') } -
&lt;             // so we throw an EvaluatorException.
&lt;             if (script == null) {
&lt;                 String message = Context.getMessage0("msg.syntax");
&lt;                 throw new EvaluatorException(message);
&lt;             }
&lt; 
&lt;             InterpretedScript is = (InterpretedScript) script;
&lt;             is.itsData.itsFromEvalCode = true;
&lt;             Object result = is.call(cx, scope, (Scriptable) thisArg,
&lt;                                     ScriptRuntime.emptyArgs);
&lt; 
&lt;             return result;
&lt;         }
&lt;         catch (IOException ioe) {
&lt;             // should never happen since we just made the Reader from a String
&lt;             throw new RuntimeException("unexpected io exception");
&lt;         }
---
&gt;         return result;
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/VariableTable.java" revision="1.22" state="changed">72,76c72
&lt;         int pIndex = itsVariableNames.get(pName, -1);
&lt;         if (itsVariableNames.has(pName)) {
&lt;             String message = Context.getMessage1("msg.dup.parms", pName);
&lt;             Context.reportWarning(message, null, 0, null, 0);
&lt;         }
---
&gt;         // Allow non-unique parameter names: use the last occurrence
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/NodeTransformer.java" revision="1.37" state="changed">67c67
&lt;         VariableTable vars = new VariableTable();
---
&gt;         VariableTable vars;
69,70c69,70
&lt;             addVariables(tree, vars);
&lt;             tree.putProp(Node.VARS_PROP, vars);
---
&gt;             vars = (VariableTable)tree.getProp(Node.VARS_PROP);
&gt;             checkVariables(tree, vars);
73,75c73,75
&lt;             addParameters(fnNode, vars);
&lt;             addVariables(tree, vars);
&lt;             fnNode.setVariableTable(vars);
---
&gt;             vars = fnNode.getVariableTable();
&gt;             checkVariables(tree, vars);
&gt;             fnNode.markVariableTableReady();
491,492c491,492
&lt;     protected void addVariables(Node tree, VariableTable vars) {
&lt;         // OPT: a whole pass to collect variables seems expensive.
---
&gt;     private void checkVariables(Node tree, VariableTable vars) {
&gt;         // OPT: a whole pass to check variables seems expensive.
495d494
&lt;         ObjToIntMap fNames = null;
511,522d509
&lt;                 if (fNames == null)
&lt;                     fNames = new ObjToIntMap();
&lt;                 fNames.put(name, 0);
&lt;             }
&lt;             if (nodeType != TokenStream.VAR)
&lt;                 continue;
&lt;             for (Node cursor = node.getFirstChild(); cursor != null;
&lt;                  cursor = cursor.getNext())
&lt;             {
&lt;                 String name = cursor.getString();
&lt;                 if (fNames == null || !fNames.has(name))
&lt;                     vars.addLocal(name);
529c516
&lt;                 &amp;&amp; name != null &amp;&amp; name.length() &gt; 0 &amp;&amp; vars.hasVariable(name))
---
&gt;                 &amp;&amp; name != null &amp;&amp; name.length() &gt; 0 &amp;&amp; !vars.hasVariable(name))
548,558d534
&lt;     protected void addParameters(FunctionNode fnNode, VariableTable vars) {
&lt;         if (vars.getParameterCount() == 0) {
&lt;             ObjArray argNames = fnNode.argNames;
&lt;             // Add parameters
&lt;             for (int i = 0, N = argNames.size(); i != N; ++i) {
&lt;                 String arg = (String)argNames.get(i);
&lt;                 vars.addParameter(arg);
&lt;             }
&lt;         }
&lt;     }
&lt; 
</file>
</fixedFiles>
</bug>
<bug id="194364" transactionid="67657">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="5"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-new K-return M O-cast T V Z-cast</fullfingerprint>
<bugreport>ECMA extension to support function expression statements in Rhino behaves
differently from SM and MSIE as it produces value which affects eval results.
For example, given the following, 

var x = eval('0; if (true) function f() {}')
print(x)

Rhino assigns to x the function f and prints 

function f() {
}

while SM assigns to x 0 and prints 0. With the standard function statements
Rhino behaves correctly and print(eval('0; function f() {}')) gives correct 0.</bugreport>
<testsforfix id="194364" type="new">
<test file="mozilla/js/tests/ecma_3/Statements/regress-194364.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/Parser.java" revision="1.41" state="changed">303c303
&lt;                 pn = nf.createExprStatement(pn, baseLineno);
---
&gt;                 pn = nf.createExprStatementNoReturn(pn, baseLineno);
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/IRFactory.java" revision="1.40" state="changed">104a105,108
&gt;     public Object createExprStatementNoReturn(Object expr, int lineno) {
&gt;         return new Node(TokenStream.POP, (Node) expr, lineno);
&gt;     }
&gt; 
</file>
</fixedFiles>
</bug>
<bug id="203402" transactionid="67085">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="--"/>
<property name="severity" value="major"/>
<concisefingerprint/>
<fullfingerprint>O-- T V Y</fullfingerprint>
<bugreport>User-Agent:       Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.0.2) Gecko/20021216
Build Identifier: Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.0.2) Gecko/20021216

The resultant class generated from the Rhino bytecode generator for the
following JavaScript causes the JVM to throw a VerifyError.

function testit()
{
   a = "a" + (1==0) ? "b" : "c";
}

The exception is:

[java.lang.VerifyError: (class: org/mozilla/javascript/gen/c156, method: call
signature:
(Lorg/mozilla/javascript/Context;Lorg/mozilla/javascript/Scriptable;Lorg/mozilla/javascript/Scriptable;[Ljava/lang/Object;)Ljava/lang/Object;)
Stack size too large]


Reproducible: Always

Steps to Reproduce:
1.  Use the following Java source:

import org.mozilla.javascript.*;
import java.io.StringReader;

public class RhinoTest
{
    public static void failingCase()
    {
        Context context = Context.enter();
        ImporterTopLevel global = new ImporterTopLevel(context);
        StringReader reader = new StringReader("function testit(){ a = \"a\" +
(1==0) ? \"b\" : \"c\"; }");
        try
        {
            Script script = context.compileReader(null, reader, "Example 1", 1,
null);
            script.exec(context, global);
        }
        catch (Exception e)
        {
            e.printStackTrace(System.err);
        }
        context.exit();
    }

    public static void main(String[] args)
    {
        failingCase();
    }
}

Actual Results:  
Exception in thread "main" java.lang.VerifyError: (class: org/mozilla/javascript
/gen/c1, method: call signature: (Lorg/mozilla/javascript/Context;Lorg/mozilla/j
avascript/Scriptable;Lorg/mozilla/javascript/Scriptable;[Ljava/lang/Object;)Ljav
a/lang/Object;) Stack size too large
        at org.mozilla.javascript.gen.c2.call(Example 1)
        at org.mozilla.javascript.gen.c2.exec(Example 1)
        at RhinoTest.failingCase(RhinoTest.java:14)
        at RhinoTest.main(RhinoTest.java:25)

Expected Results:  
Shouldn't have gotten a JVM class verification error

It looks like the placement of the ternary operator is important.  The following
example does not have a problem:

function testit()
{
   a =(1==0) ? "b" : "c" + "a";
}</bugreport>
<testsforfix id="203402" type="new">
<test file="mozilla/js/tests/js1_5/Regress/regress-203402.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/optimizer/Codegen.java" revision="1.106" state="changed">1242,1244c1242,1243
&lt;                     generateCodeFromNode(child, node, trueLabel, falseLabel);
&lt;                     generateCodeFromNode(child.getNext(),
&lt;                                                  node, trueLabel, falseLabel);
---
&gt;                     generateCodeFromNode(child, node, -1, -1);
&gt;                     generateCodeFromNode(child.getNext(), node, -1, -1);
</file>
</fixedFiles>
</bug>
<bug id="203841" transactionid="67929">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="106"/>
<property name="lines-added" value="92"/>
<property name="lines-deleted" value="19"/>
<property name="lines-modified" value="367"/>
<property name="lines-churned" value="478"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-break K-else K-if K-return K-true M O-== O-|| O-- O-! O-!= O-+ T V Y Z-if Z-switch</fullfingerprint>
<bugreport>User-Agent:       Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.0.2) Gecko/20021216
Build Identifier: Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.0.2) Gecko/20021216

When using a comma operator inside an if statement in non-interpreted mode, as
in the following example,

if (a = 5, b == 6) { c = 1; }

Rhino throws this exception:

Exception in thread "main" java.lang.IllegalStateException: Stack underflow: -1
        at org.mozilla.classfile.ClassFileWriter.badStack(ClassFileWriter.java:1154)
        at org.mozilla.classfile.ClassFileWriter.add(ClassFileWriter.java:401)
        at org.mozilla.javascript.optimizer.Codegen.addByteCode(Codegen.java:3568)
        at org.mozilla.javascript.optimizer.Codegen.visitGOTO(Codegen.java:1574)
        at
org.mozilla.javascript.optimizer.Codegen.generateCodeFromNode(Codegen.java:1172)
        at
org.mozilla.javascript.optimizer.Codegen.generateCodeFromNode(Codegen.java:1044)
        at
org.mozilla.javascript.optimizer.Codegen.generateCodeFromNode(Codegen.java:1044)
        at org.mozilla.javascript.optimizer.Codegen.generateCode(Codegen.java:409)
        at org.mozilla.javascript.optimizer.Codegen.compile(Codegen.java:137)
        at org.mozilla.javascript.Context.compile(Context.java:1916)
        at org.mozilla.javascript.Context.compileReader(Context.java:886)
        at org.mozilla.javascript.Context.evaluateReader(Context.java:803)
        at org.mozilla.javascript.tools.shell.Main.evaluateReader(Main.java:363)
        at org.mozilla.javascript.tools.shell.Main.processSource(Main.java:260)
        at org.mozilla.javascript.tools.shell.Main.exec(Main.java:103)
        at org.mozilla.javascript.tools.shell.Main.main(Main.java:76)

Reproducible: Always

Steps to Reproduce:
1. use the js&gt; shell
2. Enter the following:

js&gt; Packages.org.mozilla.javascript.Context.enter().setOptimizationLevel(1);
js&gt; if (a = 5, b==6} { return false; }

Actual Results:  
Got this exception:

org.mozilla.javascript.optimizer.Codegen.generateCode(Codegen.java:409)
        at org.mozilla.javascript.optimizer.Codegen.compile(Codegen.java:137)
        at org.mozilla.javascript.Context.compile(Context.java:1916)
        at org.mozilla.javascript.Context.compileReader(Context.java:886)
        at org.mozilla.javascript.Context.evaluateReader(Context.java:803)
        at org.mozilla.javascript.tools.shell.Main.evaluateReader(Main.java:363)
        at org.mozilla.javascript.tools.shell.Main.processSource(Main.java:260)
        at org.mozilla.javascript.tools.shell.Main.exec(Main.java:103)
        at org.mozilla.javascript.tools.shell.Main.main(Main.java:76)

Expected Results:  
No exception

This isn't a problem in interpreted mode.</bugreport>
<testsforfix id="203841" type="new">
<test file="mozilla/js/tests/js1_5/Regress/regress-203841.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/optimizer/Codegen.java" revision="1.107" state="changed">409c409
&lt;         generateCodeFromNode(codegenBase, null, -1, -1);
---
&gt;         generateCodeFromNode(codegenBase, null);
1015,1016c1015
&lt;     private void generateCodeFromNode(Node node, Node parent, int trueLabel,
&lt;                                       int falseLabel)
---
&gt;     private void generateCodeFromNode(Node node, Node parent)
1028c1027
&lt;                     generateCodeFromNode(child, node, trueLabel, falseLabel);
---
&gt;                     generateCodeFromNode(child, node);
1044c1043
&lt;                     generateCodeFromNode(child, node, trueLabel, falseLabel);
---
&gt;                     generateCodeFromNode(child, node);
1102c1101
&lt;                     generateCodeFromNode(child, node, -1, -1);
---
&gt;                     generateCodeFromNode(child, node);
1107c1106
&lt;                 generateCodeFromNode(child, node, trueLabel, falseLabel);
---
&gt;                 generateCodeFromNode(child, node);
1145c1144
&lt;                         generateCodeFromNode(child, node, trueLabel, falseLabel);
---
&gt;                         generateCodeFromNode(child, node);
1158c1157
&lt;                     generateCodeFromNode(child, node, trueLabel, falseLabel);
---
&gt;                     generateCodeFromNode(child, node);
1176c1175
&lt;                 visitUnary(node, child, trueLabel, falseLabel);
---
&gt;                 visitUnary(node, child);
1193,1237c1192,1203
&lt;                     if (trueLabel == -1) {
&lt;                         generateCodeFromNode(child, node, trueLabel, falseLabel);
&lt;                         addByteCode(ByteCode.DUP);
&lt;                         addScriptRuntimeInvoke("toBoolean",
&lt;                                                "(Ljava/lang/Object;)Z");
&lt;                         int falseTarget = acquireLabel();
&lt;                         if (type == TokenStream.AND)
&lt;                             addByteCode(ByteCode.IFEQ, falseTarget);
&lt;                         else
&lt;                             addByteCode(ByteCode.IFNE, falseTarget);
&lt;                         addByteCode(ByteCode.POP);
&lt;                         generateCodeFromNode(child.getNext(), node, trueLabel, falseLabel);
&lt;                         markLabel(falseTarget);
&lt;                     }
&lt;                     else {
&lt;                         int interLabel = acquireLabel();
&lt;                         if (type == TokenStream.AND) {
&lt;                             generateCodeFromNode(child, node, interLabel,
&lt;                                                  falseLabel);
&lt;                             if (!childIsBoolean(child)) {
&lt;                                 addScriptRuntimeInvoke("toBoolean",
&lt;                                                        "(Ljava/lang/Object;)Z");
&lt;                                 addByteCode(ByteCode.IFNE, interLabel);
&lt;                                 addByteCode(ByteCode.GOTO, falseLabel);
&lt;                             }
&lt;                         }
&lt;                         else {
&lt;                             generateCodeFromNode(child, node, trueLabel, interLabel);
&lt;                             if (!childIsBoolean(child)) {
&lt;                                 addScriptRuntimeInvoke("toBoolean",
&lt;                                                        "(Ljava/lang/Object;)Z");
&lt;                                 addByteCode(ByteCode.IFNE, trueLabel);
&lt;                                 addByteCode(ByteCode.GOTO, interLabel);
&lt;                             }
&lt;                         }
&lt;                         markLabel(interLabel);
&lt;                         child = child.getNext();
&lt;                         generateCodeFromNode(child, node, trueLabel, falseLabel);
&lt;                         if (!childIsBoolean(child)) {
&lt;                             addScriptRuntimeInvoke("toBoolean",
&lt;                                                    "(Ljava/lang/Object;)Z");
&lt;                             addByteCode(ByteCode.IFNE, trueLabel);
&lt;                             addByteCode(ByteCode.GOTO, falseLabel);
&lt;                         }
&lt;                     }
---
&gt;                     generateCodeFromNode(child, node);
&gt;                     addByteCode(ByteCode.DUP);
&gt;                     addScriptRuntimeInvoke("toBoolean",
&gt;                                            "(Ljava/lang/Object;)Z");
&gt;                     int falseTarget = acquireLabel();
&gt;                     if (type == TokenStream.AND)
&gt;                         addByteCode(ByteCode.IFEQ, falseTarget);
&gt;                     else
&gt;                         addByteCode(ByteCode.IFNE, falseTarget);
&gt;                     addByteCode(ByteCode.POP);
&gt;                     generateCodeFromNode(child.getNext(), node);
&gt;                     markLabel(falseTarget);
1242,1243c1208,1209
&lt;                     generateCodeFromNode(child, node, -1, -1);
&lt;                     generateCodeFromNode(child.getNext(), node, -1, -1);
---
&gt;                     generateCodeFromNode(child, node);
&gt;                     generateCodeFromNode(child.getNext(), node);
1294,1295c1260
&lt;                         generateCodeFromNode(child, node,
&lt;                                              trueLabel, falseLabel);
---
&gt;                         generateCodeFromNode(child, node);
1299,1307c1264,1273
&lt;                     }
&lt;                     else {
&lt;                         if (toType == ScriptRuntime.DoubleClass) {
&lt;                                                                // cnvt to double
&lt;                                                                // (not Double)
&lt;                             generateCodeFromNode(child, node,
&lt;                                                  trueLabel, falseLabel);
&lt;                             addScriptRuntimeInvoke("toNumber",
&lt;                                                    "(Ljava/lang/Object;)D");
---
&gt;                     } else if (toType == ScriptRuntime.DoubleClass) {
&gt;                         // cnvt to double (not Double)
&gt;                         generateCodeFromNode(child, node);
&gt;                         addScriptRuntimeInvoke("toNumber",
&gt;                                                "(Ljava/lang/Object;)D");
&gt;                     } else if (toType == ScriptRuntime.ObjectClass) {
&gt;                         // convert from double
&gt;                         int prop = -1;
&gt;                         if (child.getType() == TokenStream.NUMBER) {
&gt;                             prop = child.getIntProp(Node.ISNUMBER_PROP, -1);
1309,1331c1275,1283
&lt;                         else {
&lt;                             if (toType == ScriptRuntime.ObjectClass) {
&lt;                                 // convert from double
&lt;                                 int prop = -1;
&lt;                                 if (child.getType() == TokenStream.NUMBER) {
&lt;                                     prop = child.getIntProp(Node.ISNUMBER_PROP,
&lt;                                                             -1);
&lt;                                 }
&lt;                                 if (prop != -1) {
&lt;                                     child.removeProp(Node.ISNUMBER_PROP);
&lt;                                     generateCodeFromNode(child, node, trueLabel,
&lt;                                                          falseLabel);
&lt;                                     child.putIntProp(Node.ISNUMBER_PROP, prop);
&lt;                                 }
&lt;                                 else {
&lt;                                     addByteCode(ByteCode.NEW, "java/lang/Double");
&lt;                                     addByteCode(ByteCode.DUP);
&lt;                                     generateCodeFromNode(child, node, trueLabel, falseLabel);
&lt;                                     addDoubleConstructor();
&lt;                                 }
&lt;                             }
&lt;                             else
&lt;                                 badTree();
---
&gt;                         if (prop != -1) {
&gt;                             child.removeProp(Node.ISNUMBER_PROP);
&gt;                             generateCodeFromNode(child, node);
&gt;                             child.putIntProp(Node.ISNUMBER_PROP, prop);
&gt;                         } else {
&gt;                             addByteCode(ByteCode.NEW, "java/lang/Double");
&gt;                             addByteCode(ByteCode.DUP);
&gt;                             generateCodeFromNode(child, node);
&gt;                             addDoubleConstructor();
1332a1285,1286
&gt;                     } else {
&gt;                         badTree();
1338,1341c1292,1293
&lt;                 if (trueLabel == -1)    // need a result Object
&lt;                     visitRelOp(node, child, parent);
&lt;                 else
&lt;                     visitGOTOingRelOp(node, child, parent, trueLabel, falseLabel);
---
&gt;                 // need a result Object
&gt;                 visitRelOp(node, child);
1345c1297
&lt;                 visitEqOp(node, child, parent, trueLabel, falseLabel);
---
&gt;                 visitEqOp(node, child);
1354c1306
&lt;                     generateCodeFromNode(child, node, trueLabel, falseLabel);
---
&gt;                     generateCodeFromNode(child, node);
1398c1350
&lt;                     generateCodeFromNode(child, node, trueLabel, falseLabel);
---
&gt;                     generateCodeFromNode(child, node);
1426c1378
&lt;                     generateCodeFromNode(child, node, trueLabel, falseLabel);
---
&gt;                     generateCodeFromNode(child, node);
1443c1395
&lt;                 generateCodeFromNode(child, node, trueLabel, falseLabel);
---
&gt;                 generateCodeFromNode(child, node);
1450c1402
&lt;                 generateCodeFromNode(child, node, trueLabel, falseLabel);
---
&gt;                 generateCodeFromNode(child, node);
1478a1431,1484
&gt;     private void generateIfJump(Node node, Node parent,
&gt;                                 int trueLabel, int falseLabel)
&gt;     {
&gt;         // System.out.println("gen code for " + node.toString());
&gt; 
&gt;         int type = node.getType();
&gt;         Node child = node.getFirstChild();
&gt; 
&gt;         boolean jumpIsDone = false;
&gt; 
&gt;         switch (type) {
&gt;           case TokenStream.UNARYOP:
&gt;             if (node.getOperation() == TokenStream.NOT) {
&gt;                 generateIfJump(child, node, falseLabel, trueLabel);
&gt;                 jumpIsDone = true;
&gt;             }
&gt;             break;
&gt; 
&gt;           case TokenStream.OR:
&gt;           case TokenStream.AND: {
&gt;             int interLabel = acquireLabel();
&gt;             if (type == TokenStream.AND) {
&gt;                 generateIfJump(child, node, interLabel, falseLabel);
&gt;             }
&gt;             else {
&gt;                 generateIfJump(child, node, trueLabel, interLabel);
&gt;             }
&gt;             markLabel(interLabel);
&gt;             child = child.getNext();
&gt;             generateIfJump(child, node, trueLabel, falseLabel);
&gt;             jumpIsDone = true;
&gt;             break;
&gt;           }
&gt; 
&gt;           case TokenStream.RELOP:
&gt;             visitIfJumpRelOp(node, child, trueLabel, falseLabel);
&gt;             jumpIsDone = true;
&gt;             break;
&gt; 
&gt;           case TokenStream.EQOP:
&gt;             visitIfJumpEqOp(node, child, trueLabel, falseLabel);
&gt;             jumpIsDone = true;
&gt;             break;
&gt;         }
&gt; 
&gt;         if (!jumpIsDone) {
&gt;             // Generate generic code for non-optimized jump
&gt;             generateCodeFromNode(node, parent);
&gt;             addScriptRuntimeInvoke("toBoolean", "(Ljava/lang/Object;)Z");
&gt;             addByteCode(ByteCode.IFNE, trueLabel);
&gt;             addByteCode(ByteCode.GOTO, falseLabel);
&gt;         }
&gt;     }
&gt; 
1565c1571
&lt;                     generateCodeFromNode(child, node, targetLabel, fallThruLabel);
---
&gt;                     generateIfJump(child, node, targetLabel, fallThruLabel);
1567,1575c1573
&lt;                     generateCodeFromNode(child, node, fallThruLabel, targetLabel);
&lt;                 if (!childIsBoolean(child)) {
&lt;                     addScriptRuntimeInvoke("toBoolean",
&lt;                                            "(Ljava/lang/Object;)Z");
&lt;                     if (type == TokenStream.IFEQ)
&lt;                         addByteCode(ByteCode.IFNE, targetLabel);
&lt;                     else
&lt;                         addByteCode(ByteCode.IFEQ, targetLabel);
&lt;                 }
---
&gt;                     generateIfJump(child, node, fallThruLabel, targetLabel);
1580c1578
&lt;                 generateCodeFromNode(child, node, -1, -1);
---
&gt;                 generateCodeFromNode(child, node);
1594c1592
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
1610c1608
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
1623c1621
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
1634c1632
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
1676c1674
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
1711c1709
&lt;                 generateCodeFromNode(child, node, -1, -1);
---
&gt;                 generateCodeFromNode(child, node);
1741c1739
&lt;                         generateCodeFromNode(child, node, -1, -1);
---
&gt;                         generateCodeFromNode(child, node);
1744c1742
&lt;                         generateCodeFromNode(child, node, -1, -1);
---
&gt;                         generateCodeFromNode(child, node);
1910c1908
&lt;                 generateCodeFromNode(child, node, -1, -1);
---
&gt;                 generateCodeFromNode(child, node);
1928c1926
&lt;                             generateCodeFromNode(child, node, -1, -1);
---
&gt;                             generateCodeFromNode(child, node);
1938c1936
&lt;                             generateCodeFromNode(child, node, -1, -1);
---
&gt;                             generateCodeFromNode(child, node);
1942c1940
&lt;                             generateCodeFromNode(child, node, -1, -1);
---
&gt;                             generateCodeFromNode(child, node);
1946c1944
&lt;                     generateCodeFromNode(child, node, -1, -1);
---
&gt;                     generateCodeFromNode(child, node);
2065c2063
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
2197c2195
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
2217c2215
&lt;                 generateCodeFromNode(child, node, -1, -1);
---
&gt;                 generateCodeFromNode(child, node);
2235c2233
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
2247c2245
&lt;             generateCodeFromNode(first, thisCase, -1, -1);
---
&gt;             generateCodeFromNode(first, thisCase);
2276c2274
&lt;     private void visitUnary(Node node, Node child, int trueGOTO, int falseGOTO)
---
&gt;     private void visitUnary(Node node, Node child)
2280,2304c2278,2282
&lt;           case TokenStream.NOT:
&lt;           {
&lt;             if (trueGOTO != -1) {
&lt;                 generateCodeFromNode(child, node, falseGOTO, trueGOTO);
&lt;                 if (!childIsBoolean(child)) {
&lt;                     addScriptRuntimeInvoke("toBoolean",
&lt;                                            "(Ljava/lang/Object;"
&lt;                                            +")Z");
&lt;                     addByteCode(ByteCode.IFNE, falseGOTO);
&lt;                     addByteCode(ByteCode.GOTO, trueGOTO);
&lt;                 }
&lt;             }
&lt;             else {
&lt;                 int trueTarget = acquireLabel();
&lt;                 int falseTarget = acquireLabel();
&lt;                 int beyond = acquireLabel();
&lt;                 generateCodeFromNode(child, node, trueTarget, falseTarget);
&lt; 
&lt;                 if (!childIsBoolean(child)) {
&lt;                     addScriptRuntimeInvoke("toBoolean",
&lt;                                            "(Ljava/lang/Object;"
&lt;                                            +")Z");
&lt;                     addByteCode(ByteCode.IFEQ, falseTarget);
&lt;                     addByteCode(ByteCode.GOTO, trueTarget);
&lt;                 }
---
&gt;           case TokenStream.NOT: {
&gt;             int trueTarget = acquireLabel();
&gt;             int falseTarget = acquireLabel();
&gt;             int beyond = acquireLabel();
&gt;             generateIfJump(child, node, trueTarget, falseTarget);
2306,2315c2284,2292
&lt;                 markLabel(trueTarget);
&lt;                 classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
&lt;                                         "FALSE", "Ljava/lang/Boolean;");
&lt;                 addByteCode(ByteCode.GOTO, beyond);
&lt;                 markLabel(falseTarget);
&lt;                 classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
&lt;                                         "TRUE", "Ljava/lang/Boolean;");
&lt;                 markLabel(beyond);
&lt;                 classFile.adjustStackTop(-1);
&lt;             }
---
&gt;             markLabel(trueTarget);
&gt;             classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
&gt;                                     "FALSE", "Ljava/lang/Boolean;");
&gt;             addByteCode(ByteCode.GOTO, beyond);
&gt;             markLabel(falseTarget);
&gt;             classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
&gt;                                     "TRUE", "Ljava/lang/Boolean;");
&gt;             markLabel(beyond);
&gt;             classFile.adjustStackTop(-1);
2324c2301
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
2332c2309
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
2344c2321
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
2357,2370d2333
&lt;     private static boolean childIsBoolean(Node child)
&lt;     {
&lt;         switch (child.getType()) {
&lt;             case TokenStream.UNARYOP:
&lt;                 return child.getOperation() == TokenStream.NOT;
&lt;             case TokenStream.AND:
&lt;             case TokenStream.OR:
&lt;             case TokenStream.RELOP:
&lt;             case TokenStream.EQOP:
&lt;                 return true;
&lt;         }
&lt;         return false;
&lt;     }
&lt; 
2374c2337
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
2434,2435c2397,2398
&lt;                 generateCodeFromNode(getPropChild, node, -1, -1);
&lt;                 generateCodeFromNode(getPropChild.getNext(), node, -1, -1);
---
&gt;                 generateCodeFromNode(getPropChild, node);
&gt;                 generateCodeFromNode(getPropChild.getNext(), node);
2445,2446c2408,2409
&lt;                 generateCodeFromNode(getPropChild, node, -1, -1);
&lt;                 generateCodeFromNode(getPropChild.getNext(), node, -1, -1);
---
&gt;                 generateCodeFromNode(getPropChild, node);
&gt;                 generateCodeFromNode(getPropChild.getNext(), node);
2464c2427
&lt;     private boolean isArithmeticNode(Node node)
---
&gt;     private static boolean isArithmeticNode(Node node)
2478,2479c2441,2442
&lt;             generateCodeFromNode(child, node, -1, -1);
&lt;             generateCodeFromNode(child.getNext(), node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
&gt;             generateCodeFromNode(child.getNext(), node);
2488c2451
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
2491c2454
&lt;             generateCodeFromNode(child.getNext(), node, -1, -1);
---
&gt;             generateCodeFromNode(child.getNext(), node);
2508c2471
&lt;         generateCodeFromNode(child, node, -1, -1);
---
&gt;         generateCodeFromNode(child, node);
2515c2478
&lt;             generateCodeFromNode(child.getNext(), node, -1, -1);
---
&gt;             generateCodeFromNode(child.getNext(), node);
2528c2491
&lt;             generateCodeFromNode(child.getNext(), node, -1, -1);
---
&gt;             generateCodeFromNode(child.getNext(), node);
2533c2496
&lt;             generateCodeFromNode(child.getNext(), node, -1, -1);
---
&gt;             generateCodeFromNode(child.getNext(), node);
2599,2600c2562,2563
&lt;     private void visitGOTOingRelOp(Node node, Node child, Node parent,
&lt;                                    int trueGOTO, int falseGOTO)
---
&gt;     private void visitIfJumpRelOp(Node node, Node child,
&gt;                                   int trueGOTO, int falseGOTO)
2605,2606c2568,2569
&lt;             generateCodeFromNode(child, node, -1, -1);
&lt;             generateCodeFromNode(child.getNext(), node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
&gt;             generateCodeFromNode(child.getNext(), node);
2611,2612c2574,2575
&lt;                 generateCodeFromNode(child, node, -1, -1);
&lt;                 generateCodeFromNode(child.getNext(), node, -1, -1);
---
&gt;                 generateCodeFromNode(child, node);
&gt;                 generateCodeFromNode(child.getNext(), node);
2622,2623c2585,2586
&lt;                 generateCodeFromNode(child, node, -1, -1);
&lt;                 generateCodeFromNode(child.getNext(), node, -1, -1);
---
&gt;                 generateCodeFromNode(child, node);
&gt;                 generateCodeFromNode(child.getNext(), node);
2679c2642
&lt;                                 generateCodeFromNode(rChild, node, -1, -1);
---
&gt;                                 generateCodeFromNode(rChild, node);
2699c2662
&lt;                             generateCodeFromNode(child, node, -1, -1);
---
&gt;                             generateCodeFromNode(child, node);
2707,2708c2670,2671
&lt;                 generateCodeFromNode(child, node, -1, -1);
&lt;                 generateCodeFromNode(rChild, node, -1, -1);
---
&gt;                 generateCodeFromNode(child, node);
&gt;                 generateCodeFromNode(rChild, node);
2745c2708
&lt;     private void visitRelOp(Node node, Node child, Node parent)
---
&gt;     private void visitRelOp(Node node, Node child)
2758,2759c2721,2722
&lt;             generateCodeFromNode(child, node, -1, -1);
&lt;             generateCodeFromNode(child.getNext(), node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
&gt;             generateCodeFromNode(child.getNext(), node);
2794,2795c2757,2758
&lt;             generateCodeFromNode(child, node, -1, -1);
&lt;             generateCodeFromNode(child.getNext(), node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
&gt;             generateCodeFromNode(child.getNext(), node);
2844,2845c2807
&lt;     private void visitEqOp(Node node, Node child, Node parent, int trueGOTO,
&lt;                            int falseGOTO)
---
&gt;     private void visitEqOp(Node node, Node child)
2851,2882c2813,2823
&lt;         if (trueGOTO == -1) {
&lt;             if (rightChild.getType() == TokenStream.PRIMARY &amp;&amp;
&lt;                 rightChild.getOperation() == TokenStream.NULL)
&lt;             {
&lt;                 generateCodeFromNode(child, node, -1, -1);
&lt;                 if (isStrict) {
&lt;                     addByteCode(ByteCode.IFNULL, 9);
&lt;                 } else {
&lt;                     addByteCode(ByteCode.DUP);
&lt;                     addByteCode(ByteCode.IFNULL, 15);
&lt;                     pushUndefined();
&lt;                     addByteCode(ByteCode.IF_ACMPEQ, 10);
&lt;                 }
&lt;                 if ((op == TokenStream.EQ) || (op == TokenStream.SHEQ))
&lt;                     classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
&lt;                                             "FALSE", "Ljava/lang/Boolean;");
&lt;                 else
&lt;                     classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
&lt;                                             "TRUE", "Ljava/lang/Boolean;");
&lt;                 if (isStrict) {
&lt;                     addByteCode(ByteCode.GOTO, 6);
&lt;                 } else {
&lt;                     addByteCode(ByteCode.GOTO, 7);
&lt;                     addByteCode(ByteCode.POP);
&lt;                 }
&lt;                 if ((op == TokenStream.EQ) || (op == TokenStream.SHEQ))
&lt;                     classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
&lt;                                             "TRUE", "Ljava/lang/Boolean;");
&lt;                 else
&lt;                     classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
&lt;                                             "FALSE", "Ljava/lang/Boolean;");
&lt;                 return;
---
&gt;         if (rightChild.getType() == TokenStream.PRIMARY &amp;&amp;
&gt;             rightChild.getOperation() == TokenStream.NULL)
&gt;         {
&gt;             generateCodeFromNode(child, node);
&gt;             if (isStrict) {
&gt;                 addByteCode(ByteCode.IFNULL, 9);
&gt;             } else {
&gt;                 addByteCode(ByteCode.DUP);
&gt;                 addByteCode(ByteCode.IFNULL, 15);
&gt;                 pushUndefined();
&gt;                 addByteCode(ByteCode.IF_ACMPEQ, 10);
2883a2825,2844
&gt;             if ((op == TokenStream.EQ) || (op == TokenStream.SHEQ))
&gt;                 classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
&gt;                                         "FALSE", "Ljava/lang/Boolean;");
&gt;             else
&gt;                 classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
&gt;                                         "TRUE", "Ljava/lang/Boolean;");
&gt;             if (isStrict) {
&gt;                 addByteCode(ByteCode.GOTO, 6);
&gt;             } else {
&gt;                 addByteCode(ByteCode.GOTO, 7);
&gt;                 addByteCode(ByteCode.POP);
&gt;             }
&gt;             if ((op == TokenStream.EQ) || (op == TokenStream.SHEQ))
&gt;                 classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
&gt;                                         "TRUE", "Ljava/lang/Boolean;");
&gt;             else
&gt;                 classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
&gt;                                         "FALSE", "Ljava/lang/Boolean;");
&gt;             return;
&gt;         }
2885,2886c2846,2847
&lt;             generateCodeFromNode(child, node, -1, -1);
&lt;             generateCodeFromNode(child.getNext(), node, -1, -1);
---
&gt;         generateCodeFromNode(child, node);
&gt;         generateCodeFromNode(child.getNext(), node);
2888,2893c2849,2854
&lt;             // JavaScript 1.2 uses shallow equality for == and !=
&lt;             String name;
&lt;             switch (op) {
&lt;               case TokenStream.EQ:
&lt;                 name = version == Context.VERSION_1_2 ? "seqB" : "eqB";
&lt;                 break;
---
&gt;         // JavaScript 1.2 uses shallow equality for == and !=
&gt;         String name;
&gt;         switch (op) {
&gt;           case TokenStream.EQ:
&gt;             name = version == Context.VERSION_1_2 ? "seqB" : "eqB";
&gt;             break;
2895,2897c2856,2858
&lt;               case TokenStream.NE:
&lt;                 name = version == Context.VERSION_1_2 ? "sneB" : "neB";
&lt;                 break;
---
&gt;           case TokenStream.NE:
&gt;             name = version == Context.VERSION_1_2 ? "sneB" : "neB";
&gt;             break;
2899,2901c2860,2862
&lt;               case TokenStream.SHEQ:
&lt;                 name = "seqB";
&lt;                 break;
---
&gt;           case TokenStream.SHEQ:
&gt;             name = "seqB";
&gt;             break;
2903,2905c2864,2866
&lt;               case TokenStream.SHNE:
&lt;                 name = "sneB";
&lt;                 break;
---
&gt;           case TokenStream.SHNE:
&gt;             name = "sneB";
&gt;             break;
2907,2914c2868,2870
&lt;               default:
&lt;                 name = null;
&lt;                 badTree();
&lt;             }
&lt;             addScriptRuntimeInvoke(name,
&lt;                                    "(Ljava/lang/Object;"
&lt;                                    +"Ljava/lang/Object;"
&lt;                                    +")Ljava/lang/Boolean;");
---
&gt;           default:
&gt;             name = null;
&gt;             badTree();
2916,2925c2872,2876
&lt;         else {
&lt;             if (rightChild.getType() == TokenStream.PRIMARY &amp;&amp;
&lt;                 rightChild.getOperation() == TokenStream.NULL)
&lt;             {
&lt;                 if (op != TokenStream.EQ &amp;&amp; op != TokenStream.SHEQ) {
&lt;                     // invert true and false.
&lt;                     int temp = trueGOTO;
&lt;                     trueGOTO = falseGOTO;
&lt;                     falseGOTO = temp;
&lt;                 }
---
&gt;         addScriptRuntimeInvoke(name,
&gt;                                "(Ljava/lang/Object;"
&gt;                                +"Ljava/lang/Object;"
&gt;                                +")Ljava/lang/Boolean;");
&gt;     }
2927,2949c2878,2898
&lt;                 generateCodeFromNode(child, node, -1, -1);
&lt;                 if (isStrict) {
&lt;                     addByteCode(ByteCode.IFNULL, trueGOTO);
&lt;                     addByteCode(ByteCode.GOTO, falseGOTO);
&lt;                     return;
&lt;                 }
&lt;                 /*
&lt;                     since we have to test for null &amp;&amp; undefined we end up
&lt;                     having to push the operand twice and so have to GOTO to
&lt;                     a pop site if the first test passes.
&lt;                     We can avoid that for operands that are 'simple', i.e.
&lt;                     don't generate a lot of code and don't have side-effects.
&lt;                     For now, 'simple' means GETVAR
&lt;                 */
&lt;                 boolean simpleChild = (child.getType() == TokenStream.GETVAR);
&lt;                 if (!simpleChild) addByteCode(ByteCode.DUP);
&lt;                 int popGOTO = acquireLabel();
&lt;                 addByteCode(ByteCode.IFNULL,
&lt;                                 (simpleChild) ? trueGOTO : popGOTO);
&lt;                 short popStack = classFile.getStackTop();
&lt;                 if (simpleChild) generateCodeFromNode(child, node, -1, -1);
&lt;                 pushUndefined();
&lt;                 addByteCode(ByteCode.IF_ACMPEQ, trueGOTO);
---
&gt;     private void visitIfJumpEqOp(Node node, Node child,
&gt;                                  int trueGOTO, int falseGOTO)
&gt;     {
&gt;         int op = node.getOperation();
&gt;         Node rightChild = child.getNext();
&gt;         boolean isStrict = op == TokenStream.SHEQ ||
&gt;                            op == TokenStream.SHNE;
&gt; 
&gt;         if (rightChild.getType() == TokenStream.PRIMARY &amp;&amp;
&gt;             rightChild.getOperation() == TokenStream.NULL)
&gt;         {
&gt;             if (op != TokenStream.EQ &amp;&amp; op != TokenStream.SHEQ) {
&gt;                 // invert true and false.
&gt;                 int temp = trueGOTO;
&gt;                 trueGOTO = falseGOTO;
&gt;                 falseGOTO = temp;
&gt;             }
&gt; 
&gt;             generateCodeFromNode(child, node);
&gt;             if (isStrict) {
&gt;                 addByteCode(ByteCode.IFNULL, trueGOTO);
2951,2955d2899
&lt;                 if (!simpleChild) {
&lt;                     markLabel(popGOTO, popStack);
&lt;                     addByteCode(ByteCode.POP);
&lt;                     addByteCode(ByteCode.GOTO, trueGOTO);
&lt;                 }
2957a2902,2926
&gt;             /*
&gt;                 since we have to test for null &amp;&amp; undefined we end up
&gt;                 having to push the operand twice and so have to GOTO to
&gt;                 a pop site if the first test passes.
&gt;                 We can avoid that for operands that are 'simple', i.e.
&gt;                 don't generate a lot of code and don't have side-effects.
&gt;                 For now, 'simple' means GETVAR
&gt;             */
&gt;             boolean simpleChild = (child.getType() == TokenStream.GETVAR);
&gt;             if (!simpleChild) addByteCode(ByteCode.DUP);
&gt;             int popGOTO = acquireLabel();
&gt;             addByteCode(ByteCode.IFNULL,
&gt;                             (simpleChild) ? trueGOTO : popGOTO);
&gt;             short popStack = classFile.getStackTop();
&gt;             if (simpleChild) generateCodeFromNode(child, node);
&gt;             pushUndefined();
&gt;             addByteCode(ByteCode.IF_ACMPEQ, trueGOTO);
&gt;             addByteCode(ByteCode.GOTO, falseGOTO);
&gt;             if (!simpleChild) {
&gt;                 markLabel(popGOTO, popStack);
&gt;                 addByteCode(ByteCode.POP);
&gt;                 addByteCode(ByteCode.GOTO, trueGOTO);
&gt;             }
&gt;             return;
&gt;         }
2959c2928
&lt;             Node rChild = child.getNext();
---
&gt;         Node rChild = child.getNext();
2961,2983c2930,2951
&lt;             if (nodeIsDirectCallParameter(child)) {
&lt;                 Node convertChild = getConvertToObjectOfNumberNode(rChild);
&lt;                 if (convertChild != null) {
&lt;                     OptLocalVariable lVar1
&lt;                         = (OptLocalVariable)(child.getProp(Node.VARIABLE_PROP));
&lt;                     aload(lVar1.getJRegister());
&lt;                     classFile.add(ByteCode.GETSTATIC,
&lt;                             "java/lang/Void",
&lt;                             "TYPE",
&lt;                             "Ljava/lang/Class;");
&lt;                     int notNumbersLabel = acquireLabel();
&lt;                     addByteCode(ByteCode.IF_ACMPNE, notNumbersLabel);
&lt;                     dload((short)(lVar1.getJRegister() + 1));
&lt;                     push(convertChild.getDouble());
&lt;                     addByteCode(ByteCode.DCMPL);
&lt;                     if (op == TokenStream.EQ)
&lt;                         addByteCode(ByteCode.IFEQ, trueGOTO);
&lt;                     else
&lt;                         addByteCode(ByteCode.IFNE, trueGOTO);
&lt;                     addByteCode(ByteCode.GOTO, falseGOTO);
&lt;                     markLabel(notNumbersLabel);
&lt;                     // fall thru into generic handling
&lt;                 }
---
&gt;         if (nodeIsDirectCallParameter(child)) {
&gt;             Node convertChild = getConvertToObjectOfNumberNode(rChild);
&gt;             if (convertChild != null) {
&gt;                 OptLocalVariable lVar1
&gt;                     = (OptLocalVariable)(child.getProp(Node.VARIABLE_PROP));
&gt;                 aload(lVar1.getJRegister());
&gt;                 classFile.add(ByteCode.GETSTATIC,
&gt;                         "java/lang/Void",
&gt;                         "TYPE",
&gt;                         "Ljava/lang/Class;");
&gt;                 int notNumbersLabel = acquireLabel();
&gt;                 addByteCode(ByteCode.IF_ACMPNE, notNumbersLabel);
&gt;                 dload((short)(lVar1.getJRegister() + 1));
&gt;                 push(convertChild.getDouble());
&gt;                 addByteCode(ByteCode.DCMPL);
&gt;                 if (op == TokenStream.EQ)
&gt;                     addByteCode(ByteCode.IFEQ, trueGOTO);
&gt;                 else
&gt;                     addByteCode(ByteCode.IFNE, trueGOTO);
&gt;                 addByteCode(ByteCode.GOTO, falseGOTO);
&gt;                 markLabel(notNumbersLabel);
&gt;                 // fall thru into generic handling
2984a2953
&gt;         }
2986,2987c2955,2956
&lt;             generateCodeFromNode(child, node, -1, -1);
&lt;             generateCodeFromNode(rChild, node, -1, -1);
---
&gt;         generateCodeFromNode(child, node);
&gt;         generateCodeFromNode(rChild, node);
2989,2997c2958,2966
&lt;             String name;
&lt;             switch (op) {
&lt;               case TokenStream.EQ:
&lt;                 name = version == Context.VERSION_1_2 ? "shallowEq" : "eq";
&lt;                 addScriptRuntimeInvoke(name,
&lt;                                        "(Ljava/lang/Object;"
&lt;                                        +"Ljava/lang/Object;"
&lt;                                        +")Z");
&lt;                 break;
---
&gt;         String name;
&gt;         switch (op) {
&gt;           case TokenStream.EQ:
&gt;             name = version == Context.VERSION_1_2 ? "shallowEq" : "eq";
&gt;             addScriptRuntimeInvoke(name,
&gt;                                    "(Ljava/lang/Object;"
&gt;                                    +"Ljava/lang/Object;"
&gt;                                    +")Z");
&gt;             break;
2999,3005c2968,2974
&lt;               case TokenStream.NE:
&lt;                 name = version == Context.VERSION_1_2 ? "shallowNeq" : "neq";
&lt;                 addOptRuntimeInvoke(name,
&lt;                                     "(Ljava/lang/Object;"
&lt;                                     +"Ljava/lang/Object;"
&lt;                                     +")Z");
&lt;                 break;
---
&gt;           case TokenStream.NE:
&gt;             name = version == Context.VERSION_1_2 ? "shallowNeq" : "neq";
&gt;             addOptRuntimeInvoke(name,
&gt;                                 "(Ljava/lang/Object;"
&gt;                                 +"Ljava/lang/Object;"
&gt;                                 +")Z");
&gt;             break;
3007,3013c2976,2982
&lt;               case TokenStream.SHEQ:
&lt;                 name = "shallowEq";
&lt;                 addScriptRuntimeInvoke(name,
&lt;                                        "(Ljava/lang/Object;"
&lt;                                        +"Ljava/lang/Object;"
&lt;                                        +")Z");
&lt;                 break;
---
&gt;           case TokenStream.SHEQ:
&gt;             name = "shallowEq";
&gt;             addScriptRuntimeInvoke(name,
&gt;                                    "(Ljava/lang/Object;"
&gt;                                    +"Ljava/lang/Object;"
&gt;                                    +")Z");
&gt;             break;
3015,3021c2984,2990
&lt;               case TokenStream.SHNE:
&lt;                 name = "shallowNeq";
&lt;                 addOptRuntimeInvoke(name,
&lt;                                     "(Ljava/lang/Object;"
&lt;                                     +"Ljava/lang/Object;"
&lt;                                     +")Z");
&lt;                 break;
---
&gt;           case TokenStream.SHNE:
&gt;             name = "shallowNeq";
&gt;             addOptRuntimeInvoke(name,
&gt;                                 "(Ljava/lang/Object;"
&gt;                                 +"Ljava/lang/Object;"
&gt;                                 +")Z");
&gt;             break;
3023,3028c2992,2994
&lt;               default:
&lt;                 name = null;
&lt;                 badTree();
&lt;             }
&lt;             addByteCode(ByteCode.IFNE, trueGOTO);
&lt;             addByteCode(ByteCode.GOTO, falseGOTO);
---
&gt;           default:
&gt;             name = null;
&gt;             badTree();
3029a2996,2997
&gt;         addByteCode(ByteCode.IFNE, trueGOTO);
&gt;         addByteCode(ByteCode.GOTO, falseGOTO);
3129c3097
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
3225c3193
&lt;             generateCodeFromNode(child.getNext(), node, -1, -1);
---
&gt;             generateCodeFromNode(child.getNext(), node);
3287c3255
&lt;                 generateCodeFromNode(child, node, -1, -1);
---
&gt;                 generateCodeFromNode(child, node);
3312,3313c3280,3281
&lt;         generateCodeFromNode(child, node, -1, -1);      // the object
&lt;         generateCodeFromNode(nameChild, node, -1, -1);  // the name
---
&gt;         generateCodeFromNode(child, node);      // the object
&gt;         generateCodeFromNode(nameChild, node);  // the name
3356c3324
&lt;                 generateCodeFromNode(child, node, -1, -1);
---
&gt;                 generateCodeFromNode(child, node);
3377c3345
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
3393c3361
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
3425c3393
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
3438c3406
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
3462c3430
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
3473c3441
&lt;             generateCodeFromNode(child, node, -1, -1);
---
&gt;             generateCodeFromNode(child, node);
</file>
</fixedFiles>
</bug>
<bug id="204210" transactionid="68062">
<property name="files-churned" value="8"/>
<property name="java-files-churned" value="7"/>
<property name="classes-churned" value="7"/>
<property name="methods-churned" value="8"/>
<property name="hunks" value="27"/>
<property name="lines-added" value="55"/>
<property name="lines-deleted" value="47"/>
<property name="lines-modified" value="79"/>
<property name="lines-churned" value="181"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-if K-instanceof K-null K-return K-throw K-true M O-== O-- O-! O-!= O-?: O-() O-&amp; O-&amp;&amp; O-+ O-cast O-instanceof T V Y Z-cast Z-cond Z-if Z-throw</fullfingerprint>
<tag>exception</tag>
<bugreport>The following one line script causes ArrayIndexOutOfBoundsException in
interpreted mode:

new eval();

~&gt; java -jar ~/.../js.jar -opt -1 -e 'new eval()'
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException
        at org.mozilla.javascript.Interpreter.interpret(Interpreter.java:2117)
        at org.mozilla.javascript.InterpretedScript.call(InterpretedScript.java:62)
        at org.mozilla.javascript.InterpretedScript.exec(InterpretedScript.java:5
...


For the test case it may be necessary to use code like:

function f()
{
	new eval();
}

f();

since the bug corrupts interpreter stack and it may not be visible if new eval()
is not a single statement in function/script.</bugreport>
<testsforfix id="204210" type="new">
<test file="mozilla/js/tests/js1_5/Regress/regress-204210.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/ScriptRuntime.java" revision="1.126" state="changed">90,91d89
&lt;         NativeGlobalClass = classOrNull("org.mozilla.javascript.NativeGlobal"),
&lt;         NativeWithClass   = classOrNull("org.mozilla.javascript.NativeWith"),
1191,1233d1188
&lt;     private static Object callOrNewSpecial(Context cx, Scriptable scope,
&lt;                                            Object fun, Object jsThis,
&lt;                                            Object thisArg,
&lt;                                            Object[] args, boolean isCall,
&lt;                                            String filename, int lineNumber)
&lt;         throws JavaScriptException
&lt;     {
&lt;         if (fun instanceof IdFunction) {
&lt;             IdFunction f = (IdFunction)fun;
&lt;             String name = f.getFunctionName();
&lt;             if (name.length() == 4) {
&lt;                 if (name.equals("eval")) {
&lt;                     if (f.master.getClass() == NativeGlobalClass) {
&lt;                         return NativeGlobal.evalSpecial(cx, scope,
&lt;                                                         thisArg, args,
&lt;                                                         filename, lineNumber);
&lt;                     }
&lt;                 }
&lt;                 else if (name.equals("With")) {
&lt;                     if (f.master.getClass() == NativeWithClass) {
&lt;                         return NativeWith.newWithSpecial(cx, args, f, !isCall);
&lt;                     }
&lt;                 }
&lt;             }
&lt;         }
&lt; 
&lt;         if (isCall)
&lt;             return call(cx, fun, jsThis, args, scope);
&lt;         return newObject(cx, fun, args, scope);
&lt;     }
&lt; 
&lt;     public static Object callSpecial(Context cx, Object fun,
&lt;                                      Object thisArg, Object[] args,
&lt;                                      Scriptable enclosingThisArg,
&lt;                                      Scriptable scope, String filename,
&lt;                                      int lineNumber)
&lt;         throws JavaScriptException
&lt;     {
&lt;         return callOrNewSpecial(cx, scope, fun, thisArg,
&lt;                                 enclosingThisArg, args, true,
&lt;                                 filename, lineNumber);
&lt;     }
&lt; 
1251,1252c1206,1210
&lt;     public static Scriptable newObjectSpecial(Context cx, Object fun,
&lt;                                               Object[] args, Scriptable scope)
---
&gt;     public static Object callSpecial(Context cx, Object fun,
&gt;                                      boolean isNew, Object thisObj,
&gt;                                      Object[] args, Scriptable scope,
&gt;                                      Scriptable callerThis, int callType,
&gt;                                      String filename, int lineNumber)
1255,1256c1213,1239
&lt;         return (Scriptable) callOrNewSpecial(cx, scope, fun, null, null, args,
&lt;                                              false, null, -1);
---
&gt;         if (callType == Node.SPECIALCALL_EVAL) {
&gt;             if (NativeGlobal.isEvalFunction(fun)) {
&gt;                 if (isNew) {
&gt;                     throw NativeGlobal.typeError1("msg.not.ctor",
&gt;                                                   "eval", scope);
&gt;                 }
&gt;                 return NativeGlobal.evalSpecial(cx, scope,
&gt;                                                 callerThis, args,
&gt;                                                 filename, lineNumber);
&gt;             }
&gt;         } else if (callType == Node.SPECIALCALL_WITH) {
&gt;             if (NativeWith.isWithFunction(fun)) {
&gt;                 if (!isNew) {
&gt;                     throw Context.reportRuntimeError1("msg.only.from.new",
&gt;                                                       "With");
&gt;                 }
&gt;                 return NativeWith.newWithSpecial(cx, scope, args);
&gt;             }
&gt;         } else {
&gt;             Context.codeBug();
&gt;         }
&gt; 
&gt;         if (isNew) {
&gt;             return newObject(cx, fun, args, scope);
&gt;         } else {
&gt;             return call(cx, fun, thisObj, args, scope);
&gt;         }
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/NativeWith.java" revision="1.16" state="changed">168,169c168
&lt;     public static Object newWithSpecial(Context cx, Object[] args,
&lt;                                         Function ctorObj, boolean inNewExpr)
---
&gt;     static boolean isWithFunction(Object functionObj)
171,172c170,176
&lt;         if (!inNewExpr) {
&lt;             throw Context.reportRuntimeError1("msg.only.from.new", "With");
---
&gt;         if (functionObj instanceof IdFunction) {
&gt;             IdFunction function = (IdFunction)functionObj;
&gt;             if (function.master instanceof NativeWith
&gt;                 &amp;&amp; function.getMethodId() == Id_constructor)
&gt;             {
&gt;                 return true;
&gt;             }
173a178,179
&gt;         return false;
&gt;     }
174a181,182
&gt;     static Object newWithSpecial(Context cx, Scriptable scope, Object[] args)
&gt;     {
176,177c184
&lt; 
&lt;         Scriptable scope = ScriptableObject.getTopLevelScope(ctorObj);
---
&gt;         scope = ScriptableObject.getTopLevelScope(scope);
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/optimizer/Codegen.java" revision="1.110" state="changed">1894d1893
&lt;         String simpleCallName = null;
1896c1895
&lt;             simpleCallName = getSimpleCallName(node);
---
&gt;             String simpleCallName = getSimpleCallName(node);
1960c1959
&lt;             className = "org/mozilla/javascript/ScriptRuntime";
---
&gt;             className = "org/mozilla/javascript/optimizer/OptRuntime";
1967c1966,1968
&lt;                                 +")Lorg/mozilla/javascript/Scriptable;";
---
&gt;                                 +"Lorg/mozilla/javascript/Scriptable;"
&gt;                                 +"I" // call type
&gt;                                 +")Ljava/lang/Object;";
1968a1970,1971
&gt;                 aload(thisObjLocal);
&gt;                 push(callType);
1976a1980
&gt;                                 +"I" // call type
1979d1982
&lt;                 aload(thisObjLocal);
1980a1984,1985
&gt;                 aload(thisObjLocal);
&gt;                 push(callType);
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/IdFunction.java" revision="1.24" state="changed">71a72,76
&gt;     public final int getMethodId()
&gt;     {
&gt;         return methodId;
&gt;     }
&gt; 
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/NativeGlobal.java" revision="1.53" state="changed">470a471,483
&gt;     static boolean isEvalFunction(Object functionObj)
&gt;     {
&gt;         if (functionObj instanceof IdFunction) {
&gt;             IdFunction function = (IdFunction)functionObj;
&gt;             if (function.master instanceof NativeGlobal
&gt;                 &amp;&amp; function.getMethodId() == Id_eval)
&gt;             {
&gt;                 return true;
&gt;             }
&gt;         }
&gt;         return false;
&gt;     }
&gt; 
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/Interpreter.java" revision="1.142" state="changed">422a423,425
&gt;                     iCodeTop = addByte(callType, iCodeTop);
&gt;                     iCodeTop = addByte(type == TokenStream.NEW ? 1 : 0,
&gt;                                        iCodeTop);
1265,1270c1268,1276
&lt;                             int line = getShort(iCode, pc);
&lt;                             String name = strings[getIndex(iCode, pc + 2)];
&lt;                             int count = getIndex(iCode, pc + 4);
&lt;                             out.println(tname + " " + count
&lt;                                         + " " + line + " " + name);
&lt;                             pc += 6;
---
&gt;                             int callType = iCode[pc] &amp; 0xFF;
&gt;                             boolean isNew =  (iCode[pc + 1] != 0);
&gt;                             int line = getShort(iCode, pc+2);
&gt;                             String source = strings[getIndex(iCode, pc + 4)];
&gt;                             int count = getIndex(iCode, pc + 6);
&gt;                             out.println(tname + " " + callType  + " " + isNew
&gt;                                         + " " + count
&gt;                                         + " " + line + " " + source);
&gt;                             pc += 8;
1433a1440,1441
&gt;                 // call type
&gt;                 // is new
1437c1445
&lt;                 return 1 + 2 + 2 + 2;
---
&gt;                 return 1 + 1 + 1 + 2 + 2 + 2;
2109,2111c2117,2121
&lt;         int lineNum = getShort(iCode, pc + 1);
&lt;         String name = strings[getIndex(iCode, pc + 3)];
&lt;         int count = getIndex(iCode, pc + 5);
---
&gt;         int callType = iCode[pc + 1] &amp; 0xFF;
&gt;         boolean isNew =  (iCode[pc + 2] != 0);
&gt;         int sourceLine = getShort(iCode, pc + 3);
&gt;         String sourceName = strings[getIndex(iCode, pc + 5)];
&gt;         int count = getIndex(iCode, pc + 7);
2114,2118c2124,2135
&lt;         Object rhs = stack[stackTop];
&lt;         if (rhs == DBL_MRK) rhs = doubleWrap(sDbl[stackTop]);
&lt;         --stackTop;
&lt;         Object lhs = stack[stackTop];
&lt;         if (lhs == DBL_MRK) lhs = doubleWrap(sDbl[stackTop]);
---
&gt;         Object functionThis;
&gt;         if (isNew) {
&gt;             functionThis = null;
&gt;         } else {
&gt;             functionThis = stack[stackTop];
&gt;             if (functionThis == DBL_MRK) {
&gt;                 functionThis = doubleWrap(sDbl[stackTop]);
&gt;             }
&gt;             --stackTop;
&gt;         }
&gt;         Object function = stack[stackTop];
&gt;         if (function == DBL_MRK) function = doubleWrap(sDbl[stackTop]);
2120,2122c2137,2140
&lt;                             cx, lhs, rhs, outArgs,
&lt;                             thisObj, scope, name, lineNum);
&lt;         pc += 6;
---
&gt;                               cx, function, isNew, functionThis, outArgs,
&gt;                               scope, thisObj, callType,
&gt;                               sourceName, sourceLine);
&gt;         pc += 8;
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/optimizer/OptRuntime.java" revision="1.17" state="changed">308a309,331
&gt; 
&gt;     public static Object callSpecial(Context cx, Object fun,
&gt;                                      Object thisObj, Object[] args,
&gt;                                      Scriptable scope,
&gt;                                      Scriptable callerThis, int callType,
&gt;                                      String fileName, int lineNumber)
&gt;         throws JavaScriptException
&gt;     {
&gt;         return ScriptRuntime.callSpecial(cx, fun, false, thisObj, args, scope,
&gt;                                          callerThis, callType,
&gt;                                          fileName, lineNumber);
&gt;     }
&gt; 
&gt;     public static Object newObjectSpecial(Context cx, Object fun,
&gt;                                           Object[] args, Scriptable scope,
&gt;                                           Scriptable callerThis, int callType)
&gt;         throws JavaScriptException
&gt;     {
&gt;         return ScriptRuntime.callSpecial(cx, fun, true, null, args, scope,
&gt;                                          callerThis, callType,
&gt;                                          "", -1);
&gt;     }
&gt; 
</file>
</fixedFiles>
</bug>
<bug id="210682" transactionid="67060">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="8"/>
<property name="lines-churned" value="8"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-else K-this O-== O-|| O-!= O-() O-&amp; V Y Z-if</fullfingerprint>
<bugreport>User-Agent:       Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.4) Gecko/20030529
Build Identifier: Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.4) Gecko/20030529

if you have the following code snippet:

for (i = 0; i &lt; 100; i++) {
   if (i % 2 == 0) continue
   this.lasti = i;
}

you get the following error: "SyntaxError: missing ; before statement"


Reproducible: Always

Steps to Reproduce:
1.
2.
3.



Expected Results:  
It above code example is valid JS syntax.  The problem lies in TokenStream. 
When the continue keyword is processed, Rhino checks for the optional label. 
Since there isn't one, it pushes back the EOL token.  However,
TokenStream.peekTokenSameLine changes the token from EOL to EOF when it pushes
back the token (member variable pushbackToken).  Finally, when Rhino calls
checkWellTerminated, the TokenStream sees the EOF, continues processing the
stream and 'forgets' it saw an EOL.

I fixed this by not converting the EOL to EOF in
TokenStream.peekTokenSameLine().  TokenStream.getToken() then checks if the
pushbackToken was EOL, and if so, validates for the TSF_NEWLINES flag.  If that
is set, it returns the EOL, otherwise it drops through and continues processing
the stream.</bugreport>
<testsforfix id="210682" type="new">
<test file="mozilla/js/tests/js1_5/Regress/regress-210682.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/TokenStream.java" revision="1.40" state="changed">722,726c722
&lt;         if (result == EOL) {
&lt;             this.pushbackToken = EOF;
&lt;         } else {
&lt;             this.pushbackToken = result;
&lt;         }
---
&gt;         this.pushbackToken = result;
740c736,738
&lt;             return result;
---
&gt;             if (result != EOL || (flags &amp; TSF_NEWLINES) != 0) {
&gt;                 return result;
&gt;             }
</file>
</fixedFiles>
</bug>
<bug id="220362" transactionid="67806">
<property name="files-churned" value="6"/>
<property name="java-files-churned" value="5"/>
<property name="classes-churned" value="5"/>
<property name="methods-churned" value="7"/>
<property name="hunks" value="17"/>
<property name="lines-added" value="32"/>
<property name="lines-deleted" value="19"/>
<property name="lines-modified" value="25"/>
<property name="lines-churned" value="76"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-finally K-if K-instanceof K-return K-true K-try M O-== O-&gt; O-|| O--- O-() O-++ O-instanceof T V Y Z-if</fullfingerprint>
<bugreport>User-Agent:       Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.4) Gecko/20030624
Build Identifier: 

When a local function is compiled with both dynamic scope and opt-level &gt;= 0, it
only keeps its local scope as long as execution stays within that local scope.
Once execution leaves the local scope, the function loses it.

As soon as either compileFunctionsWithDynamicScope is set to false or the
optimization level is set to -1 on the Context, the function keeps the scope in
which it was defined.

The following script reproduces the problem (I'm also adding it as attachment)

// creates a local function and calls it immediately
function a() {
  var x = "A";
  var f = function() {
    java.lang.System.err.println(x);
  }
  f();
}

// creates and returns a local function
function b() {
  var x = "B";
  var f = function() {
    java.lang.System.err.println(x);
  }
  return f;
}


a(); // works
var f = b();
f(); // doesn't work

Reproducible: Always

Steps to Reproduce:
1.Run the attached script with optLevel &gt;= 0 and
compileFunctionsWithDynamicScope = true.

Actual Results:  
A
js: "/home/hannes/cvs/adele/apps/antville/global/Aspects.js", line 14: uncaught
JavaScript exception: ReferenceError: "x" is not defined.
(/home/hannes/cvs/adele/apps/antville/global/Aspects.js; line 14)

Expected Results:  
A
B</bugreport>
<testsforfix id="220362" type="new">
<test file="mozilla/js/tests/js1_5/Scope/regress-220362.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/Parser.java" revision="1.65" state="changed">236a237,238
&gt;         boolean nested = (currentScriptOrFn.type == Token.FUNCTION);
&gt; 
237a240,253
&gt;         if (nested) {
&gt;             // Nested functions must check their 'this' value to insure
&gt;             // it is not an activation object: see 10.1.6 Activation Object
&gt;             fnNode.setCheckThis();
&gt;         }
&gt;         if (nested || nestingOfWith &gt; 0) {
&gt;             // 1. Nested functions are not affected by the dynamic scope flag
&gt;             // as dynamic scope is already a parent of their scope.
&gt;             // 2. Functions defined under the with statement also immune to
&gt;             // this setup, in which case dynamic scope is ignored in favor
&gt;             // of with object.
&gt;             fnNode.setIgnoreDynamicScope();
&gt;         }
&gt; 
244a261,262
&gt;         int savedNestingOfWith = nestingOfWith;
&gt;         nestingOfWith = 0;
296a315
&gt;             nestingOfWith = savedNestingOfWith;
727c746,752
&lt;             Object body = statement(ts);
---
&gt;             ++nestingOfWith;
&gt;             Object body;
&gt;             try {
&gt;                 body = statement(ts);
&gt;             } finally {
&gt;                 --nestingOfWith;
&gt;             }
1461a1487,1488
&gt;     private int nestingOfWith;
&gt; 
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/InterpreterData.java" revision="1.40" state="changed">96a97,98
&gt;     boolean useDynamicScope;
&gt; 
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/Interpreter.java" revision="1.184" state="changed">165a166,170
&gt;         if (!theFunction.getIgnoreDynamicScope()) {
&gt;             if (cx.hasCompileFunctionsWithDynamicScope()) {
&gt;                 itsData.useDynamicScope = true;
&gt;             }
&gt;         }
304c309
&lt;                 if (fn.itsFunctionType != FunctionNode.FUNCTION_STATEMENT) {
---
&gt;                 if (fn.getFunctionType() != FunctionNode.FUNCTION_STATEMENT) {
1619,1630d1623
&lt;         if (cx.hasCompileFunctionsWithDynamicScope()) {
&lt;              // Nested functions are not affected by the dynamic scope flag
&lt;              // as dynamic scope is already a parent of their scope
&lt;              // Functions defined under the with statement also immune to
&lt;              // this setup, in which case dynamic scope is ignored in favor
&lt;              // of with object.
&lt;              if (!(scope instanceof NativeCall
&lt;                    || scope instanceof NativeWith))
&lt;              {
&lt;                  fn.itsUseDynamicScope = true;
&lt;              }
&lt;         }
1694c1687
&lt;             if (!f.itsUseDynamicScope) {
---
&gt;             if (!idata.useDynamicScope) {
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/optimizer/Codegen.java" revision="1.149" state="changed">1170,1171c1170,1172
&lt;         if (fnCurrent != null &amp;&amp; !codegen.itsUseDynamicScope
&lt;             &amp;&amp; directParameterCount == -1)
---
&gt;         if (fnCurrent != null &amp;&amp; directParameterCount == -1
&gt;             &amp;&amp; (!codegen.itsUseDynamicScope
&gt;                 || fnCurrent.getIgnoreDynamicScope()))
1173,1175c1174,1175
&lt;             // Unless we're either using dynamic scope or we're in a
&lt;             // direct call, use the enclosing scope of the function as our
&lt;             // variable object.
---
&gt;             // Unless we're either in a direct call or using dynamic scope,
&gt;             // use the enclosing scope of the function as our variable object.
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/FunctionNode.java" revision="1.24" state="changed">64,65c64,73
&lt;     public void setCheckThis(boolean b) {
&lt;         itsCheckThis = b;
---
&gt;     public void setCheckThis() {
&gt;         itsCheckThis = true;
&gt;     }
&gt; 
&gt;     public boolean getIgnoreDynamicScope() {
&gt;         return itsIgnoreDynamicScope;
&gt;     }
&gt; 
&gt;     public void setIgnoreDynamicScope() {
&gt;         itsIgnoreDynamicScope = true;
102,105d109
&lt;                 // Nested functions must check their 'this' value to insure
&lt;                 // it is not an activation object: see 10.1.6 Activation Object
&lt;                 fn.setCheckThis(true);
&lt; 
144,146d147
&lt;     protected boolean itsNeedsActivation;
&lt;     protected boolean itsCheckThis;
&lt;     protected int itsFunctionType;
147a149,152
&gt;     private boolean itsNeedsActivation;
&gt;     private boolean itsCheckThis;
&gt;     private int itsFunctionType;
&gt;     private boolean itsIgnoreDynamicScope;
</file>
</fixedFiles>
</bug>
<bug id="220584" transactionid="67487">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="4"/>
<property name="lines-churned" value="4"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M T V Y</fullfingerprint>
<bugreport>When Script object is called as a function, its result does not have properly
initialized prototype and scope chains so various Script.prototype methods
including toString does not work.

For example, calling 
var s = Script("1;");
print(s.__proto__ != null)
print(s.__parent__ != null)
print(s)

gives 
false
false
js: "&lt;command&gt;", line 3: uncaught JavaScript exception:
java.lang.RuntimeException: org.mozilla.javascript.PropertyException:
Constructor for "TypeError" not found.

instead of expected: 
true
true

1;

This is a semi-regression in rhino CVS compared with Rhino 1.5 Release 4.1 since
there the bug is only present in the interpreter.

Note that calling Script as a constructor works without any problems.</bugreport>
<testsforfix id="220584" type="new">
<test file="mozilla/js/tests/js1_5/Scope/regress-220584.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/NativeScript.java" revision="1.25" state="changed">195c195,198
&lt;         return new NativeScript(script);
---
&gt;         NativeScript nscript = new NativeScript(script);
&gt;         nscript.setParentScope(scope);
&gt;         nscript.setPrototype(getClassPrototype(scope, "Script"));
&gt;         return nscript;
</file>
</fixedFiles>
</bug>
<bug id="225831" transactionid="67930">
<property name="files-churned" value="16"/>
<property name="java-files-churned" value="15"/>
<property name="classes-churned" value="15"/>
<property name="methods-churned" value="19"/>
<property name="hunks" value="342"/>
<property name="lines-added" value="405"/>
<property name="lines-deleted" value="530"/>
<property name="lines-modified" value="1158"/>
<property name="lines-churned" value="2093"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-break K-case K-catch K-class K-continue K-default K-else K-false K-for K-if K-new K-null K-package K-return K-super K-switch K-this K-throw K-true K-try K-while M O-~ O-&lt; O-&lt;= O-== O-&gt; O-|| O-- O--- O-! O-!= O-?: O-() O-* O-&amp; O-&amp;&amp; O-+ O-++ O-cast T V Y Z-cast Z-cond Z-do Z-for Z-if Z-switch Z-throw Z-vardecl Z-while</fullfingerprint>
<bugreport>Currently to implement operations such as x += y, ++x and object and array
literals, {}, [], parser in Rhino generates nodes to hold temporary values.
Interpreter in Rhino does not support more then 256 temporaries and silently
recycles them if their number exceeds 256. The following test case demonstrates
this interpreter limitation.

In principle by changing space taken by temporary index that can be resolved but
it seems that eliminating such temporary nodes and using various forms of dup
operations on stack would make generated byte code smaller and faster both for
interpreter and optimizer.</bugreport>
<testsforfix id="225831" type="new">
<test file="mozilla/js/tests/js1_5/Regress/regress-225831.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/Parser.java" revision="1.69" state="changed">947c947
&lt;             return nf.createTernary(pn, ifTrue, ifFalse);
---
&gt;             return nf.createCondExpr(pn, ifTrue, ifFalse);
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/NodeTransformer.java" revision="1.55" state="changed">22a23
&gt;  * Igor Bukanov
49,50c50,51
&lt;     public NodeTransformer(IRFactory irFactory) {
&lt;         this.irFactory = irFactory;
---
&gt;     public NodeTransformer(TokenStream ts) {
&gt;         this.ts = ts;
53,58c54,60
&lt;     /**
&lt;      * Return new instance of this class. So that derived classes
&lt;      * can override methods of the transformer.
&lt;      */
&lt;     protected NodeTransformer newInstance() {
&lt;         return new NodeTransformer(irFactory);
---
&gt;     public final void transform(ScriptOrFnNode tree)
&gt;     {
&gt;         transformCompilationUnit(tree);
&gt;         for (int i = 0; i != tree.getFunctionCount(); ++i) {
&gt;             FunctionNode fn = tree.getFunctionNode(i);
&gt;             transform(fn);
&gt;         }
61c63
&lt;     public void transform(ScriptOrFnNode tree)
---
&gt;     private void transformCompilationUnit(ScriptOrFnNode tree)
65,66c67
&lt;         inFunction = tree.getType() == Token.FUNCTION;
&lt; 
---
&gt;         inFunction = (tree.getType() == Token.FUNCTION);
68c69,88
&lt;         boolean hasFinally = false;
---
&gt;         hasFinally = false;
&gt;         transformCompilationUnit_r(tree, tree);
&gt;     }
&gt; 
&gt;     private void transformCompilationUnit_r(final ScriptOrFnNode tree,
&gt;                                             final Node parent)
&gt;     {
&gt;         Node node = null;
&gt;       siblingLoop:
&gt;         for (;;) {
&gt;             Node previous = null;
&gt;             if (node == null) {
&gt;                 node = parent.getFirstChild();
&gt;             } else {
&gt;                 previous = node;
&gt;                 node = node.getNext();
&gt;             }
&gt;             if (node == null) {
&gt;                 break;
&gt;             }
70,72d89
&lt;         PreorderNodeIterator iter = new PreorderNodeIterator();
&lt;         for (iter.start(tree); !iter.done(); iter.next()) {
&lt;             Node node = iter.getCurrent();
78,86d94
&lt;               case Token.FUNCTION:
&lt;                 if (node != tree) {
&lt;                     int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);
&lt;                     FunctionNode fnNode = tree.getFunctionNode(fnIndex);
&lt;                     NodeTransformer inner = newInstance();
&lt;                     inner.transform(fnNode);
&lt;                 }
&lt;                 break;
&lt; 
111d118
&lt;                 Node parent = iter.getCurrentParent();
122a130,135
&gt;                 } else if (next.getType() == Token.LOCAL_BLOCK) {
&gt;                     // check for "for (in)" loop that is wrapped in local_block
&gt;                     Node child = next.getFirstChild();
&gt;                     if (child != null &amp;&amp; child.getType() == Token.LOOP) {
&gt;                         labelNode.setContinue(((Node.Jump)child).getContinue());
&gt;                     }
134d146
&lt;                 Node parent = iter.getCurrentParent();
168,171d179
&lt;               case Token.NEWLOCAL :
&lt;                   tree.incrementLocalCount();
&lt;                 break;
&lt; 
186c194
&lt;                     throw new RuntimeException("Unexpected tree");
---
&gt;                     Kit.codeBug();
201d208
&lt;                 tree.incrementLocalCount();
224c231,232
&lt; 
---
&gt;                 Node child = node.getFirstChild();
&gt;                 boolean inserted = false;
228,235c236,260
&lt;                     if (elemtype == Token.TRY) {
&lt;                         Node.Jump jsrnode = new Node.Jump(Token.JSR);
&lt;                         Node.Target jsrtarget = ((Node.Jump)n).getFinally();
&lt;                         jsrnode.target = jsrtarget;
&lt;                         iter.addBeforeCurrent(jsrnode);
&lt;                     } else if (elemtype == Token.WITH) {
&lt;                         Node leave = new Node(Token.LEAVEWITH);
&lt;                         iter.addBeforeCurrent(leave);
---
&gt;                     if (elemtype == Token.TRY || elemtype == Token.WITH) {
&gt;                         if (!inserted) {
&gt;                             inserted = true;
&gt;                             if (child != null) {
&gt;                                 node.setType(Token.POPV);
&gt;                                 // process children now as node will be
&gt;                                 // changed to point to inserted RETURN_POPV
&gt;                                 transformCompilationUnit_r(tree, node);
&gt;                                 Node retPopv = new Node(Token.RETURN_POPV);
&gt;                                 parent.addChildAfter(retPopv, node);
&gt;                                 previous = node;
&gt;                                 node = retPopv;
&gt;                             }
&gt;                         }
&gt;                         Node unwind;
&gt;                         if (elemtype == Token.TRY) {
&gt;                             Node.Jump jsrnode = new Node.Jump(Token.JSR);
&gt;                             Node.Target jsrtarget = ((Node.Jump)n).getFinally();
&gt;                             jsrnode.target = jsrtarget;
&gt;                             unwind = jsrnode;
&gt;                         } else {
&gt;                             unwind = new Node(Token.LEAVEWITH);
&gt;                         }
&gt;                         previous = addBeforeCurrent(parent, previous, node,
&gt;                                                     unwind);
254c279,280
&lt;                         iter.addBeforeCurrent(leave);
---
&gt;                         previous = addBeforeCurrent(parent, previous, node,
&gt;                                                     leave);
259c285,286
&lt;                         iter.addBeforeCurrent(jsrFinally);
---
&gt;                         previous = addBeforeCurrent(parent, previous, node,
&gt;                                                     jsrFinally);
349a377
&gt;                     if (n.getType() != Token.NAME) Kit.codeBug();
355,356c383,385
&lt;                     Node asn = (Node)irFactory.createAssignment(n, init);
&lt;                     Node pop = new Node(Token.POP, asn, node.getLineno());
---
&gt;                     n.setType(Token.BINDNAME);
&gt;                     n = new Node(Token.SETNAME, n, init);
&gt;                     Node pop = new Node(Token.POP, n, node.getLineno());
359c388
&lt;                 iter.replaceCurrent(result);
---
&gt;                 node = replaceCurrent(parent, previous, node, result);
384c413
&lt;                         iter.replaceCurrent(n);
---
&gt;                         node = replaceCurrent(parent, previous, node, n);
421a451,452
&gt; 
&gt;             transformCompilationUnit_r(tree, node);
429,506d459
&lt;         /*
&lt;          * For
&lt;          *      Call(GetProp(a, b), c, d)   // or GetElem...
&lt;          * we wish to evaluate as
&lt;          *      Call(GetProp(tmp=a, b), tmp, c, d)
&lt;          *
&lt;          * for
&lt;          *      Call(Name("a"), b, c)
&lt;          * we wish to evaluate as
&lt;          *      Call(GetProp(tmp=GetBase("a"), "a"), tmp, b, c)
&lt;          *
&lt;          * and for
&lt;          *      Call(a, b, c);
&lt;          * we wish to evaluate as
&lt;          *      Call(tmp=a, Parent(tmp), c, d)
&lt;          */
&lt;         Node left = node.getFirstChild();
&lt;         // count the arguments
&lt;         int argCount = 0;
&lt;         Node arg = left.getNext();
&lt;         while (arg != null) {
&lt;             arg = arg.getNext();
&lt;             argCount++;
&lt;         }
&lt;         boolean addGetThis = false;
&lt;         if (left.getType() == Token.NAME) {
&lt;             String name = left.getString();
&lt;             if (inFunction &amp;&amp; tree.hasParamOrVar(name)
&lt;                 &amp;&amp; !inWithStatement())
&lt;             {
&lt;                 // call to a var. Transform to Call(GetVar("a"), b, c)
&lt;                 left.setType(Token.GETVAR);
&lt;                 // fall through to code to add GetParent
&lt;             } else {
&lt;                 // transform to Call(GetProp(GetBase("a"), "a"), b, c)
&lt; 
&lt;                 node.removeChild(left);
&lt;                 left.setType(Token.GETBASE);
&lt;                 Node str = left.cloneNode();
&lt;                 str.setType(Token.STRING);
&lt;                 Node getProp = new Node(Token.GETPROP, left, str);
&lt;                 node.addChildToFront(getProp);
&lt;                 left = getProp;
&lt; 
&lt;                 // Conditionally set a flag to add a GETTHIS node.
&lt;                 // The getThis entry in the runtime will take a
&lt;                 // Scriptable object intended to be used as a 'this'
&lt;                 // and make sure that it is neither a With object or
&lt;                 // an activation object.
&lt;                 // Executing getThis requires at least two instanceof
&lt;                 // tests, so we only include it if we are currently
&lt;                 // inside a 'with' statement, or if we are executing
&lt;                 // a script (to protect against an eval inside a with).
&lt;                 addGetThis = inWithStatement() || !inFunction;
&lt;                 // fall through to GETPROP code
&lt;             }
&lt;         }
&lt;         if (left.getType() != Token.GETPROP &amp;&amp;
&lt;             left.getType() != Token.GETELEM)
&lt;         {
&lt;             node.removeChild(left);
&lt;             Node tmp = irFactory.createNewTemp(left);
&lt;             Node use = irFactory.createUseTemp(tmp);
&lt;             use.putProp(Node.TEMP_PROP, tmp);
&lt;             Node parent = new Node(Token.PARENT, use);
&lt;             node.addChildToFront(parent);
&lt;             node.addChildToFront(tmp);
&lt;             return;
&lt;         }
&lt;         Node leftLeft = left.getFirstChild();
&lt;         left.removeChild(leftLeft);
&lt;         Node tmp = irFactory.createNewTemp(leftLeft);
&lt;         left.addChildToFront(tmp);
&lt;         Node use = irFactory.createUseTemp(tmp);
&lt;         use.putProp(Node.TEMP_PROP, tmp);
&lt;         if (addGetThis)
&lt;             use = new Node(Token.GETTHIS, use);
&lt;         node.addChildAfter(use, left);
522c475,476
&lt;     private int getSpecialCallType(Node tree, Node node) {
---
&gt;     private static int getSpecialCallType(Node tree, Node node)
&gt;     {
542c496
&lt;             if (inFunction)
---
&gt;             if (tree.getType() == Token.FUNCTION)
547a502,530
&gt;     private static Node addBeforeCurrent(Node parent, Node previous,
&gt;                                          Node current, Node toAdd)
&gt;     {
&gt;         if (previous == null) {
&gt;             if (!(current == parent.getFirstChild())) Kit.codeBug();
&gt;             parent.addChildToFront(toAdd);
&gt;         } else {
&gt;             if (!(current == previous.getNext())) Kit.codeBug();
&gt;             parent.addChildAfter(toAdd, previous);
&gt;         }
&gt;         return toAdd;
&gt;     }
&gt; 
&gt;     private static Node replaceCurrent(Node parent, Node previous,
&gt;                                        Node current, Node replacement)
&gt;     {
&gt;         if (previous == null) {
&gt;             if (!(current == parent.getFirstChild())) Kit.codeBug();
&gt;             parent.replaceChild(current, replacement);
&gt;         } else if (previous.next == current) {
&gt;             // Check cachedPrev.next == current is necessary due to possible
&gt;             // tree mutations
&gt;             parent.replaceChildAfter(previous, replacement);
&gt;         } else {
&gt;             parent.replaceChild(current, replacement);
&gt;         }
&gt;         return replacement;
&gt;     }
&gt; 
554c537
&lt;         irFactory.ts.reportSyntaxError(true, messageId, messageArgs,
---
&gt;         ts.reportSyntaxError(true, messageId, messageArgs,
561c544,546
&lt;     protected IRFactory irFactory;
---
&gt;     private boolean hasFinally;
&gt; 
&gt;     private TokenStream ts;
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/ScriptRuntime.java" revision="1.147" state="changed">1334,1337c1334,1366
&lt;     public static Object initEnum(Object value, Scriptable scope) {
&lt;         if (value == null || value == Undefined.instance) {
&lt;             // Empty enumeration
&lt;             return new IdEnumeration(null);
---
&gt; 
&gt;     /**
&gt;      * This is the enumeration needed by the for..in statement.
&gt;      *
&gt;      * See ECMA 12.6.3.
&gt;      *
&gt;      * IdEnumeration maintains a ObjToIntMap to make sure a given
&gt;      * id is enumerated only once across multiple objects in a
&gt;      * prototype chain.
&gt;      *
&gt;      * XXX - ECMA delete doesn't hide properties in the prototype,
&gt;      * but js/ref does. This means that the js/ref for..in can
&gt;      * avoid maintaining a hash table and instead perform lookups
&gt;      * to see if a given property has already been enumerated.
&gt;      *
&gt;      */
&gt;     private static class IdEnumeration
&gt;     {
&gt;         Scriptable obj;
&gt;         Object[] ids;
&gt;         int index;
&gt;         ObjToIntMap used;
&gt;         String currentId;
&gt;     }
&gt; 
&gt;     public static Object enumInit(Object value, Scriptable scope)
&gt;     {
&gt;         IdEnumeration x = new IdEnumeration();
&gt;         if (!(value == null || value == Undefined.instance)) {
&gt;             x.obj = toObject(scope, value);
&gt;             // enumInit should read all initial ids before returning
&gt;             // or "for (a.i in a)" would wrongly enumerate i in a as well
&gt;             enumChangeObject(x);
1339,1340c1368
&lt;         Scriptable m = toObject(scope, value);
&lt;         return new IdEnumeration(m);
---
&gt;         return x;
1343c1371,1372
&lt;     public static Object nextEnum(Object enumObj) {
---
&gt;     public static Boolean enumNext(Object enumObj)
&gt;     {
1345,1346c1374,1430
&lt;         IdEnumeration enum = (IdEnumeration)enumObj;
&lt;         return enum.nextId();
---
&gt;         IdEnumeration x = (IdEnumeration)enumObj;
&gt;         for (;;) {
&gt;             if (x.obj == null) {
&gt;                 return Boolean.FALSE;
&gt;             }
&gt;             if (x.index == x.ids.length) {
&gt;                 x.obj = x.obj.getPrototype();
&gt;                 enumChangeObject(x);
&gt;                 continue;
&gt;             }
&gt;             Object id = x.ids[x.index++];
&gt;             if (x.used != null &amp;&amp; x.used.has(id)) {
&gt;                 continue;
&gt;             }
&gt;             if (id instanceof String) {
&gt;                 String strId = (String)id;
&gt;                 if (!x.obj.has(strId, x.obj))
&gt;                     continue;   // must have been deleted
&gt;                 x.currentId = strId;
&gt;             } else {
&gt;                 int intId = ((Number)id).intValue();
&gt;                 if (!x.obj.has(intId, x.obj))
&gt;                     continue;   // must have been deleted
&gt;                 x.currentId = String.valueOf(intId);
&gt;             }
&gt;             break;
&gt;         }
&gt;         return Boolean.TRUE;
&gt;     }
&gt; 
&gt;     public static String enumId(Object enumObj)
&gt;     {
&gt;         return ((IdEnumeration)enumObj).currentId;
&gt;     }
&gt; 
&gt;     private static void enumChangeObject(IdEnumeration x)
&gt;     {
&gt;         Object[] ids = null;
&gt;         while (x.obj != null) {
&gt;             ids = x.obj.getIds();
&gt;             if (ids.length != 0) {
&gt;                 break;
&gt;             }
&gt;             x.obj = x.obj.getPrototype();
&gt;         }
&gt;         if (x.obj != null &amp;&amp; x.ids != null) {
&gt;             Object[] previous = x.ids;
&gt;             int L = previous.length;
&gt;             if (x.used == null) {
&gt;                 x.used = new ObjToIntMap(L);
&gt;             }
&gt;             for (int i = 0; i != L; ++i) {
&gt;                 x.used.intern(previous[i]);
&gt;             }
&gt;         }
&gt;         x.ids = ids;
&gt;         x.index = 0;
2085,2086c2169,2174
&lt;     public static Scriptable newScope() {
&lt;         return new NativeObject();
---
&gt;     public static Scriptable newCatchScope(String exceptionName,
&gt;                                            Object exceptionObject)
&gt;     {
&gt;         Scriptable scope = new NativeObject();
&gt;         ScriptableObject.putProperty(scope, exceptionName, exceptionObject);
&gt;         return scope;
2285,2361d2372
&lt; 
&lt; /**
&lt;  * This is the enumeration needed by the for..in statement.
&lt;  *
&lt;  * See ECMA 12.6.3.
&lt;  *
&lt;  * IdEnumeration maintains a ObjToIntMap to make sure a given
&lt;  * id is enumerated only once across multiple objects in a
&lt;  * prototype chain.
&lt;  *
&lt;  * XXX - ECMA delete doesn't hide properties in the prototype,
&lt;  * but js/ref does. This means that the js/ref for..in can
&lt;  * avoid maintaining a hash table and instead perform lookups
&lt;  * to see if a given property has already been enumerated.
&lt;  *
&lt;  */
&lt; class IdEnumeration
&lt; {
&lt;     IdEnumeration(Scriptable m)
&lt;     {
&lt;         changeObject(m);
&lt;     }
&lt; 
&lt;     Object nextId()
&lt;     {
&lt;         if (obj == null)
&lt;             return null;
&lt;         Object result;
&lt;         for (;;) {
&lt;             if (index == array.length) {
&lt;                 changeObject(obj.getPrototype());
&lt;                 if (obj == null)
&lt;                     return null;
&lt;             }
&lt;             result = array[index++];
&lt;             if (result instanceof String) {
&lt;                 if (!obj.has((String) result, obj))
&lt;                     continue;   // must have been deleted
&lt;             } else {
&lt;                 if (!obj.has(((Number) result).intValue(), obj))
&lt;                     continue;   // must have been deleted
&lt;             }
&lt;             if (used == null || !used.has(result)) {
&lt;                 break;
&lt;             }
&lt;         }
&lt;         return ScriptRuntime.toString(result);
&lt;     }
&lt; 
&lt;     private void changeObject(Scriptable m)
&lt;     {
&lt;         Object[] ids = null;
&lt;         while (m != null) {
&lt;             ids = m.getIds();
&lt;             if (ids.length != 0) {
&lt;                 break;
&lt;             }
&lt;             m = m.getPrototype();
&lt;         }
&lt;         if (m != null &amp;&amp; array != null) {
&lt;             if (used == null) {
&lt;                 used = new ObjToIntMap(array.length + 5);
&lt;             }
&lt;             for (int i = 0; i != array.length; ++i) {
&lt;                 used.intern(array[i]);
&lt;             }
&lt;         }
&lt;         obj = m;
&lt;         array = ids;
&lt;         index = 0;
&lt;     }
&lt; 
&lt;     private Scriptable obj;
&lt;     private int index;
&lt;     private Object[] array;
&lt;     private ObjToIntMap used;
&lt; }
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/Node.java" revision="1.41" state="changed">47,48c47,48
&lt; public class Node implements Cloneable {
&lt; 
---
&gt; public class Node
&gt; {
366,369c366,369
&lt;         ENUM_PROP         =  1,
&lt;         FUNCTION_PROP     =  2,
&lt;         TEMP_PROP         =  3,
&lt;         LOCAL_PROP        =  4,
---
&gt;         FUNCTION_PROP     =  1,
&gt;         TEMP_PROP         =  2,
&gt;         LOCAL_PROP        =  3,
&gt;         LOCAL_BLOCK_PROP  =  4,
396d395
&lt; 
418d416
&lt;                 case ENUM_PROP:          return "enum";
421a420
&gt;                 case LOCAL_BLOCK_PROP:   return "local_block";
544,557d542
&lt;     public Node cloneNode() {
&lt;         Node result;
&lt;         try {
&lt;             result = (Node) super.clone();
&lt;             result.next = null;
&lt;             result.first = null;
&lt;             result.last = null;
&lt;         }
&lt;         catch (CloneNotSupportedException e) {
&lt;             throw new RuntimeException(e.getMessage());
&lt;         }
&lt;         return result;
&lt;     }
&lt; 
650a636,638
&gt;                   case LOCAL_BLOCK_PROP :     // can't add this as it is dull
&gt;                     value = "last local block";
&gt;                     break;
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/optimizer/Codegen.java" revision="1.158" state="changed">73c73
&lt;     public FunctionNode createFunctionNode(IRFactory irFactory, String name)
---
&gt;     public FunctionNode createFunctionNode(String name)
78c78
&lt;     public ScriptOrFnNode transform(Context cx, IRFactory irFactory,
---
&gt;     public ScriptOrFnNode transform(Context cx, TokenStream ts,
113c113
&lt;         OptTransformer ot = new OptTransformer(irFactory, possibleDirectCalls,
---
&gt;         OptTransformer ot = new OptTransformer(ts, possibleDirectCalls,
118c118
&lt;             (new Optimizer(irFactory)).optimize(tree, optLevel);
---
&gt;             (new Optimizer()).optimize(tree, optLevel);
1128c1128
&lt;         scriptResultLocal = -1;
---
&gt;         popvLocal = -1;
1196,1205d1195
&lt;         // These locals are to be pre-allocated since they need function scope.
&lt;         // They are primarily used by the exception handling mechanism
&lt;         int localCount = scriptOrFn.getLocalCount();
&lt;         if (localCount != 0) {
&lt;             itsLocalAllocationBase = (short)(argsLocal + 1);
&lt;             for (int i = 0; i &lt; localCount; i++) {
&lt;                 reserveWordLocal(itsLocalAllocationBase + i);
&lt;             }
&lt;         }
&lt; 
1358c1348
&lt;             scriptResultLocal = getNewWordLocal();
---
&gt;             popvLocal = getNewWordLocal();
1360c1350
&lt;             cfw.addAStore(scriptResultLocal);
---
&gt;             cfw.addAStore(popvLocal);
1394c1384
&lt;                 cfw.addALoad(scriptResultLocal);
---
&gt;                 cfw.addALoad(popvLocal);
1431a1422,1437
&gt;               case Token.LOCAL_BLOCK: {
&gt;                 visitStatement(node);
&gt;                 int local = getNewWordLocal();
&gt;                 node.putIntProp(Node.LOCAL_PROP, local);
&gt;                 while (child != null) {
&gt;                     generateCodeFromNode(child, node);
&gt;                     child = child.getNext();
&gt;                 }
&gt;                 releaseWordLocal((short)local);
&gt;                 node.removeProp(Node.LOCAL_PROP);
&gt;                 break;
&gt;               }
&gt; 
&gt;               case Token.USE_STACK:
&gt;                 break;
&gt; 
1495a1502,1504
&gt;               case Token.RETURN_POPV:
&gt;                 if (fnCurrent == null) Codegen.badTree();
&gt;                 // fallthrough
1497c1506,1520
&lt;                 visitReturn(node, child);
---
&gt;                 visitStatement(node);
&gt;                 if (child != null) {
&gt;                     do {
&gt;                         generateCodeFromNode(child, node);
&gt;                         child = child.getNext();
&gt;                     } while (child != null);
&gt;                 } else if (fnCurrent != null &amp;&amp; type == Token.RETURN) {
&gt;                     Codegen.pushUndefined(cfw);
&gt;                 } else {
&gt;                     if (popvLocal &lt; 0) Codegen.badTree();
&gt;                     cfw.addALoad(popvLocal);
&gt;                 }
&gt;                 if (epilogueLabel == -1)
&gt;                     epilogueLabel = cfw.acquireLabel();
&gt;                 cfw.add(ByteCode.GOTO, epilogueLabel);
1516,1518c1539,1553
&lt;               case Token.NEWSCOPE:
&lt;                 addScriptRuntimeInvoke("newScope",
&lt;                                        "()Lorg/mozilla/javascript/Scriptable;");
---
&gt;               case Token.INIT_LIST:
&gt;                 generateCodeFromNode(child, node);
&gt;                 while (null != (child = child.getNext())) {
&gt;                     cfw.add(ByteCode.DUP);
&gt;                     generateCodeFromNode(child, node);
&gt;                     cfw.add(ByteCode.POP);
&gt;                 }
&gt;                 break;
&gt; 
&gt;               case Token.CATCH_SCOPE:
&gt;                 cfw.addPush(node.getString());
&gt;                 generateCodeFromNode(child, node);
&gt;                 addScriptRuntimeInvoke("newCatchScope",
&gt;                                        "(Ljava/lang/String;Ljava/lang/Object;"
&gt;                                        +")Lorg/mozilla/javascript/Scriptable;");
1529,1534c1564,1572
&lt;               case Token.ENUMINIT:
&lt;                 visitEnumInit(node, child);
&lt;                 break;
&lt; 
&lt;               case Token.ENUMNEXT:
&lt;                 visitEnumNext(node, child);
---
&gt;               case Token.ENUM_INIT: {
&gt;                 generateCodeFromNode(child, node);
&gt;                 cfw.addALoad(variableObjectLocal);
&gt;                 addScriptRuntimeInvoke("enumInit",
&gt;                                        "(Ljava/lang/Object;"
&gt;                                        +"Lorg/mozilla/javascript/Scriptable;"
&gt;                                        +")Ljava/lang/Object;");
&gt;                 int local = getLocalBlockRegister(node);
&gt;                 cfw.addAStore(local);
1535a1574
&gt;               }
1537,1538c1576,1586
&lt;               case Token.ENUMDONE:
&lt;                 visitEnumDone(node, child);
---
&gt;               case Token.ENUM_NEXT:
&gt;               case Token.ENUM_ID: {
&gt;                 int local = getLocalBlockRegister(node);
&gt;                 cfw.addALoad(local);
&gt;                 if (type == Token.ENUM_NEXT) {
&gt;                     addScriptRuntimeInvoke(
&gt;                         "enumNext", "(Ljava/lang/Object;)Ljava/lang/Boolean;");
&gt;                 } else {
&gt;                     addScriptRuntimeInvoke(
&gt;                         "enumId", "(Ljava/lang/Object;)Ljava/lang/String;");
&gt;                 }
1539a1588
&gt;               }
1562,1564c1611,1613
&lt;                 while (child != null) {
&lt;                     generateCodeFromNode(child, node);
&lt;                     child = child.getNext();
---
&gt;                 generateCodeFromNode(child, node);
&gt;                 if (popvLocal &lt; 0) {
&gt;                     popvLocal = getNewWordLocal();
1566c1615
&lt;                 cfw.addAStore(scriptResultLocal);
---
&gt;                 cfw.addAStore(popvLocal);
1652a1702,1719
&gt;               case Token.HOOK : {
&gt;                     Node ifThen = child.getNext();
&gt;                     Node ifElse = ifThen.getNext();
&gt;                     generateCodeFromNode(child, node);
&gt;                     addScriptRuntimeInvoke("toBoolean",
&gt;                                            "(Ljava/lang/Object;)Z");
&gt;                     int elseTarget = cfw.acquireLabel();
&gt;                     cfw.add(ByteCode.IFEQ, elseTarget);
&gt;                     short stack = cfw.getStackTop();
&gt;                     generateCodeFromNode(ifThen, node);
&gt;                     int afterHook = cfw.acquireLabel();
&gt;                     cfw.add(ByteCode.GOTO, afterHook);
&gt;                     cfw.markLabel(elseTarget, stack);
&gt;                     generateCodeFromNode(ifElse, node);
&gt;                     cfw.markLabel(afterHook);
&gt;                 }
&gt;                 break;
&gt; 
1796c1863,1864
&lt;                 visitSetProp(node, child);
---
&gt;               case Token.SETPROP_OP:
&gt;                 visitSetProp(type, node, child);
1800,1802c1868,1900
&lt;                 while (child != null) {
&lt;                     generateCodeFromNode(child, node);
&lt;                     child = child.getNext();
---
&gt;               case Token.SETELEM_OP: {
&gt;                 generateCodeFromNode(child, node);
&gt;                 child = child.getNext();
&gt;                 if (type == Token.SETELEM_OP) {
&gt;                     cfw.add(ByteCode.DUP);
&gt;                 }
&gt;                 generateCodeFromNode(child, node);
&gt;                 child = child.getNext();
&gt;                 boolean indexIsNumber
&gt;                     = (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1);
&gt;                 if (type == Token.SETELEM_OP) {
&gt;                     if (indexIsNumber) {
&gt;                         // stack: ... object object number
&gt;                         //        -&gt; ... object number object number
&gt;                         cfw.add(ByteCode.DUP2_X1);
&gt;                         cfw.addALoad(variableObjectLocal);
&gt;                         addOptRuntimeInvoke(
&gt;                             "getElem",
&gt;                             "(Ljava/lang/Object;D"
&gt;                             +"Lorg/mozilla/javascript/Scriptable;"
&gt;                             +")Ljava/lang/Object;");
&gt;                     } else {
&gt;                         // stack: ... object object indexObject
&gt;                         //        -&gt; ... object indexObject object indexObject
&gt;                         cfw.add(ByteCode.DUP_X1);
&gt;                         cfw.addALoad(variableObjectLocal);
&gt;                         addScriptRuntimeInvoke(
&gt;                             "getElem",
&gt;                             "(Ljava/lang/Object;"
&gt;                             +"Ljava/lang/Object;"
&gt;                             +"Lorg/mozilla/javascript/Scriptable;"
&gt;                             +")Ljava/lang/Object;");
&gt;                     }
1803a1902
&gt;                 generateCodeFromNode(child, node);
1805c1904
&lt;                 if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {
---
&gt;                 if (indexIsNumber) {
1823a1923
&gt;               }
1867,1872c1967,1968
&lt;               case Token.NEWLOCAL:
&lt;                 visitNewLocal(node, child);
&lt;                 break;
&lt; 
&lt;               case Token.USELOCAL:
&lt;                 visitUseLocal(node, child);
---
&gt;               case Token.LOCAL_LOAD:
&gt;                 cfw.addALoad(getLocalBlockRegister(node));
2062,2101d2157
&lt;     private void visitEnumInit(Node node, Node child)
&lt;     {
&lt;         while (child != null) {
&lt;             generateCodeFromNode(child, node);
&lt;             child = child.getNext();
&lt;         }
&lt;         cfw.addALoad(variableObjectLocal);
&lt;         addScriptRuntimeInvoke("initEnum",
&lt;                                "(Ljava/lang/Object;"
&lt;                                +"Lorg/mozilla/javascript/Scriptable;"
&lt;                                +")Ljava/lang/Object;");
&lt;         short x = getNewWordLocal();
&lt;         cfw.addAStore(x);
&lt;         node.putIntProp(Node.LOCAL_PROP, x);
&lt;     }
&lt; 
&lt;     private void visitEnumNext(Node node, Node child)
&lt;     {
&lt;         while (child != null) {
&lt;             generateCodeFromNode(child, node);
&lt;             child = child.getNext();
&lt;         }
&lt;         Node init = (Node) node.getProp(Node.ENUM_PROP);
&lt;         int local = init.getExistingIntProp(Node.LOCAL_PROP);
&lt;         cfw.addALoad(local);
&lt;         addScriptRuntimeInvoke("nextEnum",
&lt;                                "(Ljava/lang/Object;)Ljava/lang/Object;");
&lt;     }
&lt; 
&lt;     private void visitEnumDone(Node node, Node child)
&lt;     {
&lt;         while (child != null) {
&lt;             generateCodeFromNode(child, node);
&lt;             child = child.getNext();
&lt;         }
&lt;         Node init = (Node) node.getProp(Node.ENUM_PROP);
&lt;         int local = init.getExistingIntProp(Node.LOCAL_PROP);
&lt;         releaseWordLocal((short)local);
&lt;     }
&lt; 
2548c2604
&lt; 
---
&gt;         int exceptionLocal = getLocalBlockRegister(node);
2556c2612
&lt;                                catchLabel, startLabel);
---
&gt;                                catchLabel, startLabel, exceptionLocal);
2562c2618
&lt;                                catchLabel, startLabel);
---
&gt;                                catchLabel, startLabel, exceptionLocal);
2569c2625
&lt;                                catchLabel, startLabel);
---
&gt;                                catchLabel, startLabel, exceptionLocal);
2576a2633
&gt;             cfw.addAStore(exceptionLocal);
2582,2584d2638
&lt;             short exnLocal = itsLocalAllocationBase++;
&lt;             cfw.addAStore(exnLocal);
&lt; 
2590c2644
&lt;             cfw.addALoad(exnLocal);
---
&gt;             cfw.addALoad(exceptionLocal);
2595c2649
&lt;                                           finallyHandler, null); // catch any
---
&gt;                                     finallyHandler, null); // catch any
2607,2608c2661,2662
&lt;                                     int catchLabel,
&lt;                                     int startLabel)
---
&gt;                                     int catchLabel, int startLabel,
&gt;                                     int exceptionLocal)
2613a2668
&gt;         // XXX: is it possible to use on MS JVM exceptionLocal to store it?
2633a2689
&gt;         cfw.addAStore(exceptionLocal);
2647c2703
&lt;                                       exceptionName);
---
&gt;                                 exceptionName);
2674,2692d2729
&lt;     private void visitReturn(Node node, Node child)
&lt;     {
&lt;         visitStatement(node);
&lt;         if (child != null) {
&lt;             do {
&lt;                 generateCodeFromNode(child, node);
&lt;                 child = child.getNext();
&lt;             } while (child != null);
&lt;         } else if (fnCurrent != null) {
&lt;             Codegen.pushUndefined(cfw);
&lt;         } else {
&lt;             cfw.addALoad(scriptResultLocal);
&lt;         }
&lt; 
&lt;         if (epilogueLabel == -1)
&lt;             epilogueLabel = cfw.acquireLabel();
&lt;         cfw.add(ByteCode.GOTO, epilogueLabel);
&lt;     }
&lt; 
2718a2756
&gt;         releaseWordLocal(selector);
3594a3633,3634
&gt;         generateCodeFromNode(child, node);      // the object
&gt;         generateCodeFromNode(nameChild, node);  // the name
3600,3626c3640,3653
&lt;         generateCodeFromNode(child, node);      // the object
&lt;         generateCodeFromNode(nameChild, node);  // the name
&lt;         if (nameChild.getType() == Token.STRING) {
&lt;             if ((child.getType() == Token.THIS)
&lt;                 || (child.getType() == Token.NEWTEMP
&lt;                     &amp;&amp; child.getFirstChild().getType() == Token.THIS))
&lt;             {
&lt;                 cfw.addALoad(variableObjectLocal);
&lt;                 addOptRuntimeInvoke(
&lt;                     "thisGet",
&lt;                     "(Lorg/mozilla/javascript/Scriptable;"
&lt;                     +"Ljava/lang/String;"
&lt;                     +"Lorg/mozilla/javascript/Scriptable;"
&lt;                     +")Ljava/lang/Object;");
&lt;             }
&lt;             else {
&lt;                 cfw.addALoad(variableObjectLocal);
&lt;                 addScriptRuntimeInvoke(
&lt;                     "getProp",
&lt;                     "(Ljava/lang/Object;"
&lt;                     +"Ljava/lang/String;"
&lt;                     +"Lorg/mozilla/javascript/Scriptable;"
&lt;                     +")Ljava/lang/Object;");
&lt;             }
&lt;         }
&lt;         else {
&lt;             cfw.addALoad(variableObjectLocal);
---
&gt;         cfw.addALoad(variableObjectLocal);
&gt;         int childType = child.getType();
&gt;         if ((childType == Token.THIS
&gt;             || (childType == Token.NEWTEMP
&gt;                 &amp;&amp; child.getFirstChild().getType() == Token.THIS))
&gt;             &amp;&amp; nameChild.getType() == Token.STRING)
&gt;         {
&gt;             addOptRuntimeInvoke(
&gt;                 "thisGet",
&gt;                 "(Lorg/mozilla/javascript/Scriptable;"
&gt;                 +"Ljava/lang/String;"
&gt;                 +"Lorg/mozilla/javascript/Scriptable;"
&gt;                 +")Ljava/lang/Object;");
&gt;         } else {
3636c3663
&lt;     private void visitSetProp(Node node, Node child)
---
&gt;     private void visitSetProp(int type, Node node, Node child)
3637a3665,3667
&gt;         Node objectChild = child;
&gt;         generateCodeFromNode(child, node);
&gt;         child = child.getNext();
3640,3642c3670,3685
&lt;             while (child != null) {
&lt;                 generateCodeFromNode(child, node);
&lt;                 child = child.getNext();
---
&gt;             if (type == Token.SETPROP_OP) {
&gt;                 cfw.add(ByteCode.DUP);
&gt;                 String runtimeMethod = null;
&gt;                 if (special == Node.SPECIAL_PROP_PROTO) {
&gt;                     runtimeMethod = "getProto";
&gt;                 } else if (special == Node.SPECIAL_PROP_PARENT) {
&gt;                     runtimeMethod = "getParent";
&gt;                 } else {
&gt;                     Codegen.badTree();
&gt;                 }
&gt;                 cfw.addALoad(variableObjectLocal);
&gt;                 addScriptRuntimeInvoke(
&gt;                     runtimeMethod,
&gt;                     "(Ljava/lang/Object;"
&gt;                     +"Lorg/mozilla/javascript/Scriptable;"
&gt;                     +")Lorg/mozilla/javascript/Scriptable;");
3643a3687
&gt;             generateCodeFromNode(child, node);
3661,3663c3705,3707
&lt;         while (child != null) {
&lt;             generateCodeFromNode(child, node);
&lt;             child = child.getNext();
---
&gt; 
&gt;         if (type == Token.SETPROP_OP) {
&gt;             cfw.add(ByteCode.DUP);
3664a3709,3736
&gt;         Node nameChild = child;
&gt;         generateCodeFromNode(child, node);
&gt;         child = child.getNext();
&gt;         if (type == Token.SETPROP_OP) {
&gt;             // stack: ... object object name -&gt; ... object name object name
&gt;             cfw.add(ByteCode.DUP_X1);
&gt;             cfw.addALoad(variableObjectLocal);
&gt;             //for 'this.foo += ...' we call thisGet which can skip some
&gt;             //casting overhead.
&gt;             if (objectChild.getType() == Token.THIS
&gt;                 &amp;&amp; nameChild.getType() == Token.STRING)
&gt;             {
&gt;                 addOptRuntimeInvoke(
&gt;                     "thisGet",
&gt;                     "(Lorg/mozilla/javascript/Scriptable;"
&gt;                     +"Ljava/lang/String;"
&gt;                     +"Lorg/mozilla/javascript/Scriptable;"
&gt;                     +")Ljava/lang/Object;");
&gt;             } else {
&gt;                 addScriptRuntimeInvoke(
&gt;                     "getProp",
&gt;                     "(Ljava/lang/Object;"
&gt;                     +"Ljava/lang/String;"
&gt;                     +"Lorg/mozilla/javascript/Scriptable;"
&gt;                     +")Ljava/lang/Object;");
&gt;             }
&gt;         }
&gt;         generateCodeFromNode(child, node);
3691c3763
&lt;     private short getLocalFromNode(Node node)
---
&gt;     private int getLocalBlockRegister(Node node)
3693,3704c3765,3767
&lt;         int local = node.getIntProp(Node.LOCAL_PROP, -1);
&lt;         if (local == -1) {
&lt;             // for NEWLOCAL &amp; USELOCAL, use the next pre-allocated
&lt;             // register, otherwise for NEWTEMP &amp; USETEMP, get the
&lt;             // next available from the pool
&lt;             local = ((node.getType() == Token.NEWLOCAL)
&lt;                                 || (node.getType() == Token.USELOCAL)) ?
&lt;                             itsLocalAllocationBase++ : getNewWordLocal();
&lt; 
&lt;             node.putIntProp(Node.LOCAL_PROP, local);
&lt;         }
&lt;         return (short)local;
---
&gt;         Node localBlock = (Node)node.getProp(Node.LOCAL_BLOCK_PROP);
&gt;         int localSlot = localBlock.getExistingIntProp(Node.LOCAL_PROP);
&gt;         return localSlot;
3709,3713c3772,3774
&lt;         while (child != null) {
&lt;             generateCodeFromNode(child, node);
&lt;             child = child.getNext();
&lt;         }
&lt;         short local = getLocalFromNode(node);
---
&gt;         generateCodeFromNode(child, node);
&gt;         int local = getNewWordLocal();
&gt;         node.putIntProp(Node.LOCAL_PROP, local);
3717c3778
&lt;             releaseWordLocal(local);
---
&gt;             releaseWordLocal((short)local);
3722,3725d3782
&lt;         while (child != null) {
&lt;             generateCodeFromNode(child, node);
&lt;             child = child.getNext();
&lt;         }
3727c3784
&lt;         short local = getLocalFromNode(temp);
---
&gt;         int local = temp.getExistingIntProp(Node.LOCAL_PROP);
3731c3788
&lt;             releaseWordLocal(local);
---
&gt;             releaseWordLocal((short)local);
3738,3759d3794
&lt;     private void visitNewLocal(Node node, Node child)
&lt;     {
&lt;         while (child != null) {
&lt;             generateCodeFromNode(child, node);
&lt;             child = child.getNext();
&lt;         }
&lt;         short local = getLocalFromNode(node);
&lt;         cfw.add(ByteCode.DUP);
&lt;         cfw.addAStore(local);
&lt;     }
&lt; 
&lt;     private void visitUseLocal(Node node, Node child)
&lt;     {
&lt;         while (child != null) {
&lt;             generateCodeFromNode(child, node);
&lt;             child = child.getNext();
&lt;         }
&lt;         Node temp = (Node) node.getProp(Node.LOCAL_PROP);
&lt;         short local = getLocalFromNode(temp);
&lt;         cfw.addALoad(local);
&lt;     }
&lt; 
3871d3905
&lt;     private short itsLocalAllocationBase;
3877c3911
&lt;     private short scriptResultLocal;
---
&gt;     private short popvLocal;
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/PreorderNodeIterator.java" revision="1.15" state="deleted"/>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/IRFactory.java" revision="1.67" state="changed">131c131
&lt;             catchCond = new Node(Token.TRUE);
---
&gt;             catchCond = new Node(Token.EMPTY);
197c197
&lt;         return compiler.createFunctionNode(this, name);
---
&gt;         return compiler.createFunctionNode(name);
339,345c339,347
&lt;         Node init = new Node(Token.ENUMINIT, objNode);
&lt;         Node next = new Node(Token.ENUMNEXT);
&lt;         next.putProp(Node.ENUM_PROP, init);
&lt;         Node temp = createNewTemp(next);
&lt;         Node cond = new Node(Token.NE);
&lt;         cond.addChildToBack(temp);
&lt;         cond.addChildToBack(new Node(Token.NULL));
---
&gt;         Node localBlock = new Node(Token.LOCAL_BLOCK);
&gt; 
&gt;         Node init = new Node(Token.ENUM_INIT, objNode);
&gt;         init.putProp(Node.LOCAL_BLOCK_PROP, localBlock);
&gt;         Node cond = new Node(Token.ENUM_NEXT);
&gt;         cond.putProp(Node.LOCAL_BLOCK_PROP, localBlock);
&gt;         Node id = new Node(Token.ENUM_ID);
&gt;         id.putProp(Node.LOCAL_BLOCK_PROP, localBlock);
&gt; 
347c349
&lt;         Node assign = (Node) createAssignment(lvalue, createUseTemp(temp));
---
&gt;         Node assign = (Node) createAssignment(lvalue, id);
350d351
&lt;         Node result = (Node) createWhile(cond, newBody, lineno);
352c353,354
&lt;         result.addChildToFront(init);
---
&gt;         Node loop = (Node) createWhile(cond, newBody, lineno);
&gt;         loop.addChildToFront(init);
354c356,357
&lt;             result.addChildToFront(lhsNode);
---
&gt;             loop.addChildToFront(lhsNode);
&gt;         localBlock.addChildToBack(loop);
356,360c359
&lt;         Node done = new Node(Token.ENUMDONE);
&lt;         done.putProp(Node.ENUM_PROP, init);
&lt;         result.addChildToBack(done);
&lt; 
&lt;         return result;
---
&gt;         return localBlock;
405a405,406
&gt; 
&gt;         Node localBlock  = new Node(Token.LOCAL_BLOCK);
406a408
&gt;         pn.putProp(Node.LOCAL_BLOCK_PROP, localBlock);
432c434
&lt;                 } catch (e: e instanceof Object) {
---
&gt;                 } catch (e if e instanceof Object) {
443,445c445
&lt;                         o = newScope();
&lt;                         o.e = x;
&lt;                         with (o) {
---
&gt;                         with (newCatchScope(e, x)) {
450,452c450
&lt;                         o2 = newScope();
&lt;                         o2.e2 = x;
&lt;                         with (o2) {
---
&gt;                         with (newCatchScope(e2, x)) {
465,468d462
&lt;             // get the exception object and store it in a temp
&lt;             Node exn = createNewLocal(new Node(Token.EMPTY));
&lt;             pn.addChildToBack(new Node(Token.POP, exn));
&lt; 
473a468
&gt;             boolean hasDefault = false;
475d469
&lt;                 Node catchStmt = new Node(Token.BLOCK);
485,490d478
&lt;                 Node newScope = createNewLocal(new Node(Token.NEWSCOPE));
&lt;                 Node initScope = new Node(Token.SETPROP, newScope,
&lt;                                           Node.newString(name.getString()),
&lt;                                           createUseLocal(exn));
&lt;                 catchStmt.addChildToBack(new Node(Token.POP, initScope));
&lt; 
495,496c483,490
&lt; 
&lt;                 Node ifStmt = (Node) createIf(cond, catchBlock, null, catchLineNo);
---
&gt;                 Node condStmt;
&gt;                 if (cond.getType() == Token.EMPTY) {
&gt;                     condStmt = catchBlock;
&gt;                     hasDefault = true;
&gt;                 } else {
&gt;                     condStmt = (Node) createIf(cond, catchBlock, null,
&gt;                                                catchLineNo);
&gt;                 }
502,506c496,501
&lt;                 Node withStmt = (Node) createWith(createUseLocal(newScope),
&lt;                                                   ifStmt, catchLineNo);
&lt;                 catchStmt.addChildToBack(withStmt);
&lt; 
&lt;                 pn.addChildToBack(catchStmt);
---
&gt;                 Node catchScope = Node.newString(Token.CATCH_SCOPE,
&gt;                                                  name.getString());
&gt;                 catchScope.addChildToBack(createUseLocal(localBlock));
&gt;                 Node withStmt = (Node) createWith(catchScope, condStmt,
&gt;                                                   catchLineNo);
&gt;                 pn.addChildToBack(withStmt);
511,514c506,511
&lt; 
&lt;             // Generate code to rethrow if no catch clause was executed
&lt;             Node rethrow = new Node(Token.THROW, createUseLocal(exn));
&lt;             pn.addChildToBack(rethrow);
---
&gt;             if (!hasDefault) {
&gt;                 // Generate code to rethrow if no catch clause was executed
&gt;                 Node rethrow = new Node(Token.THROW,
&gt;                                         createUseLocal(localBlock));
&gt;                 pn.addChildToBack(rethrow);
&gt;             }
530c527,529
&lt;             pn.addChildToBack(new Node(Token.FINALLY, finallyNode));
---
&gt;             Node fBlock = new Node(Token.FINALLY, finallyNode);
&gt;             fBlock.putProp(Node.LOCAL_BLOCK_PROP, localBlock);
&gt;             pn.addChildToBack(fBlock);
533c532,533
&lt;         return pn;
---
&gt;         localBlock.addChildToBack(pn);
&gt;         return localBlock;
561c561
&lt;         Node temp = createNewTemp(array);
---
&gt;         Node list = new Node(Token.INIT_LIST, array);
565d564
&lt;         Node comma = new Node(Token.COMMA, temp);
575c574
&lt;             Node addelem = new Node(Token.SETELEM, createUseTemp(temp),
---
&gt;             Node addelem = new Node(Token.SETELEM, new Node(Token.USE_STACK),
578c577
&lt;             comma.addChildToBack(addelem);
---
&gt;             list.addChildToBack(addelem);
598c597
&lt;                                           createUseTemp(temp),
---
&gt;                                           new Node(Token.USE_STACK),
601c600
&lt;                 comma.addChildToBack(setlength);
---
&gt;                 list.addChildToBack(setlength);
606,607c605
&lt;         comma.addChildToBack(createUseTemp(temp));
&lt;         return comma;
---
&gt;         return list;
617,619c615,617
&lt;         Node result = new Node(Token.NEW, Node.newString(Token.NAME,
&lt;                                                          "Object"));
&lt;         Node temp = createNewTemp(result);
---
&gt;         Node result = new Node(Token.NEW,
&gt;                                Node.newString(Token.NAME, "Object"));
&gt;         Node list = new Node(Token.INIT_LIST, result);
621d618
&lt;         Node comma = new Node(Token.COMMA, temp);
631,632c628,629
&lt;             Node addelem = new Node(op, createUseTemp(temp), n, next);
&lt;             comma.addChildToBack(addelem);
---
&gt;             Node addelem = new Node(op, new Node(Token.USE_STACK), n, next);
&gt;             list.addChildToBack(addelem);
634,635c631
&lt;         comma.addChildToBack(createUseTemp(temp));
&lt;         return comma;
---
&gt;         return list;
688,689c684,693
&lt;     public Object createTernary(Object cond, Object ifTrue, Object ifFalse) {
&lt;         return createIf(cond, ifTrue, ifFalse, -1);
---
&gt;     public Object createCondExpr(Object condObj, Object ifTrue, Object ifFalse)
&gt;     {
&gt;         Node cond = (Node)condObj;
&gt;         int condStatus = isAlwaysDefinedBoolean(cond);
&gt;         if (condStatus == ALWAYS_TRUE_BOOLEAN) {
&gt;             return ifTrue;
&gt;         } else if (condStatus == ALWAYS_FALSE_BOOLEAN) {
&gt;             return ifFalse;
&gt;         }
&gt;         return new Node(Token.HOOK, cond, (Node)ifTrue, (Node)ifFalse);
765,773c769,772
&lt;         if (post &amp;&amp; !hasSideEffects(childNode)
&lt;             &amp;&amp; (childType == Token.NAME
&lt;                 || childType == Token.GETPROP
&lt;                 || childType == Token.GETELEM))
&lt;         {
&lt;             // if it's not a LHS type, createAssignment (below) will throw
&lt;             // an exception.
&lt;             return new Node(nodeType, childNode);
&lt;         }
---
&gt;         if (childType == Token.NAME) {
&gt;             if (post) {
&gt;                 return new Node(nodeType, childNode);
&gt;             }
775,790c774,810
&lt;         /*
&lt;          * Transform INC/DEC ops to +=1, -=1,
&lt;          * expecting later optimization of all +/-=1 cases to INC, DEC.
&lt;          */
&lt;         // we have to use Double for now, because
&lt;         // 0.0 and 1.0 are stored as dconst_[01],
&lt;         // and using a Float creates a stack mismatch.
&lt;         Node rhs = (Node) createNumber(1.0);
&lt; 
&lt;         return createAssignmentOp(nodeType == Token.INC
&lt;                                     ? Token.ADD
&lt;                                     : Token.SUB,
&lt;                                   childNode,
&lt;                                   rhs,
&lt;                                   true,
&lt;                                   post);
---
&gt;             /*
&gt;              * Transform INC/DEC ops to +=1, -=1,
&gt;              * expecting later optimization of all +/-=1 cases to INC, DEC.
&gt;              */
&gt;             Node rhs = (Node) createNumber(1.0);
&gt; 
&gt;             String s = childNode.getString();
&gt;             Node opLeft = Node.newString(Token.NAME, s);
&gt;             opLeft = new Node(Token.POS, opLeft);
&gt; 
&gt;             int opType = (nodeType == Token.INC) ? Token.ADD : Token.SUB;
&gt;             Node op = new Node(opType, opLeft, rhs);
&gt;             Node lvalueLeft = Node.newString(Token.BINDNAME, s);
&gt;             return new Node(Token.SETNAME, lvalueLeft, op);
&gt; 
&gt;         } else if (childType == Token.GETPROP || childType == Token.GETELEM) {
&gt;             if (post) {
&gt;                 return new Node(nodeType, childNode);
&gt;             }
&gt; 
&gt;             /*
&gt;              * Transform INC/DEC ops to +=1, -=1,
&gt;              * expecting later optimization of all +/-=1 cases to INC, DEC.
&gt;              */
&gt;             Node rhs = (Node) createNumber(1.0);
&gt; 
&gt;             return createAssignmentOp(nodeType == Token.INC
&gt;                                         ? Token.ADD
&gt;                                         : Token.SUB,
&gt;                                       childNode,
&gt;                                       rhs,
&gt;                                       true);
&gt;         }
&gt;         // TODO: This should be a ReferenceError--but that's a runtime
&gt;         //  exception. Should we compile an exception into the code?
&gt;         ts.reportCurrentLineError("msg.bad.lhs.assign", null);
&gt;         return child;
1008,1009c1028
&lt;         return createAssignmentOp(assignOp, (Node) left, (Node) right,
&lt;                                   false, false);
---
&gt;         return createAssignmentOp(assignOp, (Node)left, (Node)right, false);
1013c1032
&lt;                                     boolean tonumber, boolean postfix)
---
&gt;                                     boolean tonumber)
1024,1035c1043,1045
&lt;             if (!postfix) {
&lt;                 Node op = new Node(assignOp, opLeft, right);
&lt;                 Node lvalueLeft = Node.newString(Token.BINDNAME, s);
&lt;                 return new Node(Token.SETNAME, lvalueLeft, op);
&lt;             } else {
&lt;                 opLeft = createNewTemp(opLeft);
&lt;                 Node op = new Node(assignOp, opLeft, right);
&lt;                 Node lvalueLeft = Node.newString(Token.BINDNAME, s);
&lt;                 Node result = new Node(Token.SETNAME, lvalueLeft, op);
&lt;                 result = new Node(Token.COMMA, result, createUseTemp(opLeft));
&lt;                 return result;
&lt;             }
---
&gt;             Node op = new Node(assignOp, opLeft, right);
&gt;             Node lvalueLeft = Node.newString(Token.BINDNAME, s);
&gt;             return new Node(Token.SETNAME, lvalueLeft, op);
1044,1045c1054,1055
&lt;                        ? Token.SETPROP
&lt;                        : Token.SETELEM;
---
&gt;                        ? Token.SETPROP_OP
&gt;                        : Token.SETELEM_OP;
1047,1075c1057,1058
&lt; /*
&lt; *    If the RHS expression could modify the LHS we have
&lt; *    to construct a temporary to hold the LHS context
&lt; *    prior to running the expression. Ditto, if the id
&lt; *    expression has side-effects.
&lt; *
&lt; *    XXX If the hasSideEffects tests take too long, we
&lt; *       could make this an optimizer-only transform
&lt; *       and always do the temp assignment otherwise.
&lt; *
&lt; */
&lt;             Node tmp1, tmp2, opLeft;
&lt;             if (obj.getType() != Token.NAME || id.hasChildren() ||
&lt;                 hasSideEffects(right) || hasSideEffects(id))
&lt;             {
&lt;                 tmp1 = createNewTemp(obj);
&lt;                 Node useTmp1 = createUseTemp(tmp1);
&lt; 
&lt;                 tmp2 = createNewTemp(id);
&lt;                 Node useTmp2 = createUseTemp(tmp2);
&lt; 
&lt;                 opLeft = new Node(nodeType, useTmp1, useTmp2);
&lt;             } else {
&lt;                 tmp1 = Node.newString(Token.NAME, obj.getString());
&lt;                 tmp2 = id.cloneNode();
&lt;                 opLeft = new Node(nodeType, obj, id);
&lt;             }
&lt; 
&lt;             if (tonumber)
---
&gt;             Node opLeft = new Node(Token.USE_STACK);
&gt;             if (tonumber) {
1077,1086d1059
&lt; 
&lt;             if (!postfix) {
&lt;                 Node op = new Node(assignOp, opLeft, right);
&lt;                 return new Node(type, tmp1, tmp2, op);
&lt;             } else {
&lt;                 opLeft = createNewTemp(opLeft);
&lt;                 Node op = new Node(assignOp, opLeft, right);
&lt;                 Node result = new Node(type, tmp1, tmp2, op);
&lt;                 result = new Node(Token.COMMA, result, createUseTemp(opLeft));
&lt;                 return result;
1087a1061,1062
&gt;             Node op = new Node(assignOp, opLeft, right);
&gt;             return new Node(type, obj, id, op);
1098,1136c1073,1076
&lt;     public Node createNewTemp(Node n) {
&lt;         int type = n.getType();
&lt;         if (type == Token.STRING || type == Token.NUMBER) {
&lt;             // Optimization: clone these values rather than storing
&lt;             // and loading from a temp
&lt;             return n;
&lt;         }
&lt;         return new Node(Token.NEWTEMP, n);
&lt;     }
&lt; 
&lt;     public Node createUseTemp(Node newTemp)
&lt;     {
&lt;         switch (newTemp.getType()) {
&lt;           case Token.NEWTEMP: {
&lt;             Node result = new Node(Token.USETEMP);
&lt;             result.putProp(Node.TEMP_PROP, newTemp);
&lt;             int n = newTemp.getIntProp(Node.USES_PROP, 0);
&lt;             if (n != Integer.MAX_VALUE) {
&lt;                 newTemp.putIntProp(Node.USES_PROP, n + 1);
&lt;             }
&lt;             return result;
&lt;           }
&lt;           case Token.STRING:
&lt;             return Node.newString(newTemp.getString());
&lt;           case Token.NUMBER:
&lt;             return Node.newNumber(newTemp.getDouble());
&lt;           default:
&lt;             throw Kit.codeBug();
&lt;         }
&lt;     }
&lt; 
&lt;     public Node createNewLocal(Node n) {
&lt;         return new Node(Token.NEWLOCAL, n);
&lt;     }
&lt; 
&lt;     public Node createUseLocal(Node newLocal) {
&lt;         if (Token.NEWLOCAL != newLocal.getType()) Kit.codeBug();
&lt;         Node result = new Node(Token.USELOCAL);
&lt;         result.putProp(Node.LOCAL_PROP, newLocal);
---
&gt;     public Node createUseLocal(Node localBlock) {
&gt;         if (Token.LOCAL_BLOCK != localBlock.getType()) Kit.codeBug();
&gt;         Node result = new Node(Token.LOCAL_LOAD);
&gt;         result.putProp(Node.LOCAL_BLOCK_PROP, localBlock);
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/optimizer/Block.java" revision="1.20" state="changed">49,50c49
&lt;     public Block(IRFactory irFactory, int startNodeIndex, int endNodeIndex,
&lt;                  Node[] statementNodes)
---
&gt;     public Block(int startNodeIndex, int endNodeIndex, Node[] statementNodes)
52d50
&lt;         itsIRFactory = irFactory;
66,67c64
&lt;     public static Block[]
&lt;     buildBlocks(IRFactory irFactory, Node[] statementNodes)
---
&gt;     public static Block[] buildBlocks(Node[] statementNodes)
81,82c78
&lt;                             FatBlock fb = new FatBlock(irFactory,
&lt;                                                        beginNodeIndex, i - 1,
---
&gt;                             FatBlock fb = new FatBlock(beginNodeIndex, i - 1,
97,98c93
&lt;                         FatBlock fb = new FatBlock(irFactory,
&lt;                                                    beginNodeIndex, i,
---
&gt;                         FatBlock fb = new FatBlock(beginNodeIndex, i,
112,113c107
&lt;             FatBlock fb = new FatBlock(irFactory,
&lt;                                        beginNodeIndex,
---
&gt;             FatBlock fb = new FatBlock(beginNodeIndex,
467c461,462
&lt;             case Token.SETPROP : {
---
&gt;             case Token.SETPROP :
&gt;             case Token.SETPROP_OP : {
528c523,524
&lt;             case Token.SETPROP : {
---
&gt;             case Token.SETPROP :
&gt;             case Token.SETPROP_OP : {
567,568c563
&lt;                                         theCSE = itsIRFactory.createNewLocal(cseHolder.getPropChild);
&lt;                                         theFunction.incrementLocalCount();
---
&gt;                                         theCSE = OptTransformer.createNewTemp(cseHolder.getPropChild);
579c574
&lt;                                     Node cseUse = itsIRFactory.createUseLocal(theCSE);
---
&gt;                                     Node cseUse = OptTransformer.createUseTemp(theCSE);
590c585,586
&lt;             case Token.SETELEM : {
---
&gt;             case Token.SETELEM :
&gt;             case Token.SETELEM_OP : {
670,671d665
&lt;     private IRFactory itsIRFactory;
&lt; 
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/optimizer/Optimizer.java" revision="1.32" state="changed">62,65d61
&lt;     Optimizer(IRFactory irFactory) {
&lt;         this.irFactory = irFactory;
&lt;     }
&lt; 
83,84c79,84
&lt;         Node[] theStatementNodes = buildStatementList(theFunction);
&lt;         Block[] theBlocks = Block.buildBlocks(irFactory, theStatementNodes);
---
&gt;         ObjArray statementsArray = new ObjArray();
&gt;         buildStatementList_r(theFunction, statementsArray);
&gt;         Node[] theStatementNodes = new Node[statementsArray.size()];
&gt;         statementsArray.toArray(theStatementNodes);
&gt; 
&gt;         Block[] theBlocks = Block.buildBlocks(theStatementNodes);
585c585,586
&lt;             case Token.SETELEM : {
---
&gt;             case Token.SETELEM :
&gt;             case Token.SETELEM_OP : {
703,704c704
&lt; 
&lt;     private static Node[] buildStatementList(FunctionNode theFunction)
---
&gt;     private static void buildStatementList_r(Node node, ObjArray statements)
706,719c706,715
&lt;         ObjArray statements = new ObjArray();
&lt; 
&lt;         PreorderNodeIterator iter = new PreorderNodeIterator();
&lt;         for (iter.start(theFunction); !iter.done(); ) {
&lt;             Node node = iter.getCurrent();
&lt;             int type = node.getType();
&lt;             if (type == Token.BLOCK
&lt;                 || type == Token.LOOP
&lt;                 || type == Token.FUNCTION)
&lt;             {
&lt;                 iter.next();
&lt;             } else {
&lt;                 statements.add(node);
&lt;                 iter.nextSkipSubtree();
---
&gt;         int type = node.getType();
&gt;         if (type == Token.BLOCK
&gt;             || type == Token.LOCAL_BLOCK
&gt;             || type == Token.LOOP
&gt;             || type == Token.FUNCTION)
&gt;         {
&gt;             Node child = node.getFirstChild();
&gt;             while (child != null) {
&gt;                 buildStatementList_r(child, statements);
&gt;                 child = child.getNext();
720a717,718
&gt;         } else {
&gt;             statements.add(node);
722,725d719
&lt; 
&lt;         Node[] result = new Node[statements.size()];
&lt;         statements.toArray(result);
&lt;         return result;
727a722
&gt; 
731d725
&lt;     private IRFactory irFactory;
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/ScriptOrFnNode.java" revision="1.14" state="changed">177,182d176
&lt;     public final int getLocalCount() { return localCount; }
&lt; 
&lt;     public final void incrementLocalCount() {
&lt;         ++localCount;
&lt;     }
&lt; 
202,204d195
&lt; 
&lt;     private int localCount;
&lt; 
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/Interpreter.java" revision="1.198" state="changed">51a52,53
&gt; 
&gt;     // Stack: ... value1 -&gt; ... value1 value1
53a56,64
&gt;     // Stack: ... value2 value1 -&gt; ... value2 value1 value2
&gt;         Icode_DUPSECOND                 = BASE_ICODE + 2,
&gt; 
&gt;     // Stack: ... value2 value1 -&gt; ... value1 value2
&gt;         Icode_SWAP                      = BASE_ICODE + 3,
&gt; 
&gt;     // To jump conditionally and pop additional stack value
&gt;         Icode_IFEQ_POP                  = BASE_ICODE + 4,
&gt; 
55,62c66,73
&lt;         Icode_NAMEINC                   = BASE_ICODE + 2,
&lt;         Icode_PROPINC                   = BASE_ICODE + 3,
&lt;         Icode_ELEMINC                   = BASE_ICODE + 4,
&lt;         Icode_VARINC                    = BASE_ICODE + 5,
&lt;         Icode_NAMEDEC                   = BASE_ICODE + 6,
&lt;         Icode_PROPDEC                   = BASE_ICODE + 7,
&lt;         Icode_ELEMDEC                   = BASE_ICODE + 8,
&lt;         Icode_VARDEC                    = BASE_ICODE + 9,
---
&gt;         Icode_NAMEINC                   = BASE_ICODE + 5,
&gt;         Icode_PROPINC                   = BASE_ICODE + 6,
&gt;         Icode_ELEMINC                   = BASE_ICODE + 7,
&gt;         Icode_VARINC                    = BASE_ICODE + 8,
&gt;         Icode_NAMEDEC                   = BASE_ICODE + 9,
&gt;         Icode_PROPDEC                   = BASE_ICODE + 10,
&gt;         Icode_ELEMDEC                   = BASE_ICODE + 11,
&gt;         Icode_VARDEC                    = BASE_ICODE + 12,
65,66c76,81
&lt;         Icode_SCOPE                     = BASE_ICODE + 10,
&lt;         Icode_TYPEOFNAME                = BASE_ICODE + 11,
---
&gt;         Icode_SCOPE                     = BASE_ICODE + 13,
&gt;         Icode_TYPEOFNAME                = BASE_ICODE + 14,
&gt; 
&gt;     // helper for function calls
&gt;         Icode_NAME_AND_THIS             = BASE_ICODE + 15,
&gt;         Icode_PUSH_PARENT               = BASE_ICODE + 16,
69,73c84,87
&lt;         Icode_GETPROTO                  = BASE_ICODE + 12,
&lt;         Icode_GETPARENT                 = BASE_ICODE + 13,
&lt;         Icode_GETSCOPEPARENT            = BASE_ICODE + 14,
&lt;         Icode_SETPROTO                  = BASE_ICODE + 15,
&lt;         Icode_SETPARENT                 = BASE_ICODE + 16,
---
&gt;         Icode_GETPROTO                  = BASE_ICODE + 17,
&gt;         Icode_GETSCOPEPARENT            = BASE_ICODE + 18,
&gt;         Icode_SETPROTO                  = BASE_ICODE + 19,
&gt;         Icode_SETPARENT                 = BASE_ICODE + 20,
76c90
&lt;         Icode_CLOSURE                   = BASE_ICODE + 17,
---
&gt;         Icode_CLOSURE                   = BASE_ICODE + 21,
79c93
&lt;         Icode_CALLSPECIAL               = BASE_ICODE + 18,
---
&gt;         Icode_CALLSPECIAL               = BASE_ICODE + 22,
82c96
&lt;         Icode_RETUNDEF                  = BASE_ICODE + 19,
---
&gt;         Icode_RETUNDEF                  = BASE_ICODE + 23,
85,87c99,101
&lt;         Icode_CATCH                     = BASE_ICODE + 20,
&lt;         Icode_GOSUB                     = BASE_ICODE + 21,
&lt;         Icode_RETSUB                    = BASE_ICODE + 22,
---
&gt;         Icode_CATCH                     = BASE_ICODE + 24,
&gt;         Icode_GOSUB                     = BASE_ICODE + 25,
&gt;         Icode_RETSUB                    = BASE_ICODE + 26,
90c104
&lt;         Icode_LINE                      = BASE_ICODE + 23,
---
&gt;         Icode_LINE                      = BASE_ICODE + 27,
93,94c107,108
&lt;         Icode_SHORTNUMBER               = BASE_ICODE + 24,
&lt;         Icode_INTNUMBER                 = BASE_ICODE + 25,
---
&gt;         Icode_SHORTNUMBER               = BASE_ICODE + 28,
&gt;         Icode_INTNUMBER                 = BASE_ICODE + 29,
97c111
&lt;         Icode_END                       = BASE_ICODE + 26;
---
&gt;         END_ICODE                       = BASE_ICODE + 30;
105c119
&lt;     public FunctionNode createFunctionNode(IRFactory irFactory, String name)
---
&gt;     public FunctionNode createFunctionNode(String name)
110c124
&lt;     public ScriptOrFnNode transform(Context cx, IRFactory irFactory,
---
&gt;     public ScriptOrFnNode transform(Context cx, TokenStream ts,
113c127
&lt;         (new NodeTransformer(irFactory)).transform(tree);
---
&gt;         (new NodeTransformer(ts)).transform(tree);
165a180,183
&gt;         if ((theFunction.getParamAndVarCount() &amp; ~0xFF) != 0) {
&gt;             // Can not optimize vars as their index should fit 1 byte
&gt;             itsData.itsNeedsActivation = true;
&gt;         }
184c202
&lt;         // add Icode_END only to scripts as function always ends with RETURN
---
&gt;         // add RETURN_POPV only to scripts as function always ends with RETURN
186c204
&lt;             theICodeTop = addIcode(Icode_END, theICodeTop);
---
&gt;             theICodeTop = addToken(Token.RETURN_POPV, theICodeTop);
304a323,325
&gt;         int savedStackDepth = itsStackDepth;
&gt;         int stackDelta = 0; // expected stack change for subtree code
&gt;         boolean stackShouldBeZero = false;
310a332
&gt;                     stackDelta = 1;
319a342,343
&gt;                 } else {
&gt;                     stackShouldBeZero = true;
324a349
&gt;                 stackShouldBeZero = true;
334c359
&lt;                 iCodeTop = updateLineNumber(node, iCodeTop);
---
&gt;                 // Skip case condition
336,341c361
&lt;                 while (child != null) {
&lt;                     iCodeTop = generateICode(child, iCodeTop);
&lt;                     child = child.getNext();
&lt;                 }
&lt;                 break;
&lt; 
---
&gt;                 // fallthrough
346a367,368
&gt;             case Token.WITH :
&gt;                 stackShouldBeZero = true;
354,355c376,386
&lt;             case Token.WITH :
&lt;                 ++itsWithDepth;
---
&gt;             case Token.LOCAL_BLOCK :
&gt;                 stackShouldBeZero = true;
&gt;                 if ((itsLocalTop &amp; ~0xFF) != 0) {
&gt;                     throw Context.reportRuntimeError(
&gt;                         "Program too complex (out of locals)");
&gt;                 }
&gt;                 node.putIntProp(Node.LOCAL_PROP, itsLocalTop);
&gt;                 ++itsLocalTop;
&gt;                 if (itsLocalTop &gt; itsData.itsMaxLocals) {
&gt;                     itsData.itsMaxLocals = itsLocalTop;
&gt;                 }
361c392
&lt;                 --itsWithDepth;
---
&gt;                 --itsLocalTop;
363a395,404
&gt;             case Token.LOCAL_LOAD : {
&gt;                 stackDelta = 1;
&gt;                 iCodeTop = addToken(Token.LOCAL_LOAD, iCodeTop);
&gt;                 iCodeTop = addLocalBlockRef(node, iCodeTop);
&gt;                 itsStackDepth++;
&gt;                 if (itsStackDepth &gt; itsData.itsMaxStack)
&gt;                     itsData.itsMaxStack = itsStackDepth;
&gt;                 break;
&gt;             }
&gt; 
364a406
&gt;                 stackDelta = 1;
366a409
&gt;                     if (1 != itsStackDepth - savedStackDepth) Kit.codeBug();
372a416,437
&gt;             case Token.INIT_LIST :
&gt;                 stackDelta = 1;
&gt;                 iCodeTop = generateICode(child, iCodeTop);
&gt;                 while (null != (child = child.getNext())) {
&gt;                     if (1 != itsStackDepth - savedStackDepth) Kit.codeBug();
&gt;                     iCodeTop = addIcode(Icode_DUP, iCodeTop);
&gt;                     // No stack adjusting: USE_STACK in subtree will do it
&gt;                     iCodeTop = generateICode(child, iCodeTop);
&gt;                     iCodeTop = addToken(Token.POP, iCodeTop);
&gt;                     itsStackDepth--;
&gt;                 }
&gt;                 break;
&gt; 
&gt;             case Token.USE_STACK:
&gt;                 // Indicates that stack was modified externally,
&gt;                 // like placed catch object
&gt;                 stackDelta = 1;
&gt;                 itsStackDepth++;
&gt;                 if (itsStackDepth &gt; itsData.itsMaxStack)
&gt;                     itsData.itsMaxStack = itsStackDepth;
&gt;                 break;
&gt; 
373a439
&gt;                 stackShouldBeZero = true;
377,381d442
&lt;                 int theLocalSlot = allocateLocal();
&lt;                 iCodeTop = addToken(Token.NEWTEMP, iCodeTop);
&lt;                 iCodeTop = addByte(theLocalSlot, iCodeTop);
&lt;                 iCodeTop = addToken(Token.POP, iCodeTop);
&lt;                 itsStackDepth--;
392,393c453
&lt;                     iCodeTop = addToken(Token.USETEMP, iCodeTop);
&lt;                     iCodeTop = addByte(theLocalSlot, iCodeTop);
---
&gt;                     iCodeTop = addIcode(Icode_DUPSECOND, iCodeTop);
401c461,464
&lt;                     iCodeTop = addGoto(target, Token.IFEQ, iCodeTop);
---
&gt;                     // If true, Icode_IFEQ_POP will jump and remove case value
&gt;                     // from stack
&gt;                     iCodeTop = addGoto(target, Icode_IFEQ_POP, iCodeTop);
&gt;                     itsStackDepth--;
402a466,467
&gt;                 iCodeTop = addToken(Token.POP, iCodeTop);
&gt;                 itsStackDepth--;
418a484
&gt;                 stackShouldBeZero = true;
424c490,497
&lt;                 int childCount = 0;
---
&gt;                 stackDelta = 1;
&gt;                 if (type == Token.NEW) {
&gt;                     iCodeTop = generateICode(child, iCodeTop);
&gt;                 } else {
&gt;                     iCodeTop = generateCallFunAndThis(child, iCodeTop);
&gt;                     if (itsStackDepth - savedStackDepth != 2)
&gt;                         Kit.codeBug();
&gt;                 }
426c499,506
&lt;                 while (child != null) {
---
&gt;                 int childType = child.getType();
&gt;                 if (childType == Token.NAME || childType == Token.GETPROP
&gt;                     || childType == Token.GETVAR)
&gt;                 {
&gt;                     functionName = lastAddString;
&gt;                 }
&gt;                 int argCount = 0;
&gt;                 while ((child = child.getNext()) != null) {
428,437c508
&lt;                     if (functionName == null) {
&lt;                         int childType = child.getType();
&lt;                         if (childType == Token.NAME
&lt;                             || childType == Token.GETPROP)
&lt;                         {
&lt;                             functionName = lastAddString;
&lt;                         }
&lt;                     }
&lt;                     child = child.getNext();
&lt;                     childCount++;
---
&gt;                     ++argCount;
451,453c522
&lt; 
&lt;                 itsStackDepth -= (childCount - 1);  // always a result value
&lt;                 // subtract from child count to account for [thisObj &amp;] fun
---
&gt;                 // adjust stack
455c524,525
&lt;                     childCount -= 1;
---
&gt;                     // f, args -&gt; results
&gt;                    itsStackDepth -= argCount;
457c527,528
&lt;                     childCount -= 2;
---
&gt;                     // f, thisObj, args -&gt; results
&gt;                    itsStackDepth -= (argCount + 1);
459,489c530,532
&lt;                 iCodeTop = addIndex(childCount, iCodeTop);
&lt;                 if (childCount &gt; itsData.itsMaxCalleeArgs)
&lt;                     itsData.itsMaxCalleeArgs = childCount;
&lt;                 break;
&lt;             }
&lt; 
&lt;             case Token.NEWLOCAL :
&lt;             case Token.NEWTEMP : {
&lt;                 iCodeTop = generateICode(child, iCodeTop);
&lt;                 iCodeTop = addToken(Token.NEWTEMP, iCodeTop);
&lt;                 iCodeTop = addLocalRef(node, iCodeTop);
&lt;                 break;
&lt;             }
&lt; 
&lt;             case Token.USELOCAL : {
&lt;                 iCodeTop = addToken(Token.USETEMP, iCodeTop);
&lt;                 itsStackDepth++;
&lt;                 if (itsStackDepth &gt; itsData.itsMaxStack)
&lt;                     itsData.itsMaxStack = itsStackDepth;
&lt;                 Node temp = (Node) node.getProp(Node.LOCAL_PROP);
&lt;                 iCodeTop = addLocalRef(temp, iCodeTop);
&lt;                 break;
&lt;             }
&lt; 
&lt;             case Token.USETEMP : {
&lt;                 iCodeTop = addToken(Token.USETEMP, iCodeTop);
&lt;                 Node temp = (Node) node.getProp(Node.TEMP_PROP);
&lt;                 iCodeTop = addLocalRef(temp, iCodeTop);
&lt;                 itsStackDepth++;
&lt;                 if (itsStackDepth &gt; itsData.itsMaxStack)
&lt;                     itsData.itsMaxStack = itsStackDepth;
---
&gt;                 iCodeTop = addIndex(argCount, iCodeTop);
&gt;                 if (argCount &gt; itsData.itsMaxCalleeArgs)
&gt;                     itsData.itsMaxCalleeArgs = argCount;
498a542
&gt;                 stackShouldBeZero = true;
504a549
&gt;                 stackShouldBeZero = true;
511,512c556,563
&lt;                 int finallyRegister = allocateLocal();
&lt;                 iCodeTop = addToken(Token.NEWTEMP, iCodeTop);
---
&gt;                 stackShouldBeZero = true;
&gt;                 // Account for incomming exception or GOTOSUB address
&gt;                 ++itsStackDepth;
&gt;                 if (itsStackDepth &gt; itsData.itsMaxStack)
&gt;                     itsData.itsMaxStack = itsStackDepth;
&gt; 
&gt;                 int finallyRegister = getLocalBlockRef(node);
&gt;                 iCodeTop = addToken(Token.LOCAL_SAVE, iCodeTop);
514d564
&lt;                 iCodeTop = addToken(Token.POP, iCodeTop);
517a568
&gt;                     if (itsStackDepth != 0) Kit.codeBug();
522d572
&lt;                 releaseLocal(finallyRegister);
526c576,578
&lt;             case Token.AND : {
---
&gt;             case Token.AND :
&gt;             case Token.OR : {
&gt;                 stackDelta = 1;
532,533c584,587
&lt;                 int falseJumpStart = iCodeTop;
&lt;                 iCodeTop = addForwardGoto(Token.IFNE, iCodeTop);
---
&gt;                 int afterSecondJumpStart = iCodeTop;
&gt;                 int jump = (type == Token.AND) ? Token.IFNE : Token.IFEQ;
&gt;                 iCodeTop = addForwardGoto(jump, iCodeTop);
&gt;                 itsStackDepth--;
538c592
&lt;                 resolveForwardGoto(falseJumpStart, iCodeTop);
---
&gt;                 resolveForwardGoto(afterSecondJumpStart, iCodeTop);
542c596,599
&lt;             case Token.OR : {
---
&gt;             case Token.HOOK : {
&gt;                 stackDelta = 1;
&gt;                 Node ifThen = child.getNext();
&gt;                 Node ifElse = ifThen.getNext();
544,550c601,602
&lt;                 iCodeTop = addIcode(Icode_DUP, iCodeTop);
&lt;                 itsStackDepth++;
&lt;                 if (itsStackDepth &gt; itsData.itsMaxStack)
&lt;                     itsData.itsMaxStack = itsStackDepth;
&lt;                 int trueJumpStart = iCodeTop;
&lt;                 iCodeTop = addForwardGoto(Token.IFEQ, iCodeTop);
&lt;                 iCodeTop = addToken(Token.POP, iCodeTop);
---
&gt;                 int elseJumpStart = iCodeTop;
&gt;                 iCodeTop = addForwardGoto(Token.IFNE, iCodeTop);
552,554c604,610
&lt;                 child = child.getNext();
&lt;                 iCodeTop = generateICode(child, iCodeTop);
&lt;                 resolveForwardGoto(trueJumpStart, iCodeTop);
---
&gt;                 iCodeTop = generateICode(ifThen, iCodeTop);
&gt;                 int afterElseJumpStart = iCodeTop;
&gt;                 iCodeTop = addForwardGoto(Token.GOTO, iCodeTop);
&gt;                 resolveForwardGoto(elseJumpStart, iCodeTop);
&gt;                 itsStackDepth = savedStackDepth;
&gt;                 iCodeTop = generateICode(ifElse, iCodeTop);
&gt;                 resolveForwardGoto(afterElseJumpStart, iCodeTop);
558a615
&gt;                 stackDelta = 1;
600a658
&gt;                 stackDelta = 1;
613a672
&gt;                 stackDelta = 1;
623c682,684
&lt;             case Token.SETPROP : {
---
&gt;             case Token.SETPROP :
&gt;             case Token.SETPROP_OP : {
&gt;                 stackDelta = 1;
626d686
&lt;                 iCodeTop = generateICode(child, iCodeTop);
628a689,703
&gt;                     if (type == Token.SETPROP_OP) {
&gt;                         iCodeTop = addIcode(Icode_DUP, iCodeTop);
&gt;                         if (itsStackDepth &gt; itsData.itsMaxStack)
&gt;                             itsData.itsMaxStack = itsStackDepth;
&gt;                         if (special == Node.SPECIAL_PROP_PROTO) {
&gt;                             iCodeTop = addIcode(Icode_GETPROTO, iCodeTop);
&gt;                         } else if (special == Node.SPECIAL_PROP_PARENT) {
&gt;                             iCodeTop = addIcode(Icode_GETSCOPEPARENT, iCodeTop);
&gt;                         } else {
&gt;                             badTree(node);
&gt;                         }
&gt;                         // Compensate for the following USE_STACK
&gt;                         itsStackDepth--;
&gt;                     }
&gt;                     iCodeTop = generateICode(child, iCodeTop);
635a711
&gt;                     itsStackDepth--;
636a713
&gt;                     iCodeTop = generateICode(child, iCodeTop);
637a715,725
&gt;                     if (type == Token.SETPROP_OP) {
&gt;                         iCodeTop = addIcode(Icode_DUPSECOND, iCodeTop);
&gt;                         iCodeTop = addIcode(Icode_DUPSECOND, iCodeTop);
&gt;                         itsStackDepth += 2;
&gt;                         if (itsStackDepth &gt; itsData.itsMaxStack)
&gt;                             itsData.itsMaxStack = itsStackDepth;
&gt;                         iCodeTop = addToken(Token.GETPROP, iCodeTop);
&gt;                         itsStackDepth--;
&gt;                         // Compensate for the following USE_STACK
&gt;                         itsStackDepth--;
&gt;                     }
645a734,735
&gt;             case Token.SETELEM_OP :
&gt;                 stackDelta = 1;
649a740,750
&gt;                 if (type == Token.SETELEM_OP) {
&gt;                     iCodeTop = addIcode(Icode_DUPSECOND, iCodeTop);
&gt;                     iCodeTop = addIcode(Icode_DUPSECOND, iCodeTop);
&gt;                     itsStackDepth += 2;
&gt;                     if (itsStackDepth &gt; itsData.itsMaxStack)
&gt;                         itsData.itsMaxStack = itsStackDepth;
&gt;                     iCodeTop = addToken(Token.GETELEM, iCodeTop);
&gt;                     itsStackDepth--;
&gt;                     // Compensate for the following USE_STACK
&gt;                     itsStackDepth--;
&gt;                 }
655a757
&gt;                 stackDelta = 1;
664a767
&gt;                 stackDelta = 1;
685,689d787
&lt;             case Token.PARENT :
&lt;                 iCodeTop = generateICode(child, iCodeTop);
&lt;                 iCodeTop = addIcode(Icode_GETPARENT, iCodeTop);
&lt;                 break;
&lt; 
693a792
&gt;                 stackDelta = 1;
702a802
&gt;                 stackDelta = 1;
765a866
&gt;                 stackDelta = 1;
794d894
&lt;             case Token.POP :
795a896,898
&gt;                 stackShouldBeZero = true;
&gt;                 // fallthrough
&gt;             case Token.POP :
802a906
&gt;                 stackShouldBeZero = true;
808c912,913
&lt;             case Token.GETTHIS :
---
&gt;             case Token.CATCH_SCOPE :
&gt;                 stackDelta = 1;
810,817c915,916
&lt;                 iCodeTop = addToken(Token.GETTHIS, iCodeTop);
&lt;                 break;
&lt; 
&lt;             case Token.NEWSCOPE :
&lt;                 iCodeTop = addToken(Token.NEWSCOPE, iCodeTop);
&lt;                 itsStackDepth++;
&lt;                 if (itsStackDepth &gt; itsData.itsMaxStack)
&lt;                     itsData.itsMaxStack = itsStackDepth;
---
&gt;                 iCodeTop = addToken(Token.CATCH_SCOPE, iCodeTop);
&gt;                 iCodeTop = addString(node.getString(), iCodeTop);
820a920
&gt;                 stackShouldBeZero = true;
824a925
&gt;                 stackShouldBeZero = true;
825a927
&gt;                 int exceptionObjectLocal = getLocalBlockRef(tryNode);
845,849d946
&lt;                         // Catch code has exception object on the stack
&lt;                         itsStackDepth = 1;
&lt;                         if (itsStackDepth &gt; itsData.itsMaxStack)
&lt;                             itsData.itsMaxStack = itsStackDepth;
&lt; 
858,866d954
&lt; 
&lt;                         // Adjust stack for finally code: on the top of the
&lt;                         // stack it has either a PC value  when called from
&lt;                         // GOSUB or exception object to rethrow when called
&lt;                         // from exception handler
&lt;                         itsStackDepth = 1;
&lt;                         if (itsStackDepth &gt; itsData.itsMaxStack) {
&lt;                             itsData.itsMaxStack = itsStackDepth;
&lt;                         }
874d961
&lt;                 itsStackDepth = 0;
886c973
&lt;                                     itsWithDepth);
---
&gt;                                     itsWithDepth, exceptionObjectLocal);
890a978
&gt;                 stackShouldBeZero = true;
898a987
&gt;                 stackShouldBeZero = true;
908a998,1003
&gt;             case Token.RETURN_POPV :
&gt;                 stackShouldBeZero = true;
&gt;                 iCodeTop = updateLineNumber(node, iCodeTop);
&gt;                 iCodeTop = addToken(Token.RETURN_POPV, iCodeTop);
&gt;                 break;
&gt; 
909a1005
&gt;                 stackDelta = 1;
935a1032
&gt;                 stackDelta = 1;
956a1054
&gt;                 stackDelta = 1;
963c1061,1062
&lt;             case Token.ENUMINIT :
---
&gt;             case Token.ENUM_INIT :
&gt;                 stackShouldBeZero = true;
965,966c1064,1065
&lt;                 iCodeTop = addToken(Token.ENUMINIT, iCodeTop);
&lt;                 iCodeTop = addLocalRef(node, iCodeTop);
---
&gt;                 iCodeTop = addToken(Token.ENUM_INIT, iCodeTop);
&gt;                 iCodeTop = addLocalBlockRef(node, iCodeTop);
970,973c1069,1073
&lt;             case Token.ENUMNEXT : {
&lt;                 iCodeTop = addToken(Token.ENUMNEXT, iCodeTop);
&lt;                 Node init = (Node)node.getProp(Node.ENUM_PROP);
&lt;                 iCodeTop = addLocalRef(init, iCodeTop);
---
&gt;             case Token.ENUM_NEXT :
&gt;             case Token.ENUM_ID : {
&gt;                 stackDelta = 1;
&gt;                 iCodeTop = addToken(type, iCodeTop);
&gt;                 iCodeTop = addLocalBlockRef(node, iCodeTop);
980,983d1079
&lt;             case Token.ENUMDONE :
&lt;                 // could release the local here??
&lt;                 break;
&lt; 
984a1081
&gt;                 stackDelta = 1;
997a1095,1102
&gt;         if (stackDelta != itsStackDepth - savedStackDepth) {
&gt;             //System.out.println("Bad stack delta: type="+Token.name(type)+" expected="+stackDelta+" real="+ (itsStackDepth - savedStackDepth));
&gt;             Kit.codeBug();
&gt;         }
&gt;         if (stackShouldBeZero &amp;&amp; !(stackDelta == 0 &amp;&amp; itsStackDepth == 0)) {
&gt;             Kit.codeBug();
&gt;         }
&gt; 
1001c1106
&lt;     private int addLocalRef(Node node, int iCodeTop)
---
&gt;     private int generateCallFunAndThis(Node left, int iCodeTop)
1003,1006c1108,1136
&lt;         int theLocalSlot = node.getIntProp(Node.LOCAL_PROP, -1);
&lt;         if (theLocalSlot == -1) {
&lt;             theLocalSlot = allocateLocal();
&lt;             node.putIntProp(Node.LOCAL_PROP, theLocalSlot);
---
&gt;         // Generate code to place on stack function and thisObj
&gt;         int type = left.getType();
&gt;         if (type == Token.NAME) {
&gt;             String name = left.getString();
&gt;             iCodeTop = addIcode(Icode_NAME_AND_THIS, iCodeTop);
&gt;             iCodeTop = addString(name, iCodeTop);
&gt;             itsStackDepth += 2;
&gt;             if (itsStackDepth &gt; itsData.itsMaxStack)
&gt;                 itsData.itsMaxStack = itsStackDepth;
&gt;         } else if (type == Token.GETPROP || type == Token.GETELEM) {
&gt;             // For Call(GetProp(a, b), c, d) or Call(GetElem(a, b), c, d)
&gt;             // generate code to calculate a, dup it, calculate
&gt;             // GetProp(use_stack, b) or GetElem(use_stack, b),
&gt;             // and swap to get function, thisObj layout
&gt;             Node leftLeft = left.getFirstChild();
&gt;             left.removeChild(leftLeft);
&gt;             left.addChildToFront(new Node(Token.USE_STACK));
&gt;             iCodeTop = generateICode(leftLeft, iCodeTop);
&gt;             iCodeTop = addIcode(Icode_DUP, iCodeTop);
&gt;             // No stack adjusting: USE_STACK in subtree will do it
&gt;             iCodeTop = generateICode(left, iCodeTop);
&gt;             iCodeTop = addIcode(Icode_SWAP, iCodeTop);
&gt;         } else {
&gt;             // Including Token.GETVAR
&gt;             iCodeTop = generateICode(left, iCodeTop);
&gt;             iCodeTop = addIcode(Icode_PUSH_PARENT, iCodeTop);
&gt;             itsStackDepth += 1;
&gt;             if (itsStackDepth &gt; itsData.itsMaxStack)
&gt;                 itsData.itsMaxStack = itsStackDepth;
1008d1137
&lt;         iCodeTop = addByte(theLocalSlot, iCodeTop);
1012c1141
&lt;     private int allocateLocal()
---
&gt;     private int getLocalBlockRef(Node node)
1014c1143,1144
&lt;          return itsData.itsMaxLocals++;
---
&gt;         Node localBlock = (Node)node.getProp(Node.LOCAL_BLOCK_PROP);
&gt;         return localBlock.getExistingIntProp(Node.LOCAL_PROP);
1017c1147
&lt;     private void releaseLocal(int local)
---
&gt;     private int addLocalBlockRef(Node node, int iCodeTop)
1018a1149,1151
&gt;         int localSlot = getLocalBlockRef(node);
&gt;         iCodeTop = addByte(localSlot, iCodeTop);
&gt;         return iCodeTop;
1082c1215
&lt;     private int addByte(int b, int iCodeTop)
---
&gt;     private int addByte(int value, int iCodeTop)
1088c1221
&lt;         array[iCodeTop++] = (byte)b;
---
&gt;         array[iCodeTop++] = (byte)value;
1104c1237
&lt;         if (!(BASE_ICODE &lt; icode &amp;&amp; icode &lt;= Icode_END)) Kit.codeBug();
---
&gt;         if (!(BASE_ICODE &lt; icode &amp;&amp; icode &lt; END_ICODE)) Kit.codeBug();
1178c1311
&lt;                                      int withDepth)
---
&gt;                                      int withDepth, int exceptionObjectLocal)
1195a1329
&gt;         table[top + EXCEPTION_LOCAL_SLOT]      = exceptionObjectLocal;
1259,1284c1393,1421
&lt;                     case Icode_DUP:              return "dup";
&lt;                     case Icode_NAMEINC:          return "nameinc";
&lt;                     case Icode_PROPINC:          return "propinc";
&lt;                     case Icode_ELEMINC:          return "eleminc";
&lt;                     case Icode_VARINC:           return "varinc";
&lt;                     case Icode_NAMEDEC:          return "namedec";
&lt;                     case Icode_PROPDEC:          return "propdec";
&lt;                     case Icode_ELEMDEC:          return "elemdec";
&lt;                     case Icode_VARDEC:           return "vardec";
&lt;                     case Icode_SCOPE:            return "scope";
&lt;                     case Icode_TYPEOFNAME:       return "typeofname";
&lt;                     case Icode_GETPROTO:         return "getproto";
&lt;                     case Icode_GETPARENT:        return "getparent";
&lt;                     case Icode_GETSCOPEPARENT:   return "getscopeparent";
&lt;                     case Icode_SETPROTO:         return "setproto";
&lt;                     case Icode_SETPARENT:        return "setparent";
&lt;                     case Icode_CLOSURE:          return "closure";
&lt;                     case Icode_CALLSPECIAL:      return "callspecial";
&lt;                     case Icode_RETUNDEF:         return "retundef";
&lt;                     case Icode_CATCH:            return "catch";
&lt;                     case Icode_GOSUB:            return "gosub";
&lt;                     case Icode_RETSUB:           return "retsub";
&lt;                     case Icode_LINE:             return "line";
&lt;                     case Icode_SHORTNUMBER:      return "shortnumber";
&lt;                     case Icode_INTNUMBER:        return "intnumber";
&lt;                     case Icode_END:              return "end";
---
&gt;                     case Icode_DUP:              return "DUP";
&gt;                     case Icode_DUPSECOND:        return "DUPSECOND";
&gt;                     case Icode_SWAP:             return "SWAP";
&gt;                     case Icode_IFEQ_POP:         return "IFEQ_POP";
&gt;                     case Icode_NAMEINC:          return "NAMEINC";
&gt;                     case Icode_PROPINC:          return "PROPINC";
&gt;                     case Icode_ELEMINC:          return "ELEMINC";
&gt;                     case Icode_VARINC:           return "VARINC";
&gt;                     case Icode_NAMEDEC:          return "NAMEDEC";
&gt;                     case Icode_PROPDEC:          return "PROPDEC";
&gt;                     case Icode_ELEMDEC:          return "ELEMDEC";
&gt;                     case Icode_VARDEC:           return "VARDEC";
&gt;                     case Icode_SCOPE:            return "SCOPE";
&gt;                     case Icode_TYPEOFNAME:       return "TYPEOFNAME";
&gt;                     case Icode_NAME_AND_THIS:    return "NAME_AND_THIS";
&gt;                     case Icode_GETPROTO:         return "GETPROTO";
&gt;                     case Icode_PUSH_PARENT:      return "PUSH_PARENT";
&gt;                     case Icode_GETSCOPEPARENT:   return "GETSCOPEPARENT";
&gt;                     case Icode_SETPROTO:         return "SETPROTO";
&gt;                     case Icode_SETPARENT:        return "SETPARENT";
&gt;                     case Icode_CLOSURE:          return "CLOSURE";
&gt;                     case Icode_CALLSPECIAL:      return "CALLSPECIAL";
&gt;                     case Icode_RETUNDEF:         return "RETUNDEF";
&gt;                     case Icode_CATCH:            return "CATCH";
&gt;                     case Icode_GOSUB:            return "GOSUB";
&gt;                     case Icode_RETSUB:           return "RETSUB";
&gt;                     case Icode_LINE:             return "LINE";
&gt;                     case Icode_SHORTNUMBER:      return "SHORTNUMBER";
&gt;                     case Icode_INTNUMBER:        return "INTNUMBER";
1306c1443
&lt;                 int token = iCode[pc] &amp; 0xff;
---
&gt;                 int token = iCode[pc] &amp; 0xFF;
1320c1457,1458
&lt;                     case Token.IFNE : {
---
&gt;                     case Token.IFNE :
&gt;                     case Icode_IFEQ_POP : {
1327,1328c1465,1467
&lt;                     case Token.ENUMINIT :
&lt;                     case Token.ENUMNEXT :
---
&gt;                     case Token.ENUM_INIT :
&gt;                     case Token.ENUM_NEXT :
&gt;                     case Token.ENUM_ID :
1333,1334c1472,1473
&lt;                     case Token.NEWTEMP :
&lt;                     case Token.USETEMP : {
---
&gt;                     case Token.LOCAL_SAVE :
&gt;                     case Token.LOCAL_LOAD : {
1371a1511,1516
&gt;                     case Token.THROW : {
&gt;                         int line = getShort(iCode, pc);
&gt;                         out.println(tname + " : " + line);
&gt;                         pc += 2;
&gt;                         break;
&gt;                     }
1390a1536
&gt;                     case Token.CATCH_SCOPE :
1391a1538
&gt;                     case Icode_NAME_AND_THIS :
1421,1429c1568,1579
&lt;                     int tryStart     = table[i + EXCEPTION_TRY_START_SLOT];
&lt;                     int tryEnd       = table[i + EXCEPTION_TRY_END_SLOT];
&lt;                     int catchStart   = table[i + EXCEPTION_CATCH_SLOT];
&lt;                     int finallyStart = table[i + EXCEPTION_FINALLY_SLOT];
&lt;                     int withDepth    = table[i + EXCEPTION_WITH_DEPTH_SLOT];
&lt; 
&lt;                     out.println(" "+tryStart+"\t "+tryEnd+"\t "
&lt;                                 +catchStart+"\t "+finallyStart
&lt;                                 +"\t "+withDepth);
---
&gt;                     int tryStart       = table[i + EXCEPTION_TRY_START_SLOT];
&gt;                     int tryEnd         = table[i + EXCEPTION_TRY_END_SLOT];
&gt;                     int catchStart     = table[i + EXCEPTION_CATCH_SLOT];
&gt;                     int finallyStart   = table[i + EXCEPTION_FINALLY_SLOT];
&gt;                     int withDepth      = table[i + EXCEPTION_WITH_DEPTH_SLOT];
&gt;                     int exceptionLocal = table[i + EXCEPTION_LOCAL_SLOT];
&gt; 
&gt;                     out.println(" tryStart="+tryStart+" tryEnd="+tryEnd
&gt;                                 +" catchStart="+catchStart
&gt;                                 +" finallyStart="+finallyStart
&gt;                                 +" withDepth="+withDepth
&gt;                                 +" exceptionLocal="+exceptionLocal);
1440c1590
&lt;             case Icode_GETPARENT :
---
&gt;             case Icode_PUSH_PARENT :
1446d1595
&lt;             case Token.NEWSCOPE :
1450c1599
&lt;             case Token.GETTHIS :
---
&gt;             case Token.RETURN_POPV :
1476a1626,1627
&gt;             case Icode_DUPSECOND :
&gt;             case Icode_SWAP :
1497d1647
&lt;             case Icode_END:
1507a1658
&gt;             case Icode_IFEQ_POP :
1512,1513c1663,1665
&lt;             case Token.ENUMINIT :
&lt;             case Token.ENUMNEXT :
---
&gt;             case Token.ENUM_INIT :
&gt;             case Token.ENUM_NEXT :
&gt;             case Token.ENUM_ID :
1518,1519c1670,1671
&lt;             case Token.NEWTEMP :
&lt;             case Token.USETEMP :
---
&gt;             case Token.LOCAL_SAVE :
&gt;             case Token.LOCAL_LOAD :
1555a1708
&gt;             case Token.CATCH_SCOPE :
1556a1710
&gt;             case Icode_NAME_AND_THIS :
1584c1738
&lt;             int icodeToken = iCode[pc] &amp; 0xff;
---
&gt;             int icodeToken = iCode[pc] &amp; 0xFF;
1787c1941
&lt;                 switch (iCode[pc] &amp; 0xff) {
---
&gt;                 switch (iCode[pc] &amp; 0xFF) {
1860,1861d2013
&lt;         // make stack to contain single exception object
&lt;         stackTop = STACK_SHFT;
1863,1864c2015,2019
&lt;             stack[stackTop] = ScriptRuntime.getCatchObject(cx, scope,
&lt;                                                            javaException);
---
&gt;             stackTop = STACK_SHFT - 1;
&gt;             int exLocal = idata.itsExceptionTable[
&gt;                               handlerOffset + EXCEPTION_LOCAL_SLOT];
&gt;             stack[LOCAL_SHFT + exLocal] = ScriptRuntime.getCatchObject(
&gt;                                               cx, scope, javaException);
1865a2021
&gt;             stackTop = STACK_SHFT;
2043a2200,2217
&gt;     case Icode_IFEQ_POP : {
&gt;         boolean valBln = stack_boolean(stack, sDbl, stackTop);
&gt;         --stackTop;
&gt;         if (valBln) {
&gt;             if (instructionThreshold != 0) {
&gt;                 instructionCount += pc + 3 - pcPrevBranch;
&gt;                 if (instructionCount &gt; instructionThreshold) {
&gt;                     cx.observeInstructionCount(instructionCount);
&gt;                     instructionCount = 0;
&gt;                 }
&gt;             }
&gt;             pcPrevBranch = pc = getTarget(iCode, pc + 1);
&gt;             stack[stackTop--] = null;
&gt;             continue Loop;
&gt;         }
&gt;         pc += 2;
&gt;         break;
&gt;     }
2097a2272,2286
&gt;     case Icode_DUPSECOND : {
&gt;         stack[stackTop + 1] = stack[stackTop - 1];
&gt;         sDbl[stackTop + 1] = sDbl[stackTop - 1];
&gt;         stackTop++;
&gt;         break;
&gt;     }
&gt;     case Icode_SWAP : {
&gt;         Object o = stack[stackTop];
&gt;         stack[stackTop] = stack[stackTop - 1];
&gt;         stack[stackTop - 1] = o;
&gt;         double d = sDbl[stackTop];
&gt;         sDbl[stackTop] = sDbl[stackTop - 1];
&gt;         sDbl[stackTop - 1] = d;
&gt;         break;
&gt;     }
2108a2298,2299
&gt;     case Token.RETURN_POPV :
&gt;         break Loop;
2112,2113d2302
&lt;     case Icode_END:
&lt;         break Loop;
2314,2319c2503
&lt;     case Token.GETTHIS : {
&lt;         Scriptable lhs = (Scriptable)stack[stackTop];
&lt;         stack[stackTop] = ScriptRuntime.getThis(lhs);
&lt;         break;
&lt;     }
&lt;     case Token.NEWTEMP : {
---
&gt;     case Token.LOCAL_SAVE : {
2322a2507
&gt;         --stackTop;
2325c2510
&lt;     case Token.USETEMP : {
---
&gt;     case Token.LOCAL_LOAD : {
2377d2561
&lt; 
2471a2656,2663
&gt;     case Icode_NAME_AND_THIS : {
&gt;         String name = strings[getIndex(iCode, pc + 1)];
&gt;         Scriptable base = ScriptRuntime.getBase(scope, name);
&gt;         stack[++stackTop] = ScriptRuntime.getProp(base, name, scope);
&gt;         stack[++stackTop] = ScriptRuntime.getThis(base);
&gt;         pc += 2;
&gt;         break;
&gt;     }
2607,2608c2799,2802
&lt;     case Token.NEWSCOPE :
&lt;         stack[++stackTop] = ScriptRuntime.newScope();
---
&gt;     case Token.CATCH_SCOPE : {
&gt;         String name = strings[getIndex(iCode, pc + 1)];
&gt;         stack[stackTop] = ScriptRuntime.newCatchScope(name, stack[stackTop]);
&gt;         pc += 2;
2610c2804,2805
&lt;     case Token.ENUMINIT : {
---
&gt;     }
&gt;     case Token.ENUM_INIT : {
2615c2810
&lt;         stack[LOCAL_SHFT + slot] = ScriptRuntime.initEnum(lhs, scope);
---
&gt;         stack[LOCAL_SHFT + slot] = ScriptRuntime.enumInit(lhs, scope);
2618c2813,2814
&lt;     case Token.ENUMNEXT : {
---
&gt;     case Token.ENUM_NEXT :
&gt;     case Token.ENUM_ID : {
2622c2818,2820
&lt;         stack[stackTop] = ScriptRuntime.nextEnum(val);
---
&gt;         stack[stackTop] = ((iCode[pc - 1] &amp; 0xFF) == Token.ENUM_NEXT)
&gt;                           ? (Object)ScriptRuntime.enumNext(val)
&gt;                           : (Object)ScriptRuntime.enumId(val);
2631c2829
&lt;     case Icode_GETPARENT : {
---
&gt;     case Icode_PUSH_PARENT : {
2634c2832
&lt;         stack[stackTop] = ScriptRuntime.getParent(lhs);
---
&gt;         stack[++stackTop] = ScriptRuntime.getParent(lhs);
2699c2897
&lt;             ("Unknown icode : "+(iCode[pc] &amp; 0xff)+" @ pc : "+pc);
---
&gt;             ("Unknown icode : "+(iCode[pc] &amp; 0xFF)+" @ pc : "+pc);
3052a3251
&gt;     private int itsLocalTop;
3054,3055c3253
&lt;     private int itsExceptionTableTop = 0;
&lt; 
---
&gt;     private int itsExceptionTableTop;
3057c3255
&lt;     private static final int EXCEPTION_SLOT_SIZE       = 5;
---
&gt;     private static final int EXCEPTION_SLOT_SIZE       = 6;
3062a3261
&gt;     private static final int EXCEPTION_LOCAL_SLOT      = 5;
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/optimizer/OptTransformer.java" revision="1.22" state="changed">51c51
&lt;     OptTransformer(IRFactory irFactory, Hashtable possibleDirectCalls,
---
&gt;     OptTransformer(TokenStream ts, Hashtable possibleDirectCalls,
54c54
&lt;         super(irFactory);
---
&gt;         super(ts);
59,63d58
&lt;     protected NodeTransformer newInstance() {
&lt;         return new OptTransformer(irFactory, possibleDirectCalls,
&lt;                                   directCallTargets);
&lt;     }
&lt; 
70a66,138
&gt; 
&gt;         /*
&gt;          * For
&gt;          *      Call(GetProp(a, b), c, d)   // or GetElem...
&gt;          * we wish to evaluate as
&gt;          *      Call(GetProp(tmp=a, b), tmp, c, d)
&gt;          *
&gt;          * for
&gt;          *      Call(Name("a"), b, c)
&gt;          * we wish to evaluate as
&gt;          *      Call(GetProp(tmp=GetBase("a"), "a"), tmp, b, c)
&gt;          *
&gt;          * and for
&gt;          *      Call(a, b, c);
&gt;          * we wish to evaluate as
&gt;          *      Call(tmp=a, Parent(tmp), c, d)
&gt;          */
&gt;         Node left = node.getFirstChild();
&gt;         boolean addGetThis = false;
&gt;         if (left.getType() == Token.NAME) {
&gt;             String name = left.getString();
&gt;             boolean inFunction = (tree.getType() == Token.FUNCTION);
&gt;             if (inFunction &amp;&amp; tree.hasParamOrVar(name)
&gt;                 &amp;&amp; !inWithStatement())
&gt;             {
&gt;                 // call to a var. Transform to Call(GetVar("a"), b, c)
&gt;                 left.setType(Token.GETVAR);
&gt;                 // fall through to code to add GetParent
&gt;             } else {
&gt;                 // transform to Call(GetProp(GetBase("a"), "a"), b, c)
&gt; 
&gt;                 node.removeChild(left);
&gt;                 left.setType(Token.GETBASE);
&gt;                 Node str = Node.newString(left.getString());
&gt;                 Node getProp = new Node(Token.GETPROP, left, str);
&gt;                 node.addChildToFront(getProp);
&gt;                 left = getProp;
&gt; 
&gt;                 // Conditionally set a flag to add a GETTHIS node.
&gt;                 // The getThis entry in the runtime will take a
&gt;                 // Scriptable object intended to be used as a 'this'
&gt;                 // and make sure that it is neither a With object or
&gt;                 // an activation object.
&gt;                 // Executing getThis requires at least two instanceof
&gt;                 // tests, so we only include it if we are currently
&gt;                 // inside a 'with' statement, or if we are executing
&gt;                 // a script (to protect against an eval inside a with).
&gt;                 addGetThis = inWithStatement() || !inFunction;
&gt;                 // fall through to GETPROP code
&gt;             }
&gt;         }
&gt;         if (left.getType() != Token.GETPROP &amp;&amp;
&gt;             left.getType() != Token.GETELEM)
&gt;         {
&gt;             node.removeChild(left);
&gt;             Node tmp = createNewTemp(left);
&gt;             Node use = createUseTemp(tmp);
&gt;             use.putProp(Node.TEMP_PROP, tmp);
&gt;             Node parent = new Node(Token.PARENT, use);
&gt;             node.addChildToFront(parent);
&gt;             node.addChildToFront(tmp);
&gt;             return;
&gt;         }
&gt;         Node leftLeft = left.getFirstChild();
&gt;         left.removeChild(leftLeft);
&gt;         Node tmp = createNewTemp(leftLeft);
&gt;         left.addChildToFront(tmp);
&gt;         Node use = createUseTemp(tmp);
&gt;         use.putProp(Node.TEMP_PROP, tmp);
&gt;         if (addGetThis)
&gt;             use = new Node(Token.GETTHIS, use);
&gt;         node.addChildAfter(use, left);
&gt; 
130a199,229
&gt;     static Node createNewTemp(Node n) {
&gt;         int type = n.getType();
&gt;         if (type == Token.STRING || type == Token.NUMBER) {
&gt;             // Optimization: clone these values rather than storing
&gt;             // and loading from a temp
&gt;             return n;
&gt;         }
&gt;         return new Node(Token.NEWTEMP, n);
&gt;     }
&gt; 
&gt;     static Node createUseTemp(Node newTemp)
&gt;     {
&gt;         switch (newTemp.getType()) {
&gt;           case Token.NEWTEMP: {
&gt;             Node result = new Node(Token.USETEMP);
&gt;             result.putProp(Node.TEMP_PROP, newTemp);
&gt;             int n = newTemp.getIntProp(Node.USES_PROP, 0);
&gt;             if (n != Integer.MAX_VALUE) {
&gt;                 newTemp.putIntProp(Node.USES_PROP, n + 1);
&gt;             }
&gt;             return result;
&gt;           }
&gt;           case Token.STRING:
&gt;             return Node.newString(newTemp.getString());
&gt;           case Token.NUMBER:
&gt;             return Node.newNumber(newTemp.getDouble());
&gt;           default:
&gt;             throw Kit.codeBug();
&gt;         }
&gt;     }
&gt; 
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/Token.java" revision="1.15" state="changed">131,140c131,140
&lt;         GETTHIS     = 56,
&lt;         NEWTEMP     = 57,
&lt;         USETEMP     = 58,
&lt;         GETBASE     = 59,
&lt;         GETVAR      = 60,
&lt;         SETVAR      = 61,
&lt;         UNDEFINED   = 62,
&lt;         NEWSCOPE    = 63,
&lt;         ENUMINIT    = 64,
&lt;         ENUMNEXT    = 65,
---
&gt;         LOCAL_SAVE  = 56,
&gt;         LOCAL_LOAD  = 57,
&gt;         GETBASE     = 58,
&gt;         GETVAR      = 59,
&gt;         SETVAR      = 60,
&gt;         UNDEFINED   = 61,
&gt;         CATCH_SCOPE = 62,
&gt;         ENUM_INIT   = 63,
&gt;         ENUM_NEXT   = 64,
&gt;         ENUM_ID     = 65,
141a142
&gt;         RETURN_POPV = 67, // to return result stored as popv in functions
143c144
&lt;         LAST_BYTECODE_TOKEN = 66,
---
&gt;         LAST_BYTECODE_TOKEN = 67,
146,182c147,184
&lt;         TRY         = 67,
&lt;         SEMI        = 68,  // semicolon
&lt;         LB          = 69,  // left and right brackets
&lt;         RB          = 70,
&lt;         LC          = 71,  // left and right curlies (braces)
&lt;         RC          = 72,
&lt;         LP          = 73,  // left and right parentheses
&lt;         RP          = 74,
&lt;         COMMA       = 75,  // comma operator
&lt;         ASSIGN      = 76, // simple assignment  (=)
&lt;         ASSIGNOP    = 77, // assignment with operation (+= -= etc.)
&lt;         HOOK        = 78, // conditional (?:)
&lt;         COLON       = 79,
&lt;         OR          = 80, // logical or (||)
&lt;         AND         = 81, // logical and (&amp;&amp;)
&lt;         INC         = 82, // increment/decrement (++ --)
&lt;         DEC         = 83,
&lt;         DOT         = 84, // member operator (.)
&lt;         FUNCTION    = 85, // function keyword
&lt;         EXPORT      = 86, // export keyword
&lt;         IMPORT      = 87, // import keyword
&lt;         IF          = 88, // if keyword
&lt;         ELSE        = 89, // else keyword
&lt;         SWITCH      = 90, // switch keyword
&lt;         CASE        = 91, // case keyword
&lt;         DEFAULT     = 92, // default keyword
&lt;         WHILE       = 93, // while keyword
&lt;         DO          = 94, // do keyword
&lt;         FOR         = 95, // for keyword
&lt;         BREAK       = 96, // break keyword
&lt;         CONTINUE    = 97, // continue keyword
&lt;         VAR         = 98, // var keyword
&lt;         WITH        = 99, // with keyword
&lt;         CATCH       = 100, // catch keyword
&lt;         FINALLY     = 101, // finally keyword
&lt;         VOID        = 102, // void keyword
&lt;         RESERVED    = 103, // reserved keywords
---
&gt;         GETTHIS     = 68,
&gt;         TRY         = 69,
&gt;         SEMI        = 70,  // semicolon
&gt;         LB          = 71,  // left and right brackets
&gt;         RB          = 72,
&gt;         LC          = 73,  // left and right curlies (braces)
&gt;         RC          = 74,
&gt;         LP          = 75,  // left and right parentheses
&gt;         RP          = 76,
&gt;         COMMA       = 77,  // comma operator
&gt;         ASSIGN      = 78, // simple assignment  (=)
&gt;         ASSIGNOP    = 79, // assignment with operation (+= -= etc.)
&gt;         HOOK        = 80, // conditional (?:)
&gt;         COLON       = 81,
&gt;         OR          = 82, // logical or (||)
&gt;         AND         = 83, // logical and (&amp;&amp;)
&gt;         INC         = 84, // increment/decrement (++ --)
&gt;         DEC         = 85,
&gt;         DOT         = 86, // member operator (.)
&gt;         FUNCTION    = 87, // function keyword
&gt;         EXPORT      = 88, // export keyword
&gt;         IMPORT      = 89, // import keyword
&gt;         IF          = 90, // if keyword
&gt;         ELSE        = 91, // else keyword
&gt;         SWITCH      = 92, // switch keyword
&gt;         CASE        = 93, // case keyword
&gt;         DEFAULT     = 94, // default keyword
&gt;         WHILE       = 95, // while keyword
&gt;         DO          = 96, // do keyword
&gt;         FOR         = 97, // for keyword
&gt;         BREAK       = 98, // break keyword
&gt;         CONTINUE    = 99, // continue keyword
&gt;         VAR         = 100, // var keyword
&gt;         WITH        = 101, // with keyword
&gt;         CATCH       = 102, // catch keyword
&gt;         FINALLY     = 103, // finally keyword
&gt;         VOID        = 104, // void keyword
&gt;         RESERVED    = 105, // reserved keywords
184c186
&lt;         EMPTY       = 104,
---
&gt;         EMPTY       = 106,
190,203c192,209
&lt;         BLOCK       = 105, // statement block
&lt;         ARRAYLIT    = 106, // array literal
&lt;         OBJLIT      = 107, // object literal
&lt;         LABEL       = 108, // label
&lt;         TARGET      = 109,
&lt;         LOOP        = 110,
&lt;         ENUMDONE    = 111,
&lt;         EXPRSTMT    = 112,
&lt;         PARENT      = 113,
&lt;         JSR         = 114,
&lt;         NEWLOCAL    = 115,
&lt;         USELOCAL    = 116,
&lt;         SCRIPT      = 117,   // top-level node for entire script
&lt;         TYPEOFNAME  = 118,  // for typeof(simple-name)
---
&gt;         BLOCK       = 107, // statement block
&gt;         ARRAYLIT    = 108, // array literal
&gt;         OBJLIT      = 109, // object literal
&gt;         LABEL       = 110, // label
&gt;         TARGET      = 111,
&gt;         LOOP        = 112,
&gt;         EXPRSTMT    = 113,
&gt;         PARENT      = 114,
&gt;         JSR         = 115,
&gt;         NEWTEMP     = 116,
&gt;         USETEMP     = 117,
&gt;         SCRIPT      = 118,   // top-level node for entire script
&gt;         TYPEOFNAME  = 119,  // for typeof(simple-name)
&gt;         USE_STACK   = 120,
&gt;         SETPROP_OP  = 121, // x.y op= something
&gt;         SETELEM_OP  = 122, // x[y] op= something
&gt;         INIT_LIST   = 123,
&gt;         LOCAL_BLOCK = 124,
205c211
&lt;         LAST_TOKEN  = 118;
---
&gt;         LAST_TOKEN  = 124;
211,328c217,341
&lt;                 case ERROR:           return "error";
&lt;                 case EOF:             return "eof";
&lt;                 case EOL:             return "eol";
&lt;                 case POPV:            return "popv";
&lt;                 case ENTERWITH:       return "enterwith";
&lt;                 case LEAVEWITH:       return "leavewith";
&lt;                 case RETURN:          return "return";
&lt;                 case GOTO:            return "goto";
&lt;                 case IFEQ:            return "ifeq";
&lt;                 case IFNE:            return "ifne";
&lt;                 case SETNAME:         return "setname";
&lt;                 case BITOR:           return "bitor";
&lt;                 case BITXOR:          return "bitxor";
&lt;                 case BITAND:          return "bitand";
&lt;                 case EQ:              return "eq";
&lt;                 case NE:              return "ne";
&lt;                 case LT:              return "lt";
&lt;                 case LE:              return "le";
&lt;                 case GT:              return "gt";
&lt;                 case GE:              return "ge";
&lt;                 case LSH:             return "lsh";
&lt;                 case RSH:             return "rsh";
&lt;                 case URSH:            return "ursh";
&lt;                 case ADD:             return "add";
&lt;                 case SUB:             return "sub";
&lt;                 case MUL:             return "mul";
&lt;                 case DIV:             return "div";
&lt;                 case MOD:             return "mod";
&lt;                 case NOT:             return "not";
&lt;                 case BITNOT:          return "bitnot";
&lt;                 case POS:             return "pos";
&lt;                 case NEG:             return "neg";
&lt;                 case NEW:             return "new";
&lt;                 case DELPROP:         return "delprop";
&lt;                 case TYPEOF:          return "typeof";
&lt;                 case GETPROP:         return "getprop";
&lt;                 case SETPROP:         return "setprop";
&lt;                 case GETELEM:         return "getelem";
&lt;                 case SETELEM:         return "setelem";
&lt;                 case CALL:            return "call";
&lt;                 case NAME:            return "name";
&lt;                 case NUMBER:          return "number";
&lt;                 case STRING:          return "string";
&lt;                 case ZERO:            return "zero";
&lt;                 case ONE:             return "one";
&lt;                 case NULL:            return "null";
&lt;                 case THIS:            return "this";
&lt;                 case FALSE:           return "false";
&lt;                 case TRUE:            return "true";
&lt;                 case SHEQ:            return "sheq";
&lt;                 case SHNE:            return "shne";
&lt;                 case REGEXP:          return "object";
&lt;                 case POP:             return "pop";
&lt;                 case BINDNAME:        return "bindname";
&lt;                 case THROW:           return "throw";
&lt;                 case IN:              return "in";
&lt;                 case INSTANCEOF:      return "instanceof";
&lt;                 case GETTHIS:         return "getthis";
&lt;                 case NEWTEMP:         return "newtemp";
&lt;                 case USETEMP:         return "usetemp";
&lt;                 case GETBASE:         return "getbase";
&lt;                 case GETVAR:          return "getvar";
&lt;                 case SETVAR:          return "setvar";
&lt;                 case UNDEFINED:       return "undefined";
&lt;                 case TRY:             return "try";
&lt;                 case NEWSCOPE:        return "newscope";
&lt;                 case ENUMINIT:        return "enuminit";
&lt;                 case ENUMNEXT:        return "enumnext";
&lt;                 case THISFN:          return "thisfn";
&lt;                 case SEMI:            return "semi";
&lt;                 case LB:              return "lb";
&lt;                 case RB:              return "rb";
&lt;                 case LC:              return "lc";
&lt;                 case RC:              return "rc";
&lt;                 case LP:              return "lp";
&lt;                 case RP:              return "rp";
&lt;                 case COMMA:           return "comma";
&lt;                 case ASSIGN:          return "assign";
&lt;                 case ASSIGNOP:        return "assignop";
&lt;                 case HOOK:            return "hook";
&lt;                 case COLON:           return "colon";
&lt;                 case OR:              return "or";
&lt;                 case AND:             return "and";
&lt;                 case INC:             return "inc";
&lt;                 case DEC:             return "dec";
&lt;                 case DOT:             return "dot";
&lt;                 case FUNCTION:        return "function";
&lt;                 case EXPORT:          return "export";
&lt;                 case IMPORT:          return "import";
&lt;                 case IF:              return "if";
&lt;                 case ELSE:            return "else";
&lt;                 case SWITCH:          return "switch";
&lt;                 case CASE:            return "case";
&lt;                 case DEFAULT:         return "default";
&lt;                 case WHILE:           return "while";
&lt;                 case DO:              return "do";
&lt;                 case FOR:             return "for";
&lt;                 case BREAK:           return "break";
&lt;                 case CONTINUE:        return "continue";
&lt;                 case VAR:             return "var";
&lt;                 case WITH:            return "with";
&lt;                 case CATCH:           return "catch";
&lt;                 case FINALLY:         return "finally";
&lt;                 case RESERVED:        return "reserved";
&lt;                 case EMPTY:           return "empty";
&lt;                 case BLOCK:           return "block";
&lt;                 case ARRAYLIT:        return "arraylit";
&lt;                 case OBJLIT:          return "objlit";
&lt;                 case LABEL:           return "label";
&lt;                 case TARGET:          return "target";
&lt;                 case LOOP:            return "loop";
&lt;                 case ENUMDONE:        return "enumdone";
&lt;                 case EXPRSTMT:        return "exprstmt";
&lt;                 case PARENT:          return "parent";
&lt;                 case JSR:             return "jsr";
&lt;                 case NEWLOCAL:        return "newlocal";
&lt;                 case USELOCAL:        return "uselocal";
&lt;                 case SCRIPT:          return "script";
---
&gt;                 case ERROR:           return "ERROR";
&gt;                 case EOF:             return "EOF";
&gt;                 case EOL:             return "EOL";
&gt;                 case POPV:            return "POPV";
&gt;                 case ENTERWITH:       return "ENTERWITH";
&gt;                 case LEAVEWITH:       return "LEAVEWITH";
&gt;                 case RETURN:          return "RETURN";
&gt;                 case GOTO:            return "GOTO";
&gt;                 case IFEQ:            return "IFEQ";
&gt;                 case IFNE:            return "IFNE";
&gt;                 case SETNAME:         return "SETNAME";
&gt;                 case BITOR:           return "BITOR";
&gt;                 case BITXOR:          return "BITXOR";
&gt;                 case BITAND:          return "BITAND";
&gt;                 case EQ:              return "EQ";
&gt;                 case NE:              return "NE";
&gt;                 case LT:              return "LT";
&gt;                 case LE:              return "LE";
&gt;                 case GT:              return "GT";
&gt;                 case GE:              return "GE";
&gt;                 case LSH:             return "LSH";
&gt;                 case RSH:             return "RSH";
&gt;                 case URSH:            return "URSH";
&gt;                 case ADD:             return "ADD";
&gt;                 case SUB:             return "SUB";
&gt;                 case MUL:             return "MUL";
&gt;                 case DIV:             return "DIV";
&gt;                 case MOD:             return "MOD";
&gt;                 case NOT:             return "NOT";
&gt;                 case BITNOT:          return "BITNOT";
&gt;                 case POS:             return "POS";
&gt;                 case NEG:             return "NEG";
&gt;                 case NEW:             return "NEW";
&gt;                 case DELPROP:         return "DELPROP";
&gt;                 case TYPEOF:          return "TYPEOF";
&gt;                 case GETPROP:         return "GETPROP";
&gt;                 case SETPROP:         return "SETPROP";
&gt;                 case GETELEM:         return "GETELEM";
&gt;                 case SETELEM:         return "SETELEM";
&gt;                 case CALL:            return "CALL";
&gt;                 case NAME:            return "NAME";
&gt;                 case NUMBER:          return "NUMBER";
&gt;                 case STRING:          return "STRING";
&gt;                 case ZERO:            return "ZERO";
&gt;                 case ONE:             return "ONE";
&gt;                 case NULL:            return "NULL";
&gt;                 case THIS:            return "THIS";
&gt;                 case FALSE:           return "FALSE";
&gt;                 case TRUE:            return "TRUE";
&gt;                 case SHEQ:            return "SHEQ";
&gt;                 case SHNE:            return "SHNE";
&gt;                 case REGEXP:          return "OBJECT";
&gt;                 case POP:             return "POP";
&gt;                 case BINDNAME:        return "BINDNAME";
&gt;                 case THROW:           return "THROW";
&gt;                 case IN:              return "IN";
&gt;                 case INSTANCEOF:      return "INSTANCEOF";
&gt;                 case LOCAL_SAVE:      return "LOCAL_SAVE";
&gt;                 case LOCAL_LOAD:      return "LOCAL_LOAD";
&gt;                 case GETBASE:         return "GETBASE";
&gt;                 case GETVAR:          return "GETVAR";
&gt;                 case SETVAR:          return "SETVAR";
&gt;                 case UNDEFINED:       return "UNDEFINED";
&gt;                 case GETTHIS:         return "GETTHIS";
&gt;                 case TRY:             return "TRY";
&gt;                 case CATCH_SCOPE:     return "CATCH_SCOPE";
&gt;                 case ENUM_INIT:       return "ENUM_INIT";
&gt;                 case ENUM_NEXT:       return "ENUM_NEXT";
&gt;                 case ENUM_ID:         return "ENUM_ID";
&gt;                 case THISFN:          return "THISFN";
&gt;                 case RETURN_POPV:     return "RETURN_POPV";
&gt;                 case SEMI:            return "SEMI";
&gt;                 case LB:              return "LB";
&gt;                 case RB:              return "RB";
&gt;                 case LC:              return "LC";
&gt;                 case RC:              return "RC";
&gt;                 case LP:              return "LP";
&gt;                 case RP:              return "RP";
&gt;                 case COMMA:           return "COMMA";
&gt;                 case ASSIGN:          return "ASSIGN";
&gt;                 case ASSIGNOP:        return "ASSIGNOP";
&gt;                 case HOOK:            return "HOOK";
&gt;                 case COLON:           return "COLON";
&gt;                 case OR:              return "OR";
&gt;                 case AND:             return "AND";
&gt;                 case INC:             return "INC";
&gt;                 case DEC:             return "DEC";
&gt;                 case DOT:             return "DOT";
&gt;                 case FUNCTION:        return "FUNCTION";
&gt;                 case EXPORT:          return "EXPORT";
&gt;                 case IMPORT:          return "IMPORT";
&gt;                 case IF:              return "IF";
&gt;                 case ELSE:            return "ELSE";
&gt;                 case SWITCH:          return "SWITCH";
&gt;                 case CASE:            return "CASE";
&gt;                 case DEFAULT:         return "DEFAULT";
&gt;                 case WHILE:           return "WHILE";
&gt;                 case DO:              return "DO";
&gt;                 case FOR:             return "FOR";
&gt;                 case BREAK:           return "BREAK";
&gt;                 case CONTINUE:        return "CONTINUE";
&gt;                 case VAR:             return "VAR";
&gt;                 case WITH:            return "WITH";
&gt;                 case CATCH:           return "CATCH";
&gt;                 case FINALLY:         return "FINALLY";
&gt;                 case RESERVED:        return "RESERVED";
&gt;                 case EMPTY:           return "EMPTY";
&gt;                 case BLOCK:           return "BLOCK";
&gt;                 case ARRAYLIT:        return "ARRAYLIT";
&gt;                 case OBJLIT:          return "OBJLIT";
&gt;                 case LABEL:           return "LABEL";
&gt;                 case TARGET:          return "TARGET";
&gt;                 case LOOP:            return "LOOP";
&gt;                 case EXPRSTMT:        return "EXPRSTMT";
&gt;                 case PARENT:          return "PARENT";
&gt;                 case JSR:             return "JSR";
&gt;                 case NEWTEMP:         return "NEWTEMP";
&gt;                 case USETEMP:         return "USETEMP";
&gt;                 case SCRIPT:          return "SCRIPT";
&gt;                 case TYPEOFNAME:      return "TYPEOFNAME";
&gt;                 case USE_STACK:       return "USE_STACK";
&gt;                 case SETPROP_OP:      return "SETPROP_OP";
&gt;                 case SETELEM_OP:      return "SETELEM_OP";
&gt;                 case INIT_LIST:       return "INIT_LIST";
&gt;                 case LOCAL_BLOCK:     return "LOCAL_BLOCK";
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/Context.java" revision="1.165" state="changed">2055c2055
&lt;         tree = compiler.transform(this, irf, tree);
---
&gt;         tree = compiler.transform(this, ts, tree);
</file>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/optimizer/FatBlock.java" revision="1.8" state="changed">43c43
&lt;     public FatBlock(IRFactory irFactory, int startNodeIndex, int endNodeIndex,
---
&gt;     public FatBlock(int startNodeIndex, int endNodeIndex,
46c46
&lt;         itsShadowOfFormerSelf = new Block(irFactory, startNodeIndex,
---
&gt;         itsShadowOfFormerSelf = new Block(startNodeIndex,
</file>
</fixedFiles>
</bug>
<bug id="271545" transactionid="67631">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M Y</fullfingerprint>
<bugreport>Werner Sharp wrote:
&gt; 
&gt; In the appendChild behavior below, it looks like Rhino is treating "new
&gt; XML()" different than "new XML("")".  The same issue appears when doing...
&gt; 
&gt; x = new XML();
&gt; x.a = "foo";
&gt; print (x.toXMLString());
&gt; x = new XML("");
&gt; x.a = "foo";
&gt; print (x.toXMLString());
&gt; 
&gt; The first case creates "&lt;a&gt;foo&lt;/a&gt;" while the second case does not.</bugreport>
<testsforfix id="271545" type="new">
<test file="mozilla/js/tests/e4x/Regress/regress-271545.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/xmlimplsrc/org/mozilla/javascript/xmlimpl/XML.java" revision="1.15" state="changed">3043c3043
&lt;             return createEmptyXML(lib);
---
&gt;             return createFromJS(lib, "");
</file>
</fixedFiles>
</bug>
<bug id="277935" transactionid="67998">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="10"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="10"/>
<property name="priority" value="--"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if M O-!= O-() O-&amp; T V Y Z-if</fullfingerprint>
<bugreport>Assignments like "msg..s = something" triggers failed assert exception at
runtime instead of proper syntax error during compile time. For example, the
following test case:

var msg =  &lt;foo&gt;&lt;bar&gt;&lt;s/&gt;&lt;/bar&gt;&lt;/foo&gt;
msg..s = "foo"

leads to:

Exception in thread "main" java.lang.IllegalStateException: FAILED ASSERTION
        at org.mozilla.javascript.Kit.codeBug(Kit.java:432)
        at org.mozilla.javascript.xmlimpl.XMLName.set(XMLName.java:130)
        at org.mozilla.javascript.ScriptRuntime.refSet(ScriptRuntime.java:1516)
        at org.mozilla.javascript.Interpreter.interpret(Interpreter.java:2828)
        at org.mozilla.javascript.Interpreter.interpret(Interpreter.java:2164)
        at
org.mozilla.javascript.InterpretedFunction.call(InterpretedFunction.java:140)

...

It was originally reported by ant_petra@hotmail.com :

-------- Original Message --------
Subject: E4X FAILED ASSERTION in Kit.codeBug(Kit.java:425)
Date: 11 Jan 2005 04:08:17 -0800
From: ant &lt;ant_petra@hotmail.com&gt;
Organization: http://groups.google.com
Newsgroups: netscape.public.mozilla.jseng

Is it valid to try to modify the contents of an XML element selected
with the dot-dot operator?

For example, using the msg defined below, if i try:

msg..s = "foo"

I get an assertion failed, whereas specifying the full path works fine:

msg.soap::Body.ns::reverse.s = "foo"

Thanks for any help.

...ant

Complete details are:

js&gt; msg
&lt;soapenv:Envelope
xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/"
xmlns:xsd="http://www
.w3.org/2001/XMLSchema"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
&lt;soapenv:Header/&gt;
&lt;soapenv:Body&gt;
&lt;p728:reverse xmlns:p728="http://ejbs"&gt;
&lt;s&gt;petra&lt;/s&gt;
&lt;/p728:reverse&gt;
&lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
js&gt; soap = new Namespace("http://schemas.xmlsoap.org/soap/envelope/")
http://schemas.xmlsoap.org/soap/envelope/
js&gt; ns = new Namespace("http://ejbs")
http://ejbs
js&gt; msg..s = "foo"
java.lang.IllegalStateException: FAILED ASSERTION
at org.mozilla.javascript.Kit.codeBug(Kit.java:425)
at org.mozilla.javascript.xmlimpl.XMLName.set(XMLName.java:130)
at
org.mozilla.javascript.ScriptRuntime.refSet(ScriptRuntime.java:1516)
at
org.mozilla.javascript.Interpreter.interpret(Interpreter.java:2828)
at
org.mozilla.javascript.Interpreter.interpret(Interpreter.java:2164)
at
org.mozilla.javascript.InterpretedFunction.call(InterpretedFunction.java:140)
at
org.mozilla.javascript.ContextFactory.doTopCall(ContextFactory.java:304)
at
org.mozilla.javascript.ScriptRuntime.doTopCall(ScriptRuntime.java:2769)
at
org.mozilla.javascript.Interpreter.interpret(Interpreter.java:2145)
at
org.mozilla.javascript.InterpretedFunction.call(InterpretedFunction.java:140)
at
org.mozilla.javascript.InterpretedFunction.exec(InterpretedFunction.java:149)
at
org.mozilla.javascript.Context.evaluateString(Context.java:1220)
at
org.mozilla.javascript.tools.shell.Main.evaluateScript(Main.java:453)
at
org.mozilla.javascript.tools.shell.Main.processSource(Main.java:341)
at
org.mozilla.javascript.tools.shell.Main.processFiles(Main.java:160)
at
org.mozilla.javascript.tools.shell.Main$IProxy.run(Main.java:83)
at org.mozilla.javascript.Context.call(Context.java:540)
at
org.mozilla.javascript.ContextFactory.call(ContextFactory.java:414)
at org.mozilla.javascript.tools.shell.Main.exec(Main.java:140)
at org.mozilla.javascript.tools.shell.Main.main(Main.java:112)</bugreport>
<testsforfix id="277935" type="new">
<test file="mozilla/js/tests/e4x/Regress/regress-277935.js"/>
</testsforfix>
<fixedFiles>
<file name="mozilla/js/rhino/src/org/mozilla/javascript/IRFactory.java" revision="1.98" state="changed">1241a1242
&gt;             checkMutableReference(ref);
1248a1250,1257
&gt;     private void checkMutableReference(Node n)
&gt;     {
&gt;         int memberTypeFlags = n.getIntProp(Node.MEMBER_TYPE_PROP, 0);
&gt;         if ((memberTypeFlags &amp; Node.DESCENDANTS_FLAG) != 0) {
&gt;             parser.reportError("msg.bad.assign.left");
&gt;         }
&gt;     }
&gt; 
1299a1309
&gt;             checkMutableReference(ref);
</file>
</fixedFiles>
</bug>
</bugrepository>
